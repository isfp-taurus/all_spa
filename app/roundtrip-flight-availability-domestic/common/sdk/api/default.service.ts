/**
 * aswbe search eapi（ShoppingShopping）
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import { Inject, Injectable, Optional } from '@angular/core';
import {
  HttpClient,
  HttpHeaders,
  HttpParams,
  HttpResponse,
  HttpEvent,
  HttpParameterCodec,
  HttpContext,
} from '@angular/common/http';
import { CustomHttpParameterCodec } from '../encoder';
import { Observable } from 'rxjs';
import { CaptchaAuthenticationRequest } from '../model/captchaAuthenticationRequest';
import { CaptchaAuthenticationResponse } from '../model/captchaAuthenticationResponse';
import { CaptchaAuthenticationStatusResponse } from '../model/captchaAuthenticationStatusResponse';
import { ComplexCalendarRequest } from '../model/complexCalendarRequest';
import { ComplexCalendarResponse } from '../model/complexCalendarResponse';
import { ComplexRequest } from '../model/complexRequest';
import { ComplexResponse } from '../model/complexResponse';
import { FavoritePostRequest } from '../model/favoritePostRequest';
import { FavoritePostResponse } from '../model/favoritePostResponse';
import { FindMoreFlightsRequest } from '../model/findMoreFlightsRequest';
import { FindMoreFlightsResponse } from '../model/findMoreFlightsResponse';
import { HistoryFavoriteDeleteRequest } from '../model/historyFavoriteDeleteRequest';
import { HistoryFavoriteGetResponse } from '../model/historyFavoriteGetResponse';
import { HistoryPostRequest } from '../model/historyPostRequest';
import { RoundtripFppRequest } from '../model/roundtripFppRequest';
import { RoundtripFppResponse } from '../model/roundtripFppResponse';
import { RoundtripOwdRequest } from '../model/roundtripOwdRequest';
import { RoundtripOwdResponse } from '../model/roundtripOwdResponse';
import { Type1 } from '../model/type1';
import { Type2 } from '../model/type2';
import { Type3 } from '../model/type3';
import { Type4 } from '../model/type4';
import { Type5 } from '../model/type5';
import { Type6 } from '../model/type6';
import { Type7 } from '../model/type7';
import { Type8 } from '../model/type8';
import { WaitlistGetSearchWaitlistResponse } from '../model/waitlistGetSearchWaitlistResponse';
import { BASE_PATH, COLLECTION_FORMATS } from '../variables';
import { Configuration } from '../configuration';

@Injectable({
  providedIn: 'root',
})
export class DefaultService {
  protected basePath = 'http://localhost';
  public defaultHeaders = new HttpHeaders();
  public configuration = new Configuration();
  public encoder: HttpParameterCodec;

  constructor(
    protected httpClient: HttpClient,
    @Optional() @Inject(BASE_PATH) basePath: string | string[],
    @Optional() configuration: Configuration
  ) {
    if (configuration) {
      this.configuration = configuration;
    }
    if (typeof this.configuration.basePath !== 'string') {
      if (Array.isArray(basePath) && basePath.length > 0) {
        basePath = basePath[0];
      }

      if (typeof basePath !== 'string') {
        basePath = this.basePath;
      }
      this.configuration.basePath = basePath;
    }
    this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
  }

  private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
    if (typeof value === 'object' && value instanceof Date === false) {
      httpParams = this.addToHttpParamsRecursive(httpParams, value);
    } else {
      httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
    }
    return httpParams;
  }

  private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
    if (value == null) {
      return httpParams;
    }

    if (typeof value === 'object') {
      if (Array.isArray(value)) {
        (value as any[]).forEach((elem) => (httpParams = this.addToHttpParamsRecursive(httpParams, elem, key)));
      } else if (value instanceof Date) {
        if (key != null) {
          httpParams = httpParams.append(key, (value as Date).toISOString().substr(0, 10));
        } else {
          throw Error('key may not be null if value is Date');
        }
      } else {
        Object.keys(value).forEach(
          (k) => (httpParams = this.addToHttpParamsRecursive(httpParams, value[k], key != null ? `${key}.${k}` : k))
        );
      }
    } else if (key != null) {
      httpParams = httpParams.append(key, value);
    } else {
      throw Error('key may not be null if value is not object or array');
    }
    return httpParams;
  }

  /**
   * # 1. 概要 リクエストパラメータを元に、reCAPTCHA又はkaptcha認証を実施し、認証結果を返却する。  # 2. 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、エラーハンドリング(API)(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。  1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。  1. リクエストパラメータの各項目を基に以下の通り画像認証を実施し、認証結果を求める。   1. 認証タイプが\&quot;reCAPTCHA\&quot;の場合、認証確認用アドレスに対して認証情報を送信する。   1. 認証タイプが\&quot;kaptcha\&quot;の場合、以下の処理を行う。     1. ASWDB(Tx)ユーザ共通の認証要否判定日時と現在日時の差が、設定ファイルの閾値を超えている場合は、タイムアウトエラーとし、ステータスコード403(Forbidden)を返却する。     1. ASWDB(Tx)ユーザ共通のkaptcha文字列を取得し、パラメータの入力文字と比較する。       一致する場合は画像認証成功、不一致の場合は画像認証失敗と判定する。  1. 認証結果をASWDB(Tx)のユーザ共通に登録する。 1. 画像認証成功の場合は、Cookie(Cookie名\&quot;srchclntkey\&quot;)に、画像認証「成功」を表す旨として、クライアントのIPアドレス、検索条件の第一出発空港に紐づく都市、画像認証用固定文字列(設定ファイルにて管理)を\&quot;_\&quot;(アンダーバー)で連結し、AESで暗号化した文字列を登録する。また、有効期限1年を付与する。 1. ステータスコード200(正常)を返却し、処理を終了する。
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public captchaAuthenticationPost(
    generated?: CaptchaAuthenticationRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<CaptchaAuthenticationResponse>;
  public captchaAuthenticationPost(
    generated?: CaptchaAuthenticationRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<CaptchaAuthenticationResponse>>;
  public captchaAuthenticationPost(
    generated?: CaptchaAuthenticationRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<CaptchaAuthenticationResponse>>;
  public captchaAuthenticationPost(
    generated?: CaptchaAuthenticationRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/captcha-authentication`;
    return this.httpClient.request<CaptchaAuthenticationResponse>(
      'post',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: generated,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * # 1. 概要 ロボットのクローラによる有害な空席照会アクセス等をブロックするため、reCAPTCHAまたはkaptchaによる画像認証要否判定を行う。 1. リクエストパラメータを元に、画像認証表示要否の判定を行い、判定結果を返却する。&lt;br&gt;一般ユーザに対して認証が表示されすぎることを避けるため、認証に成功した場合ASWDB(Tx)のユーザ共通に画像認証成功の旨を保持し、成功の旨の有無に応じて再認証要否を決定する。認証成功の旨の有無に応じた各判定は、以下の3段階で実施する。   1. 常に行うチェック&lt;br&gt;認証に成功しているかどうかに問わず必ず行う判定。同一セッション内で一度認証に成功した場合でも、条件に合致した場合はCAPTCHA表示（またはアクセス拒否/スキップ）とする。&lt;br&gt;クローラが画像認証を経ず、直接空席照会にアクセスした場合に備え、空席照会APIでも以下の対策を講ずる。     1. 当APIの常に行うチェックと同等のチェックを実施する。     1. ASWDB(マスタ)の制限レベルが\&quot;CAPTCHA\&quot;のクライアントの場合、アクセスの都度画像認証を必須とし、ASWDB(Tx)の画像認証成功の旨の有無で判定する。     1. 特定区間に対する空席照会件数をカウントし、閾値を超えた場合アクセスをブロックする。      1. Cookieより強いチェック&lt;br&gt;ASWDB(Tx)のユーザ共通が画像認証成功の場合は行わないが、Cookieのみ認証成功の旨を保持をしている場合でも行う判定。同一セッション内で一度認証に成功した場合は実施されないが、ASW TOP等から再流入した場合は再判定を行う。    1. Cookieより弱いチェック&lt;br&gt;ASWDB(Tx)のユーザ共通にもCookieにも画像認証成功を保持していない場合に行う判定。一度認証に成功した後は、Cookieの削除または有効期限切れとなるまで再判定しない。  1. 画像認証は原則reCAPTCHAを使用するが、reCAPTCHA使用不可となる場合にはkaptchaを使用する。&lt;br&gt;画像認証要否判定が「要」の場合は、reCAPTCHA利用可否判定を行い、判定結果及び認証に必要な情報も併せて返却する。&lt;br&gt;以下のいずれか場合はreCAPTCHA使用不可と判定する。   1. 中国ではGoogleへの通信が遮断されるため、操作オフィスのPOSが中国の場合   1. ANAアプリのブラウザではreCAPTCHAが動作しないため、ANAアプリの場合   1. reCAPTCHA利用設定をオフにしている場合   1. ASWDB(マスタ)から取得したreCAPTCHAの動作状況が正常動作でない場合  # 2. 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、エラーハンドリング(API)(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。  1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてCookie、アクセストークンの有効性確認およびTTL(有効期限)延長を行う。有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。  1. 認可検証APIより返却されたuuidを基に、ASWDB(Tx)からパーソナライズ情報を取得する。以下の条件に合致する場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。     1. パーソナライズ情報のログインステータスが取得できない    1. 常に行うチェックとして、クライアントのIPアドレスがASWDB(マスタ)のロボットIPアドレスに該当する場合、制限レベルに応じて以下の処理を実施する。   1. \&quot;BLOCK\&quot;の場合、ASWDB(Tx)のユーザ共通に画像認証「失敗」を登録し、ステータスコード200(正常)を返却し処理を終了する。   1. \&quot;WHITELIST\&quot;の場合、ASWDB(Tx)のユーザ共通に画像認証「成功」を登録し、ステータスコード200(正常)を返却し処理を終了する。   1. \&quot;CAPTCHA\&quot;の場合、認証の種類を決定する処理を行う。  1. ASWDB(Tx)のユーザ共通が画像認証「成功」を保持している場合、ステータスコード200(正常)を返却し処理を終了する。  1. Cookieより強いチェックとして、出発地・到着地都市コードがASWDB(マスタ)の画像認証表示対象区間に該当するかを確認する。&lt;br&gt;該当する場合は、認証の種類を決定する処理を行う。該当しない、かつ、Cookieを復号しCookieが保持する内容が、今回検索時のIPアドレス、検索条件の第一出発都市と一致する場合は、Cookieが画像認証「成功」を保持していると判定し、ステータスコード200(正常)を返却し処理を終了する。&lt;br&gt;※Cookieの復号に失敗、または復号したCookieが登録時に登録した形式(詳細は画像認証API参照)でない場合は、「成功」を保持していない扱いとする。  1. Cookieより弱いチェックとして、以下の処理を行う。&lt;br&gt;以下のいずれかに該当する場合は、認証の種類を決定する処理を行う。&lt;br&gt;該当しない場合はASWDB(Tx)のユーザ共通に画像認証「成功」を登録し、ステータスコード200(正常)を返却し処理を終了する。   1. Akamai Bot Managerによる判定結果がBotの疑いがあると判断された     1. 以下の順で求めた値(画像認証表示率)と、0から100未満の間で求めた乱数を比較し、乱数が画像認証表示率未満である     1. 操作オフィス・デバイス・言語・検索条件の出発国・ログインステータスの組み合わせに紐づく、設定ファイルの画像認証表示比率     1. 上記が存在しない場合、操作オフィス・デバイス・言語・ログインステータスの組み合わせに紐づく、設定ファイルの画像認証表示比率  1. 認証の種類を決定する。以下のいずれかに該当する場合はkaptchaとし、それ以外はreCAPTCHAとする。   1. 操作オフィスに紐づくASWDB(マスタ)のPOSが中国   1. ブラウザ種別がANAアプリ   1. 設定ファイルのreCAPTCHAの使用設定がOFF   1. ASWDB(マスタ)のreCAPTCHA動作状況が正常動作でない  1. 認証の種類がkaptchaの場合、kaptcha認証のための文字列並びに画像を生成し、文字列はASWDB(Tx)にアクセストークンに紐づく情報として登録、画像は画像ファイルとしてS3ストレージに保存する。   また、ASWDB(Tx)登録時は、TTLとして現在時刻＋設定ファイルのkaptcha認証画像有効時間を設定する。  1. ASWDB(Tx)のユーザ共通に画像認証「要」を登録し、ステータスコード200(正常)を返却し処理を終了する。  # 3. データ更新内容 1. ASWDB(Tx) |更新テーブル|更新内容|データ取得元|条件等| |:---|:---|:---|:---| |S2パーソナライズ情報|kaptcha認証文字列、kaptcha画像ファイル保存先のパス、kaptcha有効時間を登録|kaptcha関連情報は、当APIにて生成|認証要否判定結果が要、かつ認証の種類がkaptchaの場合|  # 4. 特記事項 1. kaptcha認証のための画像・認証キーの生成は、Google社提供のjarを利用する必要があるため、当該機能はJavaで開発しMuleSoftから呼び出す形をとる。
   * @param originLocationCode 出発地   照会用空港コード、都市コードの3レター   但し、空港コードの場合には、後ろに「+」を付けること   (例)   上海（空港コード）：SHA+   上海（都市コード）：SHA
   * @param destinationLocationCode 到着地   照会用空港コード、都市コードの3レター   但し、空港コードの場合には、後ろに「+」を付けること   (例)   上海（空港コード）：SHA+   上海（都市コード）：SHA
   * @param botManagerCheckResult Akamai Bot ManagerによりBotの疑いありと判定された場合true   ※本パラメータはSPAからの呼出し後、Akamai Bot Managerにより付加されるため、SPAでの設定は不要
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public captchaAuthenticationStatusGet(
    originLocationCode: string,
    destinationLocationCode: string,
    botManagerCheckResult?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<CaptchaAuthenticationStatusResponse>;
  public captchaAuthenticationStatusGet(
    originLocationCode: string,
    destinationLocationCode: string,
    botManagerCheckResult?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<CaptchaAuthenticationStatusResponse>>;
  public captchaAuthenticationStatusGet(
    originLocationCode: string,
    destinationLocationCode: string,
    botManagerCheckResult?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<CaptchaAuthenticationStatusResponse>>;
  public captchaAuthenticationStatusGet(
    originLocationCode: string,
    destinationLocationCode: string,
    botManagerCheckResult?: string,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    if (originLocationCode === null || originLocationCode === undefined) {
      throw new Error(
        'Required parameter originLocationCode was null or undefined when calling captchaAuthenticationStatusGet.'
      );
    }
    if (destinationLocationCode === null || destinationLocationCode === undefined) {
      throw new Error(
        'Required parameter destinationLocationCode was null or undefined when calling captchaAuthenticationStatusGet.'
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (originLocationCode !== undefined && originLocationCode !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>originLocationCode,
        'originLocationCode'
      );
    }
    if (destinationLocationCode !== undefined && destinationLocationCode !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>destinationLocationCode,
        'destinationLocationCode'
      );
    }
    if (botManagerCheckResult !== undefined && botManagerCheckResult !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>botManagerCheckResult,
        'BotManagerCheckResult'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/captcha-authentication-status`;
    return this.httpClient.request<CaptchaAuthenticationStatusResponse>(
      'get',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * # 1. 概要 1. 呼び出し元より渡された検索条件を基にDxAPIにて複雑カレンダー空席照会結果を行い、バウンド数に応じてDxAPIが返却可能な日付範囲の検索結果を返却する。 |検索バウンド数|回答日付範囲| |---:|:---| |3|5日間（検索日付を軸に±2日）| |4|3日間（検索日付を軸に±1日）| |5|3日間（検索日付を軸に±1日）|    バウンド数が6の場合、回答日付範囲1日間となり、カレンダー表示としての意味をなさないため、その場合にはエラーを返却する。&lt;br&gt;   なお返却される各バウンドの日付の組み合わせについては、検索条件に指定した日付を軸に、全バウンドの日付を同じ数だけずらした結果（滞在日数を固定して、出発日付をずらした結果）のみを返却する。例えば「4/10、4/14、4/17、4/20」の4バウンドを検索した場合、「4/10、4/14、4/17、4/20」を軸に、全バウンドの日付を同じ数ずらした「4/9、4/13、4/16、4/19」「4/11、4/15、4/18、4/21」の3つの組合せのみとなる。  # 2. 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、エラーハンドリング(API)(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返却する。 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。   有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。   1. 認可検証APIより返却されたuuidを基に、ASWDB(Tx)からパーソナライズ情報を取得する。 1. ASWDB(Tx)のカート情報が存在しない場合、往復指定日空席照会(OWD)用APIの【IPアドレスの制限レベルに基づく認証処理】を実行する。   1. 【法人ログインチェック処理】として、以下の処理を行う。     1. リクエストヘッダのCookieにcompanyRealが存在する場合、パーソナライズ情報内のログイン済み法人企業情報を取得する。法人企業情報を取得できなかった場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。 1. 全空港の照会用空港コードに紐づく国コードが日本（以降、日本国内単独旅程）である、かつ出発日がDCS移行開始日付(設定ファイルにて定義)以降の場合、搭乗者種別がB15の人数をADTへ合算し、B15の人数を0とする。 1. リクエストパラメータについて、以下いずれかに合致する場合、エラー項目及びエラー内容と共にステータスコード400(Bad request)でエラー情報を返却し、本処理を中止とする。   1. 出発空港、到着空港、乗り継ぎ空港が、ASWDB(マスタ)の照会用空港コードとして存在しない。     1. 日本国内単独旅程である、かつバウンドのいずれかの出発日がDCS移行開始日付よりも前、かつ操作オフィスのPOSが日本である。   1. パーソナライズ情報にANA Biz会員のログイン企業情報が存在する、かつ出発日がDCS移行開始日付以降の日本国内単独旅程以外である。   1. ARNK区間（接続するバウンドの到着空港コードと出発空港コードに紐づく都市コードが異なる区間）を1区間として換算し、ARNK区間を含むバウンドの合計数が6バウンド以上である。       例：ITM-HND、NRT-LAX、SFO-ITMで検索の場合、LAXとSFO間がARNK区間となるため、都合4バウンドとして扱う。   1. 1バウンド目出発空港の照会用空港コードに紐づく、ASWDB(マスタ)の有償表示フラグが“出発地＆目的地\&quot; または \&quot;出発地\&quot;でない。   1. 操作オフィスがAPF(TYONH08AP)の場合で、1バウンド目出発空港の照会用空港コードに紐づく、ASWDB(マスタ)の国コードが日本でない。   1. 1バウンド目出発空港以外のいずれかの照会用出発空港コードに紐づく、ASWDB(マスタ)の有償表示フラグが\&quot;出発地＆目的地\&quot;または \&quot;目的地\&quot;でない。   1. バウンドの出発空港と到着空港それぞれに紐づくASWDB(マスタ)の都市コードが同一となるバウンドがある。   1. 1バウンド目出発空港の国コードと、各バウンドの出発空港の国コードが同一かつ、そのバウンドの発着空港の国コードが同一ではない場合をカウントし、2件以上カウントされた。   1. 1バウンド目出発空港の国コードと、各バウンドの到着空港の国コードが同一かつ、そのバウンドの発着空港の国コードが同一ではない場合カウントし、2件以上カウントされた。   1. 操作オフィスに紐づくASWDB(マスタ)のPOSがアメリカで、照会用空港コードに紐づく国コードがキューバの空港を含んでいる。   1. 出発年月日が、オフィスコードをキーにした該当の国の時差を考慮した上で、ローカル日付から数えて設定ファイルに定義した日数の期間外である。   1. バウンドの要素順に、各バウンドの出発年月日が直前のバウンドの出発年月日よりも前である。     1. 出発開始時刻と出発終了時刻のいずれかのみ設定されている。   1. 出発開始時刻が、出発終了時刻以降の時刻になっている。   1. 出発開始時刻と出発終了時刻の時刻の差が2の倍数となる整数値の時間でない。ただし、出発時刻が\&quot;23:59:00\&quot;の場合は、差分に1分を加算した値を用いて判定する。   1. 搭乗者の組み合わせについて、下記のいずれかに合致する。       1. ADT/B15/CHD/INFの合計人数が0名である。     1. ADTの人数がINFの人数よりも少ない。     1. ADT/B15/CHDの合計人数が、10名以上である。     1. 日本国内単独旅程、かつ出発日がDCS移行開始日付以降である、かつ下記のいずれかに合致する。         1. ADTが0名かつ、INFの合計人数が１名以上である。         1. ADT/CHDの合計人数が、0名である。     1. 上記以外で、かつ下記のいずれかに合致する。         1. ADTが0名かつ、CHDとINFの合計人数が1名以上である。         1. ADTとB15の合計人数が、0名である。         1. 日本国内単独旅程であった場合に、INFの人数が1名以上である。   1. ASWDB(マスタ)より、以下条件(表)に該当するCFF区分かつ、Mixed Cabin Class検索用の区分が「Mixed Cabin Classで検索不可」もしくは「Mixed Cabin ClassとMixed Cabin Classではない検索ともに可能」かつ、該当するキャビンクラス、運賃オプションタイプに合致するCFFが存在しない。また、ANA Biz会員ログイン企業情報が存在する場合は、更に上記条件に合致したCFFが、ANA Biz会員のログイン企業情報の該当するキャビンクラスのCFFリストに存在しない。   |ANA Biz会員のログイン企業情報|旅程|出発日|操作オフィスのPOS|CFF区分| |:---|:---|:---|:---|:---| |存在しない|日本国内単独|DCS移行開始日付よりも前|-|有償日本国内線単独運賃(DCS移行開始日前)| |存在しない|日本国内単独|DCS移行開始日付以降|日本|日本POS用、有償日本国内線単独運賃(DCS移行開始日以降)| |存在しない|日本国内単独|DCS移行開始日付以降|日本以外|海外POS用、有償日本国内線単独運賃(DCS移行開始日以降)| |存在しない|国際|-|-|有償国際線運賃| |存在する|-|-|-|ANA Biz|    1. プロモーションコードの指定がある場合、ASWDB(マスタ)よりオフィスコードに紐づくプロモーション利用可否を取得し、利用不可である。 1. 往復指定日空席照会(OWD)用APIの【空席照会回数に基づくアクセス制限処理】を実行する。 1. 下記処理を実行の上で、ステータスコード200(正常)として複雑カレンダー空席照会結果を返却する。   1. DxAPIへのリクエストパラメータとしてのプロモーションコードは、指定されたプロモーションコードがASWDB(マスタ)にCAT25として存在している場合には紐づくアカウントコードを指定する。存在しない場合にはAAMによるプロモーションコードとみなし、指定された値をそのまま指定する。   1. 呼び出し元より渡された出発、到着空港コードそれぞれにおいて、都市コードか空港コードいずれであるかを下記の通り判断の上、DxAPIのリクエストパラメータとしてlocationTypeを指定する。     1. 呼び出し元より渡された各空港コードに、「+」が付与されている場合は、照会用空港コードとして判定。     1. 呼び出し元より渡された各空港コードが、ASWDB(マスタ)の都市コードと一致する場合には、都市コードとして判定。     1. 上記以外の場合には、空港コードとして判定。     1. 呼び出し元より渡された運賃情報を基に、ASWDB(マスタ)に定義したカレンダー検索用のCFFコードを抽出して、DxAPIへのリクエストパラメータのCFFとして指定する。   1. ASWDB(マスタ)より取得したCFFにPricing PTCが存在する場合、そのPricing PTCを全てDxAPIへのリクエストパラメータのPricing PTCとして搭乗者毎に指定する。ただし、小児又は幼児、かつ運賃オプションタイプが「障がい割」の場合、当該搭乗者のPricing PTCは指定しない。   1. 呼び出し元より渡された検索条件に基づきDxAPIにリクエストを行い、複雑カレンダー空席照会結果を取得する。なお、日付範囲については、設定ファイルよりバウンド数に応じた日数を取得し、条件として指定する。   1. DxAPIの検索結果に対して、検索条件に指定した日付を軸に、全バウンドの日付を同じ数だけずらした結果（滞在日数を固定して、出発日付をずらした結果）以外を除外する。   1. 除外した結果、検索結果を得られなかった場合には、ASWDB(マスタ)に定義する検索条件のCFFに紐づく上位CFFの有無をチェックし、存在する場合は上位CFFにより自動再検索を行う。それでも検索結果を得られなかった場合、warning情報のみ（dataは返却しない）を返却する。  # 3. データ更新内容 なし  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public complexCalendarPost(
    generated?: ComplexCalendarRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<ComplexCalendarResponse>;
  public complexCalendarPost(
    generated?: ComplexCalendarRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<ComplexCalendarResponse>>;
  public complexCalendarPost(
    generated?: ComplexCalendarRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<ComplexCalendarResponse>>;
  public complexCalendarPost(
    generated?: ComplexCalendarRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/complex-calendar`;
    return this.httpClient.request<ComplexCalendarResponse>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要 呼び出し元より渡された検索条件を基にDxAPIにて複雑空席照会を行い、検索結果からおすすめ旅程として適した旅程を返却する。  # 2. 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、エラーハンドリング(API)(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返却する。 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。  1. 認可検証APIより返却されたuuidを基に、ASWDB(Tx)からパーソナライズ情報を取得する。 1. ASWDB(Tx)のカート情報が存在しない場合、往復指定日空席照会(OWD)用APIの【IPアドレスの制限レベルに基づく認証処理】を実行する。 1. 複雑カレンダー空席照会APIの【法人ログインチェック処理】を実行する。  1. 全空港の照会用空港コードに紐づく国コードが日本（日本国内単独旅程）である、かつ出発日がDCS移行開始日付(設定ファイルに定義)以降の場合、搭乗者種別がB15の人数をADTへ合算し、B15の人数を0とする。 1. リクエストパラメータについて、以下いずれかに合致する場合、エラー項目及びエラー内容と共にステータスコード400(Bad request)でエラー情報を返却し、本処理を中止とする。【複雑空席照会入力チェック処理】   1. 出発空港、到着空港、乗り継ぎ空港が、ASWDB(マスタ)の照会用空港コードとして存在しない。   1. 日本国内単独旅程である、かつバウンドのいずれかの出発日がDCS移行開始日付よりも前、かつ操作オフィスのPOSが日本である。   1. パーソナライズ情報にANA Biz会員のログイン企業情報が存在する、かつ出発日がDCS移行開始日付以降の日本国内単独旅程以外である。   1. 1バウンド目出発空港の照会用空港コードに紐づく、ASWDB(マスタ)の有償表示フラグが“出発地＆目的地\&quot; または \&quot;出発地\&quot;でない。   1. 操作オフィスがAPF(TYONH08AP)の場合で、1バウンド目出発空港の照会用空港コードに紐づく、ASWDB(マスタ)の国コードが日本でない。   1. 1バウンド目出発空港以外のいずれかの照会用出発空港コードに紐づく、ASWDB(マスタ)の有償表示フラグが\&quot;出発地＆目的地\&quot;または \&quot;目的地\&quot;でない。   1. バウンドの出発空港と到着空港それぞれに紐づくASWDB(マスタ)の都市コードが同一となるバウンドがある。   1. 1バウンド目出発空港の国コードと、各バウンドの出発空港の国コードが同一かつ、そのバウンドの発着空港の国コードが同一ではない場合をカウントし、2件以上カウントされた。   1. 1バウンド目出発空港の国コードと、各バウンドの到着空港の国コードが同一かつ、そのバウンドの発着空港の国コードが同一ではない場合カウントし、2件以上カウントされた。   1. 操作オフィスに紐づくASWDB(マスタ)のPOSがアメリカで、照会用空港コードに紐づく国コードがキューバの空港を含んでいる。   1. 出発年月日が、オフィスコードをキーにした該当の国の時差を考慮した上で、ローカル日付から数えて設定ファイルに定義した日数の期間外である。   1. バウンドの要素順に、各バウンドの出発年月日が直前のバウンドの出発年月日よりも前である。   1. 出発開始時刻と出発終了時刻のいずれかのみ設定されている。   1. 出発開始時刻が、出発終了時刻以降の時刻になっている。   1. 出発開始時刻と出発終了時刻の時刻の差が2の倍数となる整数値の時間でない。ただし、出発時刻が\&quot;23:59:00\&quot;の場合は、差分に1分を加算した値を用いて判定する。   1. 搭乗者の組み合わせついて、下記のいずれかに合致する。     1. ADT/B15/CHD/INFの合計人数が0名である。     1. ADTの人数がINFの人数よりも少ない。     1. ADT/B15/CHDの合計人数が、10名以上である。     1. 日本国内単独旅程、かつ出発日がDCS移行開始日付以降である、かつ下記のいずれかに合致する。         1. ADTが0名かつ、INFの合計人数が１名以上である。         1. ADT/CHDの合計人数が、0名である。     1. 上記以外で、かつ下記のいずれかに合致する。         1. ADTが0名かつ、CHDとINFの合計人数が1名以上である。         1. ADTとB15の合計人数が、0名である。         1. 日本国内単独旅程の場合、INFの人数が1名以上である。   1. ASWDB(マスタ)より、以下条件(表)に該当するCFF区分かつ、Mixed Cabin Class検索用の区分が「Mixed Cabin Classで検索不可」もしくは「Mixed Cabin ClassとMixed Cabin Classではない検索ともに可能」かつ、該当するキャビンクラス、運賃オプションタイプに合致するCFFが存在しない。また、ANA Biz会員ログイン企業情報が存在する場合は、更に上記条件に合致したCFFが、ANA Biz会員のログイン企業情報の該当するキャビンクラスのCFFリストに存在しない。   |ANA Biz会員のログイン企業情報|旅程|出発日|操作オフィスのPOS|CFF区分| |:---|:---|:---|:---|:---| |存在しない|日本国内単独|DCS移行開始日付よりも前|-|有償日本国内線単独運賃(DCS移行開始日前)| |存在しない|日本国内単独|DCS移行開始日付以降|日本|日本POS用、有償日本国内線単独運賃(DCS移行開始日以降)| |存在しない|日本国内単独|DCS移行開始日付以降|日本以外|海外POS用、有償日本国内線単独運賃(DCS移行開始日以降)| |存在しない|国際|-|-|有償国際線運賃| |存在する|-|-|-|ANA Biz|    1. プロモーションコードの指定がある場合、ASWDB(マスタ)よりオフィスコードに紐づくプロモーション利用可否を取得し、利用不可である。 1. 往復指定日空席照会(OWD)用APIの【空席照会回数に基づくアクセス制限処理】を実行する。 1. 下記処理を実行の上で、ステータスコード200(正常)として複雑空席照会結果を返却する。   1. DxAPIへのリクエストパラメータとしてのプロモーションコードは、指定されたプロモーションコードがASWDB(マスタ)にCAT25として存在している場合には紐づくアカウントコードを指定する。存在しない場合にはAAMによるプロモーションコードとみなし、指定された値をそのまま指定する。   1. 呼び出し元より渡された出発、到着空港コードそれぞれにおいて、都市コードか空港コードいずれであるかを下記の通り判断の上、DxAPIのリクエストパラメータとしてlocationTypeを指定する。     1. 呼び出し元より渡された各空港コードに、「+」が付与されている場合は、照会用空港コードとして判定。     1. 呼び出し元より渡された各空港コードが、ASWDB(マスタ)の都市コードと一致する場合には、都市コードとして判定。     1. 上記以外の場合には、空港コードとして判定。   1. ASWDB(マスタ)より取得したCFFにPricing PTCが存在する場合、そのPricing PTCを全てDxAPIへのリクエストパラメータのPricing PTCとして搭乗者毎に指定する。ただし、小児又は幼児、かつ運賃オプションタイプが「障がい割」の場合、当該搭乗者のPricing PTCは指定しない。   1. 日本国内単独旅程、かつ出発日がDCS移行開始日付以降の場合、DxAPIへのリクエストパラメータに対して、空席待ちを含めた結果を返却するよう指定する。   1. 呼び出し元より渡された検索条件に基づきDxAPIにリクエストを行い、複雑空席照会結果を取得する。CFFについては呼び出し元より渡された運賃情報を基に、ASWDB(マスタ)に定義した複雑空席照会用のCFFコードを指定する。ただしANA Biz会員のログイン企業情報が存在する場合は、呼び出し元より渡されたキャビンクラスに応じたログイン企業情報の表示対象CFFリストの1件目のCFFコードに対応する複雑空席照会用のCFFコードとする。   1. 検索結果に対し、以下の通り【検索結果の書き換え処理】を実施する。     1. 最終発券期限を過ぎている、もしくは、セグメントのキャビンクラスにAirOfferのFFのキャビンクラスより上位となるキャビンクラスが含まれている場合には、検索結果対象から除去する。但し、キャビンクラスによる除去判定対象は、国際旅程の場合日本発着のセグメント、日本国内単独旅程の場合は全セグメントを判定対象とする。       なお、最終発券期限の判定は以下の通りとし、出発時刻はその空港のタイムゾーンの時刻となっているため、比較時は現在時刻に対してASWDB(マスタ)から空港コードをキーに取得した時差を考慮する。         1. 日本国内単独旅程、かつ出発日がDCS移行開始日付以降、かつ以下のいずれかが合致した場合、最終発券期限を過ぎているとする。           1. 第1バウンド第1セグメントの出発時刻までの時間が20分未満である。           1. 運航キャリアがPeach(MM)、かつ出発時刻までの時間が3時間未満であるセグメントを含む。           1. 空席待ち、かつ設定ファイルに設定された最終空席待ち期限を過ぎているセグメントを含む。         1. 上記以外の場合、第1バウンド第1セグメントの出発時刻まで6時間未満である。    1. 以下の条件に合致する場合、ASWDB(マスタ)に定義する検索条件のCFFに紐づく上位CFFの有無をチェックし、存在する場合は上位CFFにより自動再検索を行う。再検索結果に対しても【検索結果の書き換え処理】を実施する。      1. 残席があるAirOfferを含む検索結果が得られなかった場合。       ※搭乗者数&gt;残席数のセグメントを含む場合も、残席なしとして扱う。       ※空席待ちで返却された場合でも残席なしとして扱う。     1. 検索条件のCFFに紐づくキャビンクラスの結果が得られなかった場合。   1. 検索結果を得られなかった場合、warning情報のみ（dataは返却しない）を返却する。   1. 検索結果のうち、それぞれのFFごとに空席があるAirOfferの中で最安となるAirOfferを、返却するFF毎のおすすめ旅程として決定する。ただし、おすすめ旅程を決定するにあたり、以下の点を考慮する。     1. 日本国内単独旅程、かつ出発日がDCS移行開始日付以降の場合、おすすめ旅程選定において、空席待ちセグメントを含むAirOffer除去したうえで決定する。ただし、FF毎に、空席待ちセグメントを含むAirOfferの他に有効なAirOfferが存在しない場合、空席待ちセグメントを含むAirOfferの内最安となるAirOfferをおすすめ旅程とする。空席待ちセグメントを含むAirOfferも存在しないFFについては、おすすめ旅程は返却せず、検索結果売り切れ判定:trueとして返却する。       ※ただし、ASWDB(マスタ)に設定された最終空席待ち期限を過ぎている空席待ちセグメントは、残席なしとして扱う。     1. 上記以外の場合、空席のあるAirOfferが得られなかったFFについては、おすすめ旅程は返却せず、検索結果売り切れ判定:trueとして返却する。   1. 以下の通り、最新の運航情報を取得する。     1. リクエストパラメータの検索結果に最新の運航情報を含める処理の実行要否がtrueの場合、TSリスト中に含まれるNHグループ運航国際便、NHグループ便名国内線のうち、出発予定時刻(STD)までの時間が48時間以内であるセグメントについて、発着APIより最新の運航情報を取得する。   1. 往復指定日空席照会(OWD)APIの【Wi-Fi情報取得処理】を実行する。  # 3. データ更新内容 なし  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public complexTripPost(
    generated?: ComplexRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<ComplexResponse>;
  public complexTripPost(
    generated?: ComplexRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<ComplexResponse>>;
  public complexTripPost(
    generated?: ComplexRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<ComplexResponse>>;
  public complexTripPost(
    generated?: ComplexRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/complex-trip`;
    return this.httpClient.request<ComplexResponse>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要 検索条件情報を、お気に入り情報としてASWDB(Tx)に対して登録する。  # 2. 処理内容 1. 【フライト検索条件登録共通処理】として、以下の処理を実行する。   1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、エラーハンドリング(API)(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。   1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。   1. 認可検証APIより返却されたuuidを基に、ASWDB(Tx)からパーソナライズ情報を取得する。以下の条件のいずれかに合致する場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。       1. パーソナライズ情報のログインステータスが取得できない       1. パーソナライズ情報のログインステータスが未ログインである       1. パーソナライズ情報から会員番号を取得できない   1. リクエストパラメータの入力チェックとして、以下処理を実施する。     1. 全空港の照会用空港コードに紐づく国コードが日本(日本国内単独旅程)、かつ出発日にDCS移行開始日付前を含む、かつ操作オフィスのPOSが日本の場合、エラー項目及びエラー内容と共にステータスコード400(Bad request)でエラー情報を返却し、本処理を中止とする。     1. 旅程タイプが往復旅程の場合、もしくは旅程タイプが片道又は複雑旅程、かつバウンドリストの要素数&#x3D;1(片道)または2(往復又はオープンジョー)の場合、以下の処理を行う。         1. 全空港の照会用空港コードに紐づく国コードが日本(日本国内単独旅程)、かつ全ての出発日がDCS移行開始日付以降の場合、往復指定日空席照会(FPP)用APIの【往復空席照会入力チェック処理】         1. 上記以外の場合、往復指定日空席照会(OWD)用APIの【往復空席照会入力チェック処理】     1. 上記以外の場合、複雑空席照会APIの【複雑空席照会入力チェック処理】 1. AMC会員番号をキーにASWDB(Tx)からお気に入り検索条件を取得し、取得した検索条件にリクエストパラメータと同一条件の検索条件が既に登録済みである場合、重複レコードを削除する。また、取得した検索条件と同一条件ではなく、取得した検索条件数が、設定ファイルに定義された設定最大件数に到達している場合、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。削除時にエラーが発生した場合、ステータスコード500(Internal Server Error)でエラー情報を返して、本処理を中止とする。 1. ASWDB(Tx)に対してAMC会員番号、登録日時をキーにお気に入り検索条件を登録する。登録時にエラーが発生した場合、ステータスコード500(Internal Server Error)でエラー情報を返して、本処理を中止とする。 1. ステータスコード201(正常)を返却し処理を終了する。  # 3. データ更新内容 - リクエストパラメータで受け取った検索条件情報をASWDB(Tx)に登録  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public favoritePost(
    generated?: FavoritePostRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<FavoritePostResponse>;
  public favoritePost(
    generated?: FavoritePostRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<FavoritePostResponse>>;
  public favoritePost(
    generated?: FavoritePostRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<FavoritePostResponse>>;
  public favoritePost(
    generated?: FavoritePostRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/favorite`;
    return this.httpClient.request<FavoritePostResponse>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要 1. 複雑空席照会で選択したAir Offer及びバウンドを基にDxAPIのFind more Flights空席照会を行い、検索結果を返却する。  # 2. 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、エラーハンドリング(API)(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返却する。 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。 1. リクエストパラメータについて、以下に合致する場合、エラー項目及びエラー内容と共にステータスコード400(Bad request)でエラー情報を返却し、本処理を中止とする。   1. プロモーションコードの指定がある場合、ASWDB(マスタ)よりオフィスコードに紐づくプロモーション利用可否を取得し、利用不可である。 1. リクエストパラメータにて指定されたバウンドについて、以下に従いDxAPIから空席照会結果を取得する。   1. DxAPIへのリクエストパラメータとしてのプロモーションコードは、指定されたプロモーションコードがASWDB(マスタ)にCAT25として存在している場合には紐づくアカウントコードを指定する。存在しない場合にはAAMによるプロモーションコードとみなし、指定された値をそのまま指定する。   1. 以下に該当する場合、検索結果から除去する。出発時刻はその空港のタイムゾーンの時刻となっているため、比較時は現在時刻に対してASWDB(マスタ)から空港コードをキーに取得した時差を考慮する。     1. 最終発券期限超過として、日本国内単独旅程、かつ出発日がDCS移行開始日付以降の場合、かつ以下のいずれかが合致した場合。         ※以降、DCS移行開始日付は設定ファイルに定義したものを指す。           1. 第1バウンド第1セグメントの出発時刻までの時間が20分未満である。         1. 運航キャリアがPeach(MM)、かつ出発時刻までの時間が3時間未満であるセグメントを含む。     1. 上記以外の場合、かつ第1バウンド第1セグメントの出発時刻まで6時間未満である。     1. 日本国内単独旅程、かつ出発日がDCS移行開始日付以降、かつ現在のairOfferに紐づくFareFamily(FF)が、ASWDB(マスタ)に設定された特定の証憑型運賃のFFである場合、検索結果のairOfferのFFが、該当するFFと異なる。   1. 除外した結果、検索結果が0件の場合は、ステータスコード200(正常)及び検索結果が0件の旨をwarning情報を返却し、本処理を中止とする。   1. リクエストパラメータの検索結果に最新の運航情報を含める処理の実行要否がtrueの場合、TSリスト中に含まれるNHグループ運航国際便、NHグループ便名国内線のうち、出発予定時刻(STD)までの時間が48時間以内であるセグメントについて、発着APIより最新の運航情報を取得する。   1. 往復指定日空席照会(OWD)APIの【Wi-Fi情報取得処理】を実行する。 1. ステータスコード200(正常)を返却し処理を終了する。  # 3. データ更新内容 なし  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public findMoreFlightsPost(
    generated?: FindMoreFlightsRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<FindMoreFlightsResponse>;
  public findMoreFlightsPost(
    generated?: FindMoreFlightsRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<FindMoreFlightsResponse>>;
  public findMoreFlightsPost(
    generated?: FindMoreFlightsRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<FindMoreFlightsResponse>>;
  public findMoreFlightsPost(
    generated?: FindMoreFlightsRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/find-more-flights`;
    return this.httpClient.request<FindMoreFlightsResponse>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要 リクエストパラメータで特定されるフライト検索履歴又はお気に入りを削除する。  # 2. 処理概要 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、エラーハンドリングAPI(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。 1. 認可検証APIより返却されたuuidを基に、ASWDB(Tx)からパーソナライズ情報を取得する。以下の条件のいずれかに合致する場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。     1. パーソナライズ情報のログインステータスが取得できない     1. パーソナライズ情報のログインステータスが未ログインである     1. パーソナライズ情報から会員番号を取得できない 1. 会員情報および呼び出し元より渡された削除対象データの登録日時に紐づくフライト検索履歴、又はお気に入りを削除する。削除時にエラーが発生した場合、ステータスコード500(Internal Server Error)でエラー情報を返して、本処理を中止とする。削除対象データが存在しない場合はステータスコード400(Bad request)を返して、本処理を中止とする。  1. ステータスコード204(正常)を返却し処理を終了する。  # 3. データ更新内容 - 会員情報および呼び出し元より渡された削除対象データの登録日時に紐づくフライト検索履歴、又はお気に入り情報  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public historyFavoriteDeletePost(
    generated?: HistoryFavoriteDeleteRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any>;
  public historyFavoriteDeletePost(
    generated?: HistoryFavoriteDeleteRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<any>>;
  public historyFavoriteDeletePost(
    generated?: HistoryFavoriteDeleteRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<any>>;
  public historyFavoriteDeletePost(
    generated?: HistoryFavoriteDeleteRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/history-favorite/delete`;
    return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要 検索条件の履歴・お気に入り情報をASWDB(Tx)から返却する。  # 2. 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、エラーハンドリング(API)(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。 1. 認可検証APIより返却されたuuidを基に、ASWDB(Tx)からパーソナライズ情報を取得する。以下の条件のいずれかに合致する場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。     1. パーソナライズ情報のログインステータスが取得できない     1. パーソナライズ情報のログインステータスが未ログインである     1. パーソナライズ情報から会員番号を取得できない 1. ASWDB(Tx)から、ログイン中のAMC会員番号に紐づけられた履歴情報、お気に入り情報を全て取得し返却する。 1. ステータスコード200(正常)を返却し処理を終了する。  # 3. データ更新内容 なし  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public historyFavoriteGet(
    generated?: object,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HistoryFavoriteGetResponse>;
  public historyFavoriteGet(
    generated?: object,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<HistoryFavoriteGetResponse>>;
  public historyFavoriteGet(
    generated?: object,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<HistoryFavoriteGetResponse>>;
  public historyFavoriteGet(
    generated?: object,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/history-favorite`;
    return this.httpClient.request<HistoryFavoriteGetResponse>('get', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要 検索条件情報を、検索履歴情報としてASWDB(Tx)に対して登録する。  # 2. 処理内容 1. お気に入り情報登録APIの【フライト検索条件登録共通処理】を実行する。 1. AMC会員番号をキーにASWDB(Tx)から検索履歴情報を取得し、取得した検索条件にリクエストパラメータと同一条件の検索条件が既に登録済みである場合、会員番号と登録日時に紐づく検索履歴情報を削除する。また、取得した検索条件と同一条件ではなく、取得した検索条件数が、設定ファイルに定義された設定最大件数に到達している場合、最も古い検索履歴情報を削除する。削除時にエラーが発生した場合、ステータスコード500(Internal Server Error)でエラー情報を返して、本処理を中止とする。 1. ASWDB(Tx)に対してAMC会員番号、登録日時をキーに検索履歴として検索条件を登録する。登録時にエラーが発生した場合、ステータスコード500(Internal Server Error)でエラー情報を返して、本処理を中止とする。 1. ステータスコード201(正常)を返却し処理を終了する。  # 3. データ更新内容 - クエストパラメータで受け取った検索条件情報をASWDB(Tx)に登録  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public historyPost(
    generated?: HistoryPostRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any>;
  public historyPost(
    generated?: HistoryPostRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<any>>;
  public historyPost(
    generated?: HistoryPostRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<any>>;
  public historyPost(
    generated?: HistoryPostRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/history`;
    return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要 アクセストークンに紐づくkaptcha画像を返却する。  # 2. 処理内容 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。  1. アクセストークンをキーにASWDB(Tx)よりkaptcha画像ファイル保存先のパスを取得し、取得したパスのkaptcha画像をエンコードして呼び出し元に返却する。保存先のパス又は画像ファイルが取得できない場合は、ステータスコード400(Bad Request)を返却し、処理を終了する。  1. ステータスコード200(正常)を返却し、処理を終了する。
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public kaptchaImagePost(
    generated?: object,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'image/jpeg' | 'application/json'; context?: HttpContext }
  ): Observable<object>;
  public kaptchaImagePost(
    generated?: object,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'image/jpeg' | 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<object>>;
  public kaptchaImagePost(
    generated?: object,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'image/jpeg' | 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<object>>;
  public kaptchaImagePost(
    generated?: object,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'image/jpeg' | 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['image/jpeg', 'application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/kaptcha-image`;
    return this.httpClient.request<object>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1 概要   1. 呼び出し元より渡された検索情報を基に、7日間空席照会情報及び、指定日空席照会情報を取得する。   1. バウンドに対するTravel SolutionとFare Familyの掛け合わせを一意に定めた情報をAir Boundとし、この情報に対するIDをAir Bound IDとする。   1. 片道旅程の検索の場合、片道の検索情報を指定することにより、片道の7日間空席照会情報及び、指定日空席照会情報を取得する。   1. 往復旅程の検索の場合、往路のAir Bound ID有無によって、以下のように空席照会情報を取得する。     1. 往復の検索情報を往路のAir Bound IDなしで指定することにより、往復7日間空席照会情報及び、往路の指定日空席照会情報を取得する。     1. 往復の検索情報と、往路のAir Bound IDを指定することにより、往路のAir Boundに応じた、往復7日間空席照会情報及び、復路の指定日空席照会情報を取得する。  # 2 処理内容   1.  Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、共通部品「エラーハンドリング」(G01-010)を利用してMulesoftが生成したエラー情報を解析し、**HTTPステータスコード:400**でエラー情報を返却し、本処理を中止とする。    1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br&gt;有効でない場合、**HTTPステータスコード:401**でエラー情報を返却し、本処理を中止とする。    1. ASWDB(マスタ)より、リクエストヘッダのIPアドレス（以下、当該IPアドレスとする）に紐づく制限レベルを取得し、以下の処理を行う。     1. 当該IPアドレスの制限レベルが「BLOCK」の場合は、ASWDB(Tx)より画像認証情報の画像認証のステータスに「失敗」を登録し、**HTTPステータスコード:403**でエラー情報を返却し、本処理を中止とする。     1. 当該IPアドレスの制限レベルが「CAPTCHA」、かつASWDB(Tx)より画像認証情報の画像認証のステータスが「成功」である場合には、画像認証のステータスを削除して、以降の処理を継続する。&lt;br&gt;画像認証のステータスが「成功」以外である場合には、画像認証のステータスに「失敗」を登録し、**HTTPステータスコード:403**でエラー情報を返却し、本処理を中止とする。      1. リクエストヘッダのCookieにcompanyRealが存在する場合、呼び出し元より渡されたアクセストークンを基に、ASWDB(Tx)よりログイン済み法人企業情報を取得し、以下の処理を行う。&lt;br&gt;ログイン済み法人企業情報を取得できなかった場合、**HTTPステータスコード:401**でエラー情報を返却し、本処理を中止とする。     1. ログイン済み法人企業情報より企業情報(A票)の契約形態がパーチェシングサービス(\&quot;P\&quot;)の場合は企業清算情報(C票)、それ以外の場合は企業情報(A票)をANA Bizログイン情報として、以下のいずれかに該当する場合、ANA Biz利用停止として、**HTTPステータスコード:401**でエラー情報を返却し、本処理を中止とする。       1. 一時停止フラグが「JCB与信停止」または「発券停止」である。       1. 操作日が解約日以降である。    1. 以下のいずれかに該当する場合、検索不可として、**HTTPステータスコード:400**でエラー情報を返却し、本処理を中止とする。     1. 呼び出し元より渡された照会用出発空港コード、照会用到着空港コード、照会用乗継空港コードが、ASWDB(マスタ)の照会用空港コードとして存在しない。     1. 照会用出発空港コード、照会用到着空港コード、照会用乗継空港コードに紐づく、ASWDB(マスタ)の国コード(2レター)に日本以外の国が存在する。     1. 照会用出発空港コードに紐づく、ASWDB(マスタ)の有償表示フラグが「出発地＆目的地」または 「出発地」ではない。     1. 照会用到着空港コード、照会用乗継空港コードに紐づく、ASWDB(マスタ)の有償表示フラグが「出発地＆目的地」または 「目的地」ではない。     1. 照会用出発空港コードと照会用到着空港コードそれぞれに紐づくASWDB(マスタ)の都市コードが同一となる検索情報が存在する。     1. 呼び出し元より渡された出発年月日が、設定ファイルに定義した国内DCS移行開始日よりも前である。     1. 出発年月日が、ASWDB(マスタ)より操作オフィスコードを基に取得した国の時差を考慮して、操作日から数えて設定ファイルで定義した日数の期間外である。     1. 往復旅程検索の場合、復路の出発年月日が往路の出発年月日よりも前である。     1. 操作オフィスに紐づくASWDB(マスタ)のPOSが日本、かつ呼び出し元より渡された運賃オプションがシニアまたはユースの場合、操作日と出発年月日が同日ではない。     1. 操作オフィスがAPF(国際線法人)サイトである。     1. 呼び出し元より渡された出発時間帯の開始時刻と終了時刻において、開始時刻が終了時刻の後である。     1. 出発時間帯の開始時刻と終了時刻の差が2の倍数ではない。&lt;br&gt;※時刻が23:59:00の場合は、差分に1分を加算した値を用いて判定する。     1. 出発時間帯の開始時刻と終了時刻のいずれかのみ設定されている。     1. 呼び出し元より乗り継ぎ時間(分単位)が渡されている場合、乗り継ぎ時間(分単位)が30の倍数ではない、または設定ファイルで定義した乗り継ぎ時間の上限を超えている。     1. 呼び出し元より別予約同行者有無が渡された場合、小児人数が0人である、または大人人数と幼児人数の合計が0人ではない。     1. 呼び出し元より渡された搭乗者数情報の小児人数が1人以上、かつ大人人数と幼児人数の合計が0人である、かつ別予約同行者有無が渡されない。     1. 呼び出し元より渡された搭乗者数情報の組み合わせについて、以下のいずれかに該当する。       1. 大人人数が幼児人数よりも少ない。       1. 大人人数と小児人数の合計が、10人以上である。       1. 大人人数と小児人数の合計が、0人である。     1.Mixed Cabin利用あり、かつ以下のいずれかに該当する。       1. Mixed Cabin情報が渡されていない。       1. ANA Bizログイン情報が存在せず、ASWDB(マスタ)に、CFF区分が「有償日本国内線単独運賃(DCS移行開始後)」、かつMixed Cabin Class検索用の区分が「Mixed Cabin Classのみ検索可能」または「Mixed Cabin ClassとMixed Cabin Classではない検索ともに可能」、かつ呼び出し元より渡された往路復路のキャビンクラスと運賃オプションに紐づくCFFが存在しない。※当該CFFが存在する場合は、当該CFF含むASWDB(マスタ)の情報を対象CFF情報とする。       1. ANA Bizログイン情報が存在し、ASWDB(マスタ)よりCFF区分が「ANA Biz」、かつMixed Cabin Class検索用の区分が「Mixed Cabin Classのみ検索可能」または「Mixed Cabin ClassとMixed Cabin Classではない検索ともに可能」、かつ呼び出し元より渡された往路復路のキャビンクラスと運賃オプションに紐づく、以下すべてを満たすCFFが存在しない。※当該CFFが存在する場合は、当該CFF含むASWDB(マスタ)の情報を対象CFF情報とする。         1. ANA Bizログイン情報のEクラスCFFリストに含まれる。         1. ANA Bizログイン情報のFクラスCFFリストに含まれる。     1. 呼び出し元よりMixed Cabin利用なし、かつ以下のいずれかに該当する。       1. 呼び出し元よりキャビンクラスが渡されていない。       1. ANA Bizログイン情報が存在せず、ASWDB(マスタ)に、CFF区分が有償日本国内線単独運賃(DCS移行開始後)、かつMixed Cabin Class検索用の区分が「Mixed Cabin Classで検索不可」または「Mixed Cabin ClassとMixed Cabin Classではない検索ともに可能」、かつ呼び出し元より渡されたキャビンクラス、運賃オプションに紐づくCFFが存在しない。※当該CFFが存在する場合は、当該CFF含むASWDB(マスタ)の情報を対象CFF情報とする。       1. ANA Bizログイン情報が存在し、ASWDB(マスタ)よりCFF区分が「ANA Biz」、かつMixed Cabin Class検索用の区分が「Mixed Cabin Classのみ検索不可」または「Mixed Cabin ClassとMixed Cabin Classではない検索ともに可能」、かつ呼び出し元より渡されたキャビンクラスと運賃オプションに紐づく、以下いずれかを満たすCFFが存在しない。※当該CFFが存在する場合は、当該CFF含むASWDB(マスタ)の情報を対象CFF情報とする。           1. キャビンクラスがエコノミークラスの場合に、ANA Bizログイン情報のEクラスCFFリストに含まれる。           1. キャビンクラスがファーストクラスの場合に、ANA Bizログイン情報のFクラスCFFリストに含まれる。     1. 呼び出し元よりプロモーションコードが渡されている場合、ASWDB(マスタ)よりオフィスコードに紐づくプロモーション利用可能フラグが「対象外」である。     1. リクエストヘッダのCookieにcompanyRealが存在する、かつANA Bizログイン情報の予約時1PAX限定フラグが「限定する」である場合に、大人人数が2人以上、または小児人数と幼児人数の合計が1人以上である。    1. 空席照会件数に基づくアクセス制限に関して、以下の処理を行う。     1. ASWDB(Tx)に、当該IPアドレスに紐づく空席照会件数が存在し、ASWDB(マスタ)に1バウンド目の出発地・到着地に紐づくキャプチャ表示対象区間が存在する場合は、 現在日時がASWDB(Tx)の空席照会件数の有効期限を超えているかを判定し、その結果に基づき以下の処理を行う。       1. 超えている場合はASWDB(Tx)の空席照会件数、最終検索日時及び有効期限を更新する。&lt;br&gt;※空席照会件数は0件、最終検索日時は現在日時、有効期限は現在日時＋設定ファイルで定義した有効時間で更新する。       1. 超えていない場合は空席照会件数に、1を加算した値に更新する。ただし、加算後の空席照会件数が設定ファイルで定義した空席照会件数の閾値を超える場合は、ASWDB(Tx)の空席照会件数を0件に更新し、画像認証情報の画像認証ステータスに「失敗」を登録して、**HTTPステータスコード:403**でエラー情報を返却し、本処理を中止とする。     1. ASWDB(Tx)に、当該IPアドレスに紐づく空席照会件数が存在せず、ASWDB(マスタ)に1バウンド目の出発地・到着地に紐づくキャプチャ表示対象区間が存在する場合は、ASWDB(Tx)へ、対象IPアドレスは当該IPアドレス、空席照会件数は1件、有効期限は現在日時＋設定ファイルで定義した有効時間、最終検索日時は現在日時を新規登録する。      1. ASWDB(Tx)より、操作オフィスコードの8〜9桁目が「DD」でない場合、操作オフィスコードの8〜9桁目を「DD」に更新する。    1. DxAPIより、7日間空席照会情報、指定日空席照会情報を取得する際は、以下に従ってリクエストパラメータを設定する。     1. 呼び出し元より渡されたプロモーションコードがASWDB(マスタ)においてCAT25プロモーションコードとして存在している場合、それに紐づくアカウントコードを設定する。存在しない場合はAAMプロモーションコードとして、呼び出し元より渡されたプロモーションコードを設定する。     1. 照会用出発空港コード、照会用到着空港コードにおいて、以下に従ってリクエストパラメータを設定する。       1. 照会用出発空港コード、照会用到着空港コードの末尾に、「+」が付与されている場合は、空港コードとする。       1. 照会用出発空港コード、照会用到着空港コードが、ASWDB(マスタ)の都市コードと一致する場合には、都市コードとする。       1. 上記以外の場合には、空港コードとする。     1. 呼び出し元より渡された運賃オプションに紐づくPricing PTCリストをASWDB(マスタ)より取得し、搭乗者毎に設定する。&lt;br&gt;※小児の場合、障がい割引運賃のPricing PTC(DIS)を除いたPricing PTCリストを設定する。     1. 指定日空席照会情報を取得する際、対象CFF情報のCFFを設定する。     1. 7日間空席照会情報を取得する際、対象CFF情報のカレンダー検索用のCFFを設定する。      1. 呼び出し元より、7日間空席照会情報のみ返却すると指定されている場合、以下の処理を行う。     1. DxAPIより7日間空席照会情報を取得する。     1. 7日間空席照会情報より、残席がある検索結果が得られない、かつASWDB(マスタ)に再検索用CFFが存在する場合に再検索用CFFにて自動再検索を行い、7日間空席照会情報を取得する。&lt;br&gt;自動再検索後の7日間空席照会情報において検索結果が取得できない場合は金額情報を含まない7日間空席照会情報を返却する。    1. 呼び出し元より、7日間空席照会情報のみ返却すると指定されていない場合、以下の処理を行う。     1. DxAPIより指定日空席照会情報、7日間空席照会情報を取得する。&lt;br&gt;指定日空席照会情報において検索結果が取得できない場合は**HTTPステータスコード:400**でエラー情報を返却し、本処理を中止とする。     1. 以下のすべてに該当する、かつASWDB(マスタ)に再検索用CFFが存在する場合に再検索用CFFにて自動再検索を行い、指定日空席照会情報、7日間空席照会情報を取得する。&lt;br&gt;自動再検索後の指定日空席照会情報において検索結果が取得できない場合は**HTTPステータスコード:400**でエラー情報を返却し、本処理を中止とする。&lt;br&gt;自動再検索後の7日間空席照会情報において検索結果が取得できない場合は金額情報を含まない7日間空席照会情報を返却する。       1. 指定日空席照会情報より、残席がある検索結果が取得できない。       1. 指定日空席照会情報より、呼び出し元より渡されたキャビンクラスの検索結果が取得できない。       1. 7日間空席照会情報より、残席がある検索結果が取得できない。     1. 指定日空席照会情報より、出発地の現在時刻から出発日時まで48時間未満のセグメントについて、発着APIから最新発着日時を取得する。取得できなかった場合、ワーニングコード\&quot;WBAZ000048\&quot;を返却する。    1. 【Wi-Fi情報取得処理】にてWi-Fi利用区分を取得してWi-Fi利用可否情報とする。取得できなかった場合、ワーニングコード\&quot;WBAZ000558\&quot;を返却し、ASWDB(マスタ)の機材情報より取得したWi-Fi利用区分をWi-Fi利用可否情報とする。&lt;br&gt;※Wi-Fi情報取得処理では以下の通りWi-Fi利用区分を取得する。     1. 操作日、及び出発日がそれぞれ設定された日時以降である場合、便番号と運航日を基にASWDB(Tx)のフライト毎のWi-Fi利用可否情報からWi-Fi利用区分を取得する。取得できない場合はCASよりWi-Fi利用可否を取得してASWDB(Tx)に登録する。&lt;br&gt;     1. 上記以外の場合にACVを基にASWDB(マスタ)の機材情報より取得したWi-Fi利用区分を取得する。    1. **HTTPステータスコード:200**を返却し、処理を終了する。  # 3 データ更新内容   なし  # 4 特記事項   なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public roundtripFppPost(
    generated?: RoundtripFppRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<RoundtripFppResponse>;
  public roundtripFppPost(
    generated?: RoundtripFppRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<RoundtripFppResponse>>;
  public roundtripFppPost(
    generated?: RoundtripFppRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<RoundtripFppResponse>>;
  public roundtripFppPost(
    generated?: RoundtripFppRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/roundtrip-fpp`;
    return this.httpClient.request<RoundtripFppResponse>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要 【往復指定日空席照会(OWD)用API】   指定された検索条件を基に、指定した日付の前後3日間における最安金額及び、指定した日付のフライト・運賃の候補リストを返却する。  # 2. 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、エラーハンドリング(API)(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返却する。 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。   有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。  1. ASWDB(Tx)のカート情報が存在しない場合、ASWDB(マスタ)のIPアドレスの制限レベルに基づき下記処理を実施する。【IPアドレスの制限レベルに基づく認証処理】   1. 当該IPアドレスの制限レベルが”BLOCK”の場合は、ステータスコード403(Forbidden)を返却し処理を終了する。   1. 当該IPアドレスの制限レベルが\&quot;CAPTCHA\&quot;で、ASWDB(Tx)のユーザ共通に画像認証「成功」以外を保持している場合には、ステータスコード403(Forbidden)を返却し処理を終了する。 1. ANABiz会員としてログイン済みではないことを確認する。     1. 呼び出しもとより渡されたCookie「companyReal」が存在する場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。 1. リクエストパラメータについて、以下いずれかに合致する場合、エラー項目及びエラー内容と共にステータスコード400(Bad request)でエラー情報を返却し、本処理を中止とする。【往復空席照会入力チェック処理】   1. 出発空港、到着空港、乗り継ぎ空港が、ASWDB(マスタ)の照会用空港コードとして存在しない。   1. 1バウンド目出発空港の照会用空港コードに紐づく、ASWDB(マスタ)の有償表示フラグが“出発地＆目的地\&quot; または \&quot;出発地\&quot;でない。   1. 操作オフィスがAPF(TYONH08AP)の場合で、1バウンド目出発空港の照会用空港コードに紐づく、ASWDB(マスタ)の国コードが日本でない。   1. 1バウンド目出発空港以外のいずれかの照会用出発空港コードに紐づく、ASWDB(マスタ)の有償表示フラグが\&quot;出発地＆目的地\&quot;または \&quot;目的地\&quot;でない。   1. バウンドの出発空港と到着空港それぞれに紐づくASWDB(マスタ)の都市コードが同一となるバウンドがある。   1. 全空港の照会用空港コードに紐づく国コードが日本(日本国内単独旅程)である場合、以下のいずれかの条件に合致する。       1. 1バウンド目の出発日が、設定ファイルに定義したDCS移行開始日以降である。       1. 操作オフィスに紐づくASWDB(マスタ)のPOSが日本である。   1. 操作オフィスに紐づくASWDB(マスタ)のPOSがアメリカで、照会用空港コードに紐づく国コードがキューバの空港を含んでいる。   1. 出発年月日が、オフィスコードをキーにした該当の国の時差を考慮した上で、ローカル日付から数えて設定ファイルに定義した日数の期間外である。   1. 2バウンドの場合、2バウンド目の出発年月日が1バウンド目の出発年月日よりも前である。   1. 出発開始時刻と出発終了時刻のいずれかのみ設定されている。   1. 出発開始時刻が、出発終了時刻以降の時刻になっている。   1. 出発開始時刻と出発終了時刻の時刻の差が2の倍数となる整数値の時間でない。ただし、出発時刻が\&quot;23:59:00\&quot;の場合は、差分に1分を加算した値を用いて判定する。   1. 搭乗者の組み合わせについて、下記のいずれかに合致する。     1. ADT/B15/CHD/INFの合計人数が0名である。     1. ADTが0名かつ、CHDとINFの合計人数が1名以上である。        1. ADTの人数がINFの人数よりも少ない。     1. ADT/B15/CHDの合計人数が、10名以上である。     1. ADTとB15の合計人数が、0名である。     1. 日本国内単独旅程であった場合に、INFの人数が1名以上である。   1. MixedCabin選択有無がtrueの場合に、下記のいずれかに合致する。     1. Mixed Cabin情報が指定されていない。     1. 日本国内単独旅程の場合、ASWDB(マスタ)のCFF区分が有償日本国内線単独運賃(DCS移行開始前)かつ、Mixed Cabin Class検索用の区分が「Mixed Cabin Classのみ検索可能」もしくは「Mixed Cabin ClassとMixed Cabin Classではない検索ともに可能」、往路復路それぞれのキャビンクラスに合致するCFFが存在しない。       1. 国際旅程の場合、ASWDB(マスタ)のCFF区分が有償国際線運賃かつ、Mixed Cabin Class検索用の区分が「Mixed Cabin Classのみ検索可能」もしくは「Mixed Cabin ClassとMixed Cabin Classではない検索ともに可能」、往路復路それぞれのキャビンクラスに合致するCFFが存在しない。   1. MixedCabin選択有無がfalseの場合に、下記のいずれかに合致する。     1. キャビンクラスが指定されていない。     1. 日本国内単独旅程の場合、ASWDB(マスタ)のCFF区分が有償日本国内線単独運賃(DCS移行開始前)かつ、Mixed Cabin Class検索用の区分が「Mixed Cabin Classで検索不可」もしくは「Mixed Cabin ClassとMixed Cabin Classではない検索ともに可能」かつ、該当するキャビンクラス、運賃オプションタイプに合致するCFFが存在しない。       1. 国際旅程の場合、ASWDB(マスタ)のCFF区分が有償国際線運賃かつ、Mixed Cabin Class検索用の区分が「Mixed Cabin Classで検索不可」もしくは「Mixed Cabin ClassとMixed Cabin Classではない検索ともに可能」かつ、該当するキャビンクラス、運賃オプションタイプに合致するCFFが存在しない。   1. プロモーションコードの指定がある場合、ASWDB(マスタ)よりオフィスコードに紐づくプロモーション利用可否を取得し、利用不可である。 1. アクセスを制限に関して、下記処理を実施する。【空席照会回数に基づくアクセス制御処理】   1. ASWDB(Tx)に当該IPアドレス及び1バウンド目の出発地・到着地に紐づく空席照会回数データが存在する場合は、最終更新日時と現在日時が、設定ファイルに定義したアクセス間隔の閾値を超えているかを確認し、その結果に基づき下記の処理を行う。     1. 超えていた場合はASWDB(Tx)の空席照会回数を0リセットし、最終更新日時及び削除予定日時を更新する。最終更新日時は現在日時を、削除予定日時は、現在日時＋設定ファイルで設定した秒数で更新する。     1. 超えていない場合は空席照会回数を+1カウントアップさせる。カウントアップ後の空席照会回数が、設定ファイルの空席照会回数の閾値を超えた場合は、ASWDB(Tx)の空席照会回数を0リセットし、ASWDB(Tx)のユーザ情報に画像認証「失敗」を登録し、ステータスコード403(Forbidden)を返却し処理を終了する。   1. ASWDB(Tx)に当該IPアドレスかつ、出発地・到着地がASWDB(マスタ)の画像認証表示対象区間に該当する空席照会回数データが存在しない場合は、空席照会回数を1件として新規登録する。新規登録時は、当該IPアドレス、出発地・到着地、最終更新日時、現在日時＋設定ファイルに設定した秒数を削除予定日時として登録する。 1. 下記処理を実行の上で、ステータスコード200(正常)として往復指定日空席照会結果を返却する。   1. DxAPIへのリクエストパラメータとしてのプロモーションコードは、指定されたプロモーションコードがASWDB(マスタ)にCAT25として存在している場合には紐づくアカウントコードを指定する。存在しない場合にはAAMによるプロモーションコードとみなし、指定された値をそのまま指定する。   1. 呼び出し元より渡された出発、到着空港コードそれぞれにおいて、都市コードか空港コードいずれであるかを下記の通り判断の上、DxAPIのリクエストパラメータとしてlocationTypeを指定する。     1. 呼び出し元より渡された各空港コードに、「+」が付与されている場合は、照会用空港コードとして判定。     1. 呼び出し元より渡された各空港コードが、ASWDB(マスタ)の都市コードと一致する場合には、都市コードとして判定。     1. 上記以外の場合には、空港コードとして判定。   1. リクエストパラメータにて、照会結果としてカレンダー情報のみ返却すると指定された場合、下記処理を行う。     1. DxAPIより指定した日付の前後3日間における各日付の最安金額を取得する。     1. 下記の通り、条件に応じて再検索を実行する。          1. DxAPIから取得した、「指定した日付の前後3日間における各日付の最安金額」に対して、下記の条件に合致するかを確認する。【再検索実施要否判定】            1. 有効な検索結果が得られなかった。（※）             ※搭乗者数&gt;残席数のセグメントを含む場合も、残席なしとして扱う。           1. 検索条件のCFFに紐づくキャビンクラスの結果が得られなかった。（※）             ※CFFには、主とするキャビンクラスのFFに加えて、アップセル用の上位キャビンクラスのFFを設定している場合があるが、この上位キャビンクラスの結果しか得られない場合を指す。         1. いずれかの条件に合致した場合、ASWDB(マスタ)に定義する検索条件のCFFに紐づく上位CFFの有無をチェックし、存在する場合は上位CFFにより自動再検索を行う。         1. 初回・再検索時のいずれの場合にも検索結果を得られなかった場合、金額情報を含まないカレンダー日付に関する情報のみを返却する。   1. リクエストパラメータにて、照会結果としてカレンダー情報のみ返却すると指定されていない場合、下記処理を行う。     1. 呼び出し元より渡された検索条件に基づき、並列処理として、指定した1日分のAirOffer一覧、指定した日付の前後3日間における各日付の最安金額を、それぞれDxAPIより取得する。     1. 下記の通り、条件に応じて再検索を実行する。         1. DxAPIから取得した、「指定した1日分のAirOffer一覧」と「指定した日付の前後3日間における各日付の最安金額」の両方の結果に対して、再検索実施可否判定を実施する。         1. DxAPIから取得した結果の両方に対していずれかの条件に合致した場合、ASWDB(マスタ)に定義する検索条件のCFFに紐づく上位CFFの有無をチェックし、存在する場合は上位CFFにより自動再検索を行う。ただし、「指定した1日分のAirOffer一覧」結果に対して、AirOfferがない検索結果となった場合は、CFFを変更しても検索結果は変わらないため再検索は行わない。         1. 再検索時においても、「指定した1日分のAirOffer一覧」に対して、全検索結果が残席なし（※）である結果の場合、初回検索時の検索結果を返却対象とする。ただし、再検索の上、「指定した日付の前後3日間における各日付の最安金額」のみ有効な検索結果を得られている場合には、再検索時の検索結果を返却対象とする。           ※搭乗者数&gt;残席数のセグメントを含む場合も、残席なしとして扱う。         1. DxAPIから取得した結果の両方に対して有効な検索結果を得られなかった場合、warning情報のみ（dataは返却しない）を返却する。     1. リクエストパラメータの検索結果に最新の運航情報を含める処理の実行要否がtrueの場合、TSリスト中に含まれるNHグループ運航国際便、NHグループ便名国内線のうち、出発予定時刻(STD)までの時間が48時間以内であるセグメントについて、発着APIより最新の運航情報を取得する。     1. 以下の通り、TSリスト中に含まれるNHグループ運航の各セグメントにおけるWi-Fi情報を取得する。【Wi-Fi情報取得処理】         1. 現在日時(JST)が設定ファイルに定義したDCS移行開始前日以降、かつ当該セグメントの出発日時がJST換算で出発前日の22:15以降の場合、ASWDB(Tx)より当該セグメントに対する便別Wi-Fi搭載有無情報を取得する。ASWDB(Tx)より、該当の便別Wi-Fi搭載有無情報を取得できなかった場合、当該TSの搭乗日とキャリアコード、便名、出発空港コードをキーに便別Wi-Fi搭載有無情報取得API(CAS接続)より最新の便別Wi-Fi搭載有無情報を取得し、ASWDB(Tx)に対して取得した便別Wi-Fi搭載有無情報を登録する。         1. 上記以外の場合、ASWDB(マスタ)より当該セグメントのACVに該当するWi-Fi有無フラグを取得する。  # 3. データ更新内容 なし  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public roundtripOwdPost(
    generated?: RoundtripOwdRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<RoundtripOwdResponse>;
  public roundtripOwdPost(
    generated?: RoundtripOwdRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<RoundtripOwdResponse>>;
  public roundtripOwdPost(
    generated?: RoundtripOwdRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<RoundtripOwdResponse>>;
  public roundtripOwdPost(
    generated?: RoundtripOwdRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/roundtrip-owd`;
    return this.httpClient.request<RoundtripOwdResponse>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1 概要 指定されたセグメントのキャビンクラスごとのアップグレード空席待ち人数を取得する。  # 2 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、共通部品「エラーハンドリング」(G01-010)を呼び出してMulesoftが生成したエラー情報を解析し、**HTTPステータスコード:400**及びエラー情報を返却して、本処理を中止とする。  1. 呼び出し元より渡されたアクセストークンについて、認可検証APIを呼び出してcookie、アクセストークンの有効性確認及びTTL延長を行う。&lt;br&gt;   有効でない場合、**HTTPステータスコード:401**及びエラー情報を返却して、本処理を中止とする。  1. 呼び出し元より渡されたアクセストークンを復号し、トークン内に含まれるuuidを基に、ASWDB(Tx)からログイン中の会員情報を取得する。&lt;br&gt;   AMC会員番号を取得できなかった場合、**HTTPステータスコード:401**及びエラー情報を返却して、本処理を中止とする。  1. 呼び出し元より渡された出発日付、販売キャリアコード、便番号を基に、DxAPIを呼び出して、対象セグメント情報を取得する。&lt;br&gt;   取得できなかった場合、**HTTPステータスコード:400**及びエラー情報を返却して、本処理を中止とする。  1. 以下のいずれかの条件に合致する場合、指定されたセグメントがNHグループ運航国際線以外であるとし、**HTTPステータスコード:400**及びエラー情報を返却して、本処理を中止とする。   1. 対象セグメント情報の出発空港コードに紐づくASWDB(マスタ)が存在しない   1. 対象セグメント情報の到着空港コードに紐づくASWDB(マスタ)が存在しない   1. 発着それぞれの空港コードを基に、ASWDB(マスタ)から取得した国コード(2レター)が一致している   1. 対象セグメントの運航キャリアコードが\&quot;NH\&quot;(ANA)、\&quot;NQ\&quot;(エアージャパン)ではない 1. 呼び出し元より渡された出発日付、販売キャリアコード、便番号を基に、Altea Web Serviceを呼び出して、アップグレード空席待ち人数を含んだセグメント情報を取得する。&lt;br&gt;   取得できなかった場合、**HTTPステータスコード:400**及びエラー情報を返却して、本処理を中止とする。  1. **HTTPステータスコード:200**を返却して、本処理を終了する。  # 3 データ更新内容   なし。  # 4 特記事項   なし。
   * @param departureDateTime 出発日付(yyyy-MM-dd\&#39;T\&#39;HH:mm:ss形式)
   * @param marketingAirlineCode 販売キャリアコード
   * @param marketingFlightNumber 便番号
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public searchUpgradeWaitlistGet(
    departureDateTime: string,
    marketingAirlineCode: string,
    marketingFlightNumber: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<Type3>;
  public searchUpgradeWaitlistGet(
    departureDateTime: string,
    marketingAirlineCode: string,
    marketingFlightNumber: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<Type3>>;
  public searchUpgradeWaitlistGet(
    departureDateTime: string,
    marketingAirlineCode: string,
    marketingFlightNumber: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<Type3>>;
  public searchUpgradeWaitlistGet(
    departureDateTime: string,
    marketingAirlineCode: string,
    marketingFlightNumber: string,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    if (departureDateTime === null || departureDateTime === undefined) {
      throw new Error(
        'Required parameter departureDateTime was null or undefined when calling searchUpgradeWaitlistGet.'
      );
    }
    if (marketingAirlineCode === null || marketingAirlineCode === undefined) {
      throw new Error(
        'Required parameter marketingAirlineCode was null or undefined when calling searchUpgradeWaitlistGet.'
      );
    }
    if (marketingFlightNumber === null || marketingFlightNumber === undefined) {
      throw new Error(
        'Required parameter marketingFlightNumber was null or undefined when calling searchUpgradeWaitlistGet.'
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (departureDateTime !== undefined && departureDateTime !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>departureDateTime,
        'departureDateTime'
      );
    }
    if (marketingAirlineCode !== undefined && marketingAirlineCode !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>marketingAirlineCode,
        'marketingAirlineCode'
      );
    }
    if (marketingFlightNumber !== undefined && marketingFlightNumber !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>marketingFlightNumber,
        'marketingFlightNumber'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/search/upgrade-waitlist`;
    return this.httpClient.request<Type3>('get', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1 概要 指定されたセグメントのキャビンクラスごとの空席待ち人数を取得する。  # 2 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、共通部品「エラーハンドリング」(G01-010)を呼び出してMulesoftが生成したエラー情報を解析し、**HTTPステータスコード:400**及びエラー情報を返却して、本処理を中止とする。  1. 呼び出し元より渡されたアクセストークンについて、認可検証APIを呼び出してcookie、アクセストークンの有効性確認及びTTL延長を行う。&lt;br&gt;   有効でない場合、**HTTPステータスコード:401**及びエラー情報を返却して、本処理を中止とする。  1. 呼び出し元より渡された出発日付、販売キャリアコード、便番号を基に、Altea Web Serviceを呼び出して、空席待ち人数を含んだセグメント情報を取得する。&lt;br&gt;   取得できなかった場合、**HTTPステータスコード:400**及びエラー情報を返却して、本処理を中止とする。  1. **HTTPステータスコード:200**を返却して、本処理を終了する。  # 3 データ更新内容   なし。  # 4 特記事項   なし。
   * @param departureDateTime 出発日付(yyyy-MM-dd\&#39;T\&#39;HH:mm:ss形式)
   * @param marketingAirlineCode 販売キャリアコード
   * @param marketingFlightNumber 便番号
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public searchWaitlistGet(
    departureDateTime: string,
    marketingAirlineCode: string,
    marketingFlightNumber: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<WaitlistGetSearchWaitlistResponse>;
  public searchWaitlistGet(
    departureDateTime: string,
    marketingAirlineCode: string,
    marketingFlightNumber: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<WaitlistGetSearchWaitlistResponse>>;
  public searchWaitlistGet(
    departureDateTime: string,
    marketingAirlineCode: string,
    marketingFlightNumber: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<WaitlistGetSearchWaitlistResponse>>;
  public searchWaitlistGet(
    departureDateTime: string,
    marketingAirlineCode: string,
    marketingFlightNumber: string,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    if (departureDateTime === null || departureDateTime === undefined) {
      throw new Error('Required parameter departureDateTime was null or undefined when calling searchWaitlistGet.');
    }
    if (marketingAirlineCode === null || marketingAirlineCode === undefined) {
      throw new Error('Required parameter marketingAirlineCode was null or undefined when calling searchWaitlistGet.');
    }
    if (marketingFlightNumber === null || marketingFlightNumber === undefined) {
      throw new Error('Required parameter marketingFlightNumber was null or undefined when calling searchWaitlistGet.');
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (departureDateTime !== undefined && departureDateTime !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>departureDateTime,
        'departureDateTime'
      );
    }
    if (marketingAirlineCode !== undefined && marketingAirlineCode !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>marketingAirlineCode,
        'marketingAirlineCode'
      );
    }
    if (marketingFlightNumber !== undefined && marketingFlightNumber !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>marketingFlightNumber,
        'marketingFlightNumber'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/search/waitlist`;
    return this.httpClient.request<WaitlistGetSearchWaitlistResponse>(
      'get',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * # 1 概要 指定された出発日付と区間ごとに、アップグレード可能な空席状況をキャビンクラス別に取得する。  # 2 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、共通部品「エラーハンドリング」(G01-010)を利用してMulesoftが生成したエラー情報を解析し、**HTTPステータスコード:400** でエラー情報を返却し、本処理を中止とする。 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br&gt; 有効でない場合、**HTTPステータスコード:401** でエラー情報を返却し、本処理を中止とする。 1. 呼び出し元より渡されたアクセストークンを復号し、トークン内に含まれるuuidを基に、ASWDB(Tx)からログイン中の会員情報を取得する。&lt;br&gt; AMC会員番号を取得できなかった場合、**HTTPステータスコード:401** でエラー情報を返却し、本処理を中止とする。 1. 呼び出し元より渡された出発日付と区間ごとに以下の処理を実行する。   1. 対象の出発日付と、出発地の空港情報の空港コード、到着地の空港情報の空港コードに基づき、Altea Web Service経由で空席情報を取得する。&lt;br&gt;   取得できなかった場合、**HTTPステータスコード400**でエラー情報を返却し、本処理を中止とする。   1. 空席情報のセグメントから、NHグループ運航国際線のリストとして、以下全てを満たすセグメントのリストを作成する。&lt;br&gt;   同じ便名の情報が複数存在する場合、「直行便」、「他のNH販売便が含まれるTS」、「他社販売便が含まれるTS」の順で最初に存在するものを対象としてリストを作成する。     1. 対象セグメントの出発地の空港コードに基づき、ASWDB(マスタ)から出発地の空港情報を取得できる。     1. 対象セグメントの到着地の空港コードに基づき、ASWDB(マスタ)から到着地の空港情報を取得できる。     1. 発着それぞれの空港情報より、国コード(2レター)が一致しない。     1. 対象セグメントの運航キャリアコードが\&quot;NH\&quot;(ANA)、\&quot;NQ\&quot;(エアージャパン)のいずれかである。 1. **HTTPステータスコード:200** を返却し、本処理を終了する。  # 3 データ更新内容 なし  # 4 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public upgradeAvailabilityPost(
    generated?: Type6,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<Type7>;
  public upgradeAvailabilityPost(
    generated?: Type6,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<Type7>>;
  public upgradeAvailabilityPost(
    generated?: Type6,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<Type7>>;
  public upgradeAvailabilityPost(
    generated?: Type6,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/upgrade-availability`;
    return this.httpClient.request<Type7>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要 便番号と運航日をキーにWi-Fi使用可否を、ASWDB(マスタ)に対して登録・更新する。  # 2. 処理内容 1. リクエストパラメータの便番号と運航日をキーにWi-Fi使用可否を更新する。   1. ASWDB(マスタ)に便番号と運航日が未登録の場合、便番号と運航日をキーにWi-Fi使用可否を新規登録する。 1. ステータスコード200(正常)を返却し処理を終了する。  # 3. データ更新内容 - 呼び出し元より渡された便番号と運航日に紐づくWi-Fi使用可否情報  # 4. 特記事項 - なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public wifiAvailabilityPost(
    generated?: Type2,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<string>;
  public wifiAvailabilityPost(
    generated?: Type2,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<string>>;
  public wifiAvailabilityPost(
    generated?: Type2,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<string>>;
  public wifiAvailabilityPost(
    generated?: Type2,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/wifi-availability`;
    return this.httpClient.request<string>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }
}
