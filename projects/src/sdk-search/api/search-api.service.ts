/**
 * aswbe search eapi（ShoppingShopping）
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import { Inject, Injectable, Optional } from '@angular/core';
import {
  HttpClient,
  HttpHeaders,
  HttpParams,
  HttpResponse,
  HttpEvent,
  HttpParameterCodec,
  HttpContext,
} from '@angular/common/http';
import { CustomHttpParameterCodec } from '../encoder';
import { Observable } from 'rxjs';
import { CaptchaAuthenticationRequest } from '../model/captchaAuthenticationRequest';
import { CaptchaAuthenticationResponse } from '../model/captchaAuthenticationResponse';
import { CaptchaAuthenticationStatusResponse } from '../model/captchaAuthenticationStatusResponse';
import { ComplexCalendarRequest } from '../model/complexCalendarRequest';
import { ComplexCalendarResponse } from '../model/complexCalendarResponse';
import { ComplexRequest } from '../model/complexRequest';
import { ComplexResponse } from '../model/complexResponse';
import { FavoritePostRequest } from '../model/favoritePostRequest';
import { FavoritePostResponse } from '../model/favoritePostResponse';
import { FindMoreFlightsRequest } from '../model/findMoreFlightsRequest';
import { FindMoreFlightsResponse } from '../model/findMoreFlightsResponse';
import { HistoryFavoriteDeleteRequest } from '../model/historyFavoriteDeleteRequest';
import { HistoryFavoriteGetResponse } from '../model/historyFavoriteGetResponse';
import { HistoryPostRequest } from '../model/historyPostRequest';
import { RoundtripOwdRequest } from '../model/roundtripOwdRequest';
import { RoundtripOwdResponse } from '../model/roundtripOwdResponse';
import { Type } from '../model/type';
import { Type1 } from '../model/type1';
import { Type2 } from '../model/type2';
import { Type3 } from '../model/type3';
import { Type4 } from '../model/type4';
import { Type5 } from '../model/type5';
import { Type6 } from '../model/type6';
import { Type7 } from '../model/type7';
import { BASE_PATH, COLLECTION_FORMATS } from '../variables';
import { Configuration } from '../configuration';
import { UpgradeavailabilityResponse } from '@common/interfaces/shopping/upgrade-availability/upgradeavailabilityResponses';
import { UpgradeAvailabilityRequest } from '@common/interfaces/shopping/upgrade-availability/upgradeavailabilityRequest';

@Injectable({
  providedIn: 'root',
})
export class SearchApiService {
  protected basePath = 'http://localhost';
  public defaultHeaders = new HttpHeaders();
  public configuration = new Configuration();
  public encoder: HttpParameterCodec;

  constructor(
    protected httpClient: HttpClient,
    @Optional() @Inject(BASE_PATH) basePath: string | string[],
    @Optional() configuration: Configuration
  ) {
    if (configuration) {
      this.configuration = configuration;
    }
    if (typeof this.configuration.basePath !== 'string') {
      if (Array.isArray(basePath) && basePath.length > 0) {
        basePath = basePath[0];
      }

      if (typeof basePath !== 'string') {
        basePath = this.basePath;
      }
      this.configuration.basePath = basePath;
    }
    this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
  }

  private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
    if (typeof value === 'object' && value instanceof Date === false) {
      httpParams = this.addToHttpParamsRecursive(httpParams, value);
    } else {
      httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
    }
    return httpParams;
  }

  private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
    if (value == null) {
      return httpParams;
    }

    if (typeof value === 'object') {
      if (Array.isArray(value)) {
        (value as any[]).forEach((elem) => (httpParams = this.addToHttpParamsRecursive(httpParams, elem, key)));
      } else if (value instanceof Date) {
        if (key != null) {
          httpParams = httpParams.append(key, (value as Date).toISOString().substr(0, 10));
        } else {
          throw Error('key may not be null if value is Date');
        }
      } else {
        Object.keys(value).forEach(
          (k) => (httpParams = this.addToHttpParamsRecursive(httpParams, value[k], key != null ? `${key}.${k}` : k))
        );
      }
    } else if (key != null) {
      httpParams = httpParams.append(key, value);
    } else {
      throw Error('key may not be null if value is not object or array');
    }
    return httpParams;
  }

  /**
   * # 1. 概要 リクエストパラメータを元に、reCAPTCHA又はkaptcha認証を実施し、認証結果を返却する。  # 2. 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、エラーハンドリング(API)(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。  1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。  1. リクエストパラメータの各項目を基に以下の通り画像認証を実施し、認証結果を求める。   1. 認証タイプが\&quot;reCAPTCHA\&quot;の場合、認証確認用アドレスに対して認証情報を送信する。   1. 認証タイプが\&quot;kaptcha\&quot;の場合、以下の処理を行う。     1. ASWDB(Tx)ユーザ共通の認証要否判定日時と現在日時の差が、設定ファイルの閾値を超えている場合は、タイムアウトエラーとし、ステータスコード403(Forbidden)を返却する。     1. ASWDB(Tx)ユーザ共通のkaptcha文字列を取得し、パラメータの入力文字と比較する。       一致する場合は画像認証成功、不一致の場合は画像認証失敗と判定する。  1. 認証結果をASWDB(Tx)のユーザ共通に登録する。 1. 画像認証成功の場合は、Cookie(Cookie名\&quot;srchclntkey\&quot;)に、画像認証「成功」を表す旨として、クライアントのIPアドレス、検索条件の第一出発空港に紐づく都市、画像認証用固定文字列(設定ファイルにて管理)を\&quot;_\&quot;(アンダーバー)で連結し、AESで暗号化した文字列を登録する。また、有効期限1年を付与する。 1. ステータスコード200(正常)を返却し、処理を終了する。
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public captchaAuthenticationPost(
    generated?: CaptchaAuthenticationRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<CaptchaAuthenticationResponse>;
  public captchaAuthenticationPost(
    generated?: CaptchaAuthenticationRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<CaptchaAuthenticationResponse>>;
  public captchaAuthenticationPost(
    generated?: CaptchaAuthenticationRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<CaptchaAuthenticationResponse>>;
  public captchaAuthenticationPost(
    generated?: CaptchaAuthenticationRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/captcha-authentication`;
    return this.httpClient.request<CaptchaAuthenticationResponse>(
      'post',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: generated,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * # 1. 概要 ロボットのクローラによる有害な空席照会アクセス等をブロックするため、reCAPTCHAまたはkaptchaによる画像認証要否判定を行う。 1. リクエストパラメータを元に、画像認証表示要否の判定を行い、判定結果を返却する。&lt;br&gt;一般ユーザに対して認証が表示されすぎることを避けるため、認証に成功した場合ASWDB(Tx)のユーザ共通に画像認証成功の旨を保持し、成功の旨の有無に応じて再認証要否を決定する。認証成功の旨の有無に応じた各判定は、以下の3段階で実施する。   1. 常に行うチェック&lt;br&gt;認証に成功しているかどうかに問わず必ず行う判定。同一セッション内で一度認証に成功した場合でも、条件に合致した場合はCAPTCHA表示（またはアクセス拒否/スキップ）とする。&lt;br&gt;クローラが画像認証を経ず、直接空席照会にアクセスした場合に備え、空席照会APIでも以下の対策を講ずる。     1. 当APIの常に行うチェックと同等のチェックを実施する。     1. ASWDB(マスタ)の制限レベルが\&quot;CAPTCHA\&quot;のクライアントの場合、アクセスの都度画像認証を必須とし、ASWDB(Tx)の画像認証成功の旨の有無で判定する。&lt;br&gt;判定後、空席照会APIは認証成功の旨を削除し、万が一次回画像認証を経ず直接空席照会にアクセスされた場合でも、処理をブロックできるようにする。     1. 特定区間に対する空席照会件数をカウントし、閾値を超えた場合アクセスをブロックする。      1. Cookieより強いチェック&lt;br&gt;ASWDB(Tx)のユーザ共通が画像認証成功の場合は行わないが、Cookieのみ認証成功の旨を保持をしている場合でも行う判定。同一セッション内で一度認証に成功した場合は実施されないが、ASW TOP等から再流入した場合は再判定を行う。    1. Cookieより弱いチェック&lt;br&gt;ASWDB(Tx)のユーザ共通にもCookieにも画像認証成功を保持していない場合に行う判定。一度認証に成功した後は、Cookieの削除または有効期限切れとなるまで再判定しない。  1. 画像認証は原則reCAPTCHAを使用するが、reCAPTCHA使用不可となる場合にはkaptchaを使用する。&lt;br&gt;画像認証要否判定が「要」の場合は、reCAPTCHA利用可否判定を行い、判定結果及び認証に必要な情報も併せて返却する。&lt;br&gt;以下のいずれか場合はreCAPTCHA使用不可と判定する。   1. 中国ではGoogleへの通信が遮断されるため、操作オフィスのPOSが中国の場合   1. ANAアプリのブラウザではreCAPTCHAが動作しないため、ANAアプリの場合   1. reCAPTCHA利用設定をオフにしている場合   1. ASWDB(マスタ)から取得したreCAPTCHAの動作状況が正常動作でない場合  # 2. 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、エラーハンドリング(API)(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。  1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてCookie、アクセストークンの有効性確認およびTTL(有効期限)延長を行う。有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。  1. 認可検証APIより返却されたuuidを基に、ASWDB(Tx)からパーソナライズ情報を取得する。以下の条件に合致する場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。     1. パーソナライズ情報のログインステータスが取得できない    1. 常に行うチェックとして、クライアントのIPアドレスがASWDB(マスタ)のロボットIPアドレスに該当する場合、制限レベルに応じて以下の処理を実施する。   1. \&quot;BLOCK\&quot;の場合、ASWDB(Tx)のユーザ共通に画像認証「失敗」を登録し、ステータスコード200(正常)を返却し処理を終了する。   1. \&quot;WHITELIST\&quot;の場合、ASWDB(Tx)のユーザ共通に画像認証「成功」を登録し、ステータスコード200(正常)を返却し処理を終了する。   1. \&quot;CAPTCHA\&quot;の場合、認証の種類を決定する処理を行う。  1. ASWDB(Tx)のユーザ共通が画像認証「成功」を保持している場合、ステータスコード200(正常)を返却し処理を終了する。  1. Cookieより強いチェックとして、出発地・到着地都市コードがASWDB(マスタ)の画像認証表示対象区間に該当するかを確認する。&lt;br&gt;該当する場合は、認証の種類を決定する処理を行う。該当しない、かつ、Cookieを復号しCookieが保持する内容が、今回検索時のIPアドレス、検索条件の第一出発都市と一致する場合は、Cookieが画像認証「成功」を保持していると判定し、ステータスコード200(正常)を返却し処理を終了する。&lt;br&gt;※Cookieの復号に失敗、または復号したCookieが登録時に登録した形式(詳細は画像認証API参照)でない場合は、「成功」を保持していない扱いとする。  1. Cookieより弱いチェックとして、以下の処理を行う。&lt;br&gt;以下のいずれかに該当する場合は、認証の種類を決定する処理を行う。&lt;br&gt;該当しない場合はASWDB(Tx)のユーザ共通に画像認証「成功」を登録し、ステータスコード200(正常)を返却し処理を終了する。   1. ASWDB(Tx)のユーザ共通に保持するAkamai Bot Managerによる判定結果がBotの疑いがあると判断された     1. 以下の順で求めた値(画像認証表示率)と、0から100未満の間で求めた乱数を比較し、乱数が画像認証表示率未満である     1. 操作オフィス・デバイス・言語・検索条件の出発国・ログインステータスの組み合わせに紐づく、設定ファイルの画像認証表示比率     1. 上記が存在しない場合、操作オフィス・デバイス・言語・ログインステータスの組み合わせに紐づく、設定ファイルの画像認証表示比率  1. 認証の種類を決定する。以下のいずれかに該当する場合はkaptchaとし、それ以外はreCAPTCHAとする。   1. 操作オフィスに紐づくASWDB(マスタ)のPOSが中国   1. ブラウザ種別がANAアプリ   1. 設定ファイルのreCAPTCHAの使用設定がOFF   1. ASWDB(マスタ)のreCAPTCHA動作状況が正常動作でない  1. 認証の種類がkaptchaの場合、kaptcha認証のための文字列並びに画像を生成し、文字列はASWDB(Tx)にアクセストークンに紐づく情報として登録、画像は画像ファイルとしてS3ストレージに保存する。   また、ASWDB(Tx)登録時は、TTLとして現在時刻＋設定ファイルのkaptcha認証画像有効時間を設定する。  1. ASWDB(Tx)のユーザ共通に画像認証「要」を登録し、ステータスコード200(正常)を返却し処理を終了する。  # 3. データ更新内容 1. ASWDB(Tx) |更新テーブル|更新内容|データ取得元|条件等| |:---|:---|:---|:---| |S2パーソナライズ情報|kaptcha認証文字列、kaptcha画像ファイル保存先のパス、kaptcha有効時間を登録|kaptcha関連情報は、当APIにて生成|認証要否判定結果が要、かつ認証の種類がkaptchaの場合|  # 4. 特記事項 1. kaptcha認証のための画像・認証キーの生成は、Google社提供のjarを利用する必要があるため、当該機能はJavaで開発しMuleSoftから呼び出す形をとる。
   * @param originLocationCode 出発地   照会用空港コード、都市コードの3レター   但し、空港コードの場合には、後ろに「+」を付けること   (例)   上海（空港コード）：SHA+   上海（都市コード）：SHA
   * @param destinationLocationCode 到着地   照会用空港コード、都市コードの3レター   但し、空港コードの場合には、後ろに「+」を付けること   (例)   上海（空港コード）：SHA+   上海（都市コード）：SHA
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public captchaAuthenticationStatusGet(
    originLocationCode: string,
    destinationLocationCode: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<CaptchaAuthenticationStatusResponse>;
  public captchaAuthenticationStatusGet(
    originLocationCode: string,
    destinationLocationCode: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<CaptchaAuthenticationStatusResponse>>;
  public captchaAuthenticationStatusGet(
    originLocationCode: string,
    destinationLocationCode: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<CaptchaAuthenticationStatusResponse>>;
  public captchaAuthenticationStatusGet(
    originLocationCode: string,
    destinationLocationCode: string,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    if (originLocationCode === null || originLocationCode === undefined) {
      throw new Error(
        'Required parameter originLocationCode was null or undefined when calling captchaAuthenticationStatusGet.'
      );
    }
    if (destinationLocationCode === null || destinationLocationCode === undefined) {
      throw new Error(
        'Required parameter destinationLocationCode was null or undefined when calling captchaAuthenticationStatusGet.'
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (originLocationCode !== undefined && originLocationCode !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>originLocationCode,
        'originLocationCode'
      );
    }
    if (destinationLocationCode !== undefined && destinationLocationCode !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>destinationLocationCode,
        'destinationLocationCode'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/captcha-authentication-status`;
    return this.httpClient.request<CaptchaAuthenticationStatusResponse>(
      'get',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * # 1. 概要 1. 呼び出し元より渡された検索条件を基にDxAPIにて複雑カレンダー空席照会結果を行い、バウンド数に応じてDxAPIが返却可能な日付範囲の検索結果を返却する。 |検索バウンド数|回答日付範囲| |---:|:---| |3|5日間（検索日付を軸に±2日）| |4|3日間（検索日付を軸に±1日）| |5|3日間（検索日付を軸に±1日）|    バウンド数が6の場合、回答日付範囲1日間となり、カレンダー表示としての意味をなさないため、その場合にはエラーを返却する。&lt;br&gt;   なお返却される各バウンドの日付の組み合わせについては、検索条件に指定した日付を軸に、全バウンドの日付を同じ数だけずらした結果（滞在日数を固定して、出発日付をずらした結果）のみを返却する。例えば「4/10、4/14、4/17、4/20」の4バウンドを検索した場合、「4/10、4/14、4/17、4/20」を軸に、全バウンドの日付を同じ数ずらした「4/9、4/13、4/16、4/19」「4/11、4/15、4/18、4/21」の3つの組合せのみとなる。  # 2. 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、エラーハンドリング(API)(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返却する。 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。   有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。   1. 往復指定日空席照会(OWD)用APIの【IPアドレスの制限レベルに基づく認証処理】を実行する。 1. リクエストパラメータについて、以下いずれかに合致する場合、エラー項目及びエラー内容と共にステータスコード400(Bad request)でエラー情報を返却し、本処理を中止とする。   1. 出発空港、到着空港、乗り継ぎ空港が、ASWDB(マスタ)の照会用空港コードとして存在しない。   1. ARNK区間（接続するバウンドの到着空港コードと出発空港コードに紐づく都市コードが異なる区間）を1区間として換算し、ARNK区間を含むバウンドの合計数が6バウンド以上である。       例：ITM-HND、NRT-LAX、SFO-ITMで検索の場合、LAXとSFO間がARNK区間となるため、都合4バウンドとして扱う。   1. 1バウンド目出発空港の照会用空港コードに紐づく、ASWDB(マスタ)の有償表示フラグが“出発地＆目的地\&quot; または \&quot;出発地\&quot;でない。   1. 操作オフィスがAPF(TYONH08AP)の場合で、1バウンド目出発空港の照会用空港コードに紐づく、ASWDB(マスタ)の国コードが日本でない。   1. 1バウンド目出発空港以外のいずれかの照会用出発空港コードに紐づく、ASWDB(マスタ)の有償表示フラグが\&quot;出発地＆目的地\&quot;または \&quot;目的地\&quot;でない。   1. バウンドの出発空港と到着空港それぞれに紐づくASWDB(マスタ)の都市コードが同一となるバウンドがある。   1. 1バウンド目出発空港の国コードと、各バウンドの出発空港の国コードが同一かつ、そのバウンドの発着空港の国コードが同一ではない場合をカウントし、2件以上カウントされた。   1. 1バウンド目出発空港の国コードと、各バウンドの到着空港の国コードが同一かつ、そのバウンドの発着空港の国コードが同一ではない場合カウントし、2件以上カウントされた。   1. 操作オフィスに紐づくASWDB(マスタ)のPOSが日本で、全空港の照会用空港コードに紐づく国コードが日本（日本国内単独旅程）である。   1. 操作オフィスに紐づくASWDB(マスタ)のPOSがアメリカで、照会用空港コードに紐づく国コードがキューバの空港を含んでいる。   1. 出発年月日が、オフィスコードをキーにした該当の国の時差を考慮した上で、ローカル日付から数えて設定ファイルに定義した日数の期間外である。   1. バウンドの要素順に、各バウンドの出発年月日が直前のバウンドの出発年月日よりも前である。   1. 出発開始時刻と出発終了時刻のいずれかのみ設定されている。   1. 出発開始時刻が、出発終了時刻以降の時刻になっている。   1. 出発開始時刻と出発終了時刻の時刻の差が2の倍数となる整数値の時間でない。ただし、出発時刻が\&quot;23:59:00\&quot;の場合は、差分に1分を加算した値を用いて判定する。   1. 搭乗者の組み合わせついて、下記のいずれかに合致する。     1. ADTが0名かつ、CHDとINFの合計人数が1名以上である。     1. ADTの人数がINFの人数よりも少ない。     1. ADT/B15/CHDの合計人数が、10名以上である。     1. ADTとB15の合計人数が、0名である。     1. 日本国内単独旅程であった場合に、INFの人数が1名以上である。   1. 日本国内単独旅程の場合、ASWDB(マスタ)のCFF区分が有償日本国内単独運賃かつ、Mixed Cabin Class検索用の区分が「Mixed Cabin Classで検索不可」もしくは「Mixed Cabin ClassとMixed Cabin Classではない検索ともに可能」かつ、該当するキャビンクラス、運賃オプションタイプに合致するCFFが存在しない。   1. 国際旅程の場合、ASWDB(マスタ)のCFF区分が有償国際線運賃かつ、Mixed Cabin Class検索用の区分が「Mixed Cabin Classで検索不可」もしくは「Mixed Cabin ClassとMixed Cabin Classではない検索ともに可能」かつ、該当するキャビンクラス、運賃オプションタイプに合致するCFFが存在しない。   1. プロモーションコードの指定がある場合、ASWDB(マスタ)よりオフィスコードに紐づくプロモーション利用可否を取得し、利用不可である。 1. 往復指定日空席照会(OWD)用APIの【空席照会回数に基づくアクセス制限処理】を実行する。 1. 下記処理を実行の上で、ステータスコード200(正常)として複雑カレンダー空席照会結果を返却する。   1. DxAPIへのリクエストパラメータとしてのプロモーションコードは、指定されたプロモーションコードがASWDB(マスタ)にCAT25として存在している場合には紐づくアカウントコードを指定する。存在しない場合にはAAMによるプロモーションコードとみなし、指定された値をそのまま指定する。   1. 呼び出し元より渡された出発、到着空港コードそれぞれにおいて、都市コードか空港コードいずれであるかを下記の通り判断の上、DxAPIのリクエストパラメータとしてlocationTypeを指定する。     1. 呼び出し元より渡された各空港コードに、「+」が付与されている場合は、照会用空港コードとして判定。     1. 呼び出し元より渡された各空港コードが、ASWDB(マスタ)の都市コードと一致する場合には、都市コードとして判定。     1. 上記以外の場合には、空港コードとして判定。   1. 呼び出し元より渡された検索条件に基づきDxAPIにリクエストを行い、複雑カレンダー空席照会結果を取得する。なお、日付範囲については、設定ファイルよりバウンド数に応じた日数を取得し、条件として指定する。   1. DxAPIの検索結果に対して、検索条件に指定した日付を軸に、全バウンドの日付を同じ数だけずらした結果（滞在日数を固定して、出発日付をずらした結果）以外を除外する。   1. 除外した結果、検索結果を得られなかった場合には、ASWDB(マスタ)に定義する検索条件のCFFに紐づく上位CFFの有無をチェックし、存在する場合は上位CFFにより自動再検索を行う。それでも検索結果を得られなかった場合、ステータスコード200(正常)及びwarning情報を返却する。  # 3. データ更新内容 なし  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public complexCalendarPost(
    generated?: ComplexCalendarRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<ComplexCalendarResponse>;
  public complexCalendarPost(
    generated?: ComplexCalendarRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<ComplexCalendarResponse>>;
  public complexCalendarPost(
    generated?: ComplexCalendarRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<ComplexCalendarResponse>>;
  public complexCalendarPost(
    generated?: ComplexCalendarRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/complex-calendar`;
    return this.httpClient.request<ComplexCalendarResponse>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要 呼び出し元より渡された検索条件を基にDxAPIにて複雑空席照会を行い、検索結果からおすすめ旅程として適した旅程を返却する。  # 2. 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、エラーハンドリング(API)(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返却する。 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。   有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。  1. 往復指定日空席照会(OWD)用APIの【IPアドレスの制限レベルに基づく認証処理】を実行する。 1. リクエストパラメータについて、以下いずれかに合致する場合、エラー項目及びエラー内容と共にステータスコード400(Bad request)でエラー情報を返却し、本処理を中止とする。【複雑空席照会入力チェック処理】   1. 出発空港、到着空港、乗り継ぎ空港が、ASWDB(マスタ)の照会用空港コードとして存在しない。   1. 1バウンド目出発空港の照会用空港コードに紐づく、ASWDB(マスタ)の有償表示フラグが“出発地＆目的地\&quot; または \&quot;出発地\&quot;でない。   1. 操作オフィスがAPF(TYONH08AP)の場合で、1バウンド目出発空港の照会用空港コードに紐づく、ASWDB(マスタ)の国コードが日本でない。   1. 1バウンド目出発空港以外のいずれかの照会用出発空港コードに紐づく、ASWDB(マスタ)の有償表示フラグが\&quot;出発地＆目的地\&quot;または \&quot;目的地\&quot;でない。   1. バウンドの出発空港と到着空港それぞれに紐づくASWDB(マスタ)の都市コードが同一となるバウンドがある。   1. 1バウンド目出発空港の国コードと、各バウンドの出発空港の国コードが同一かつ、そのバウンドの発着空港の国コードが同一ではない場合をカウントし、2件以上カウントされた。   1. 1バウンド目出発空港の国コードと、各バウンドの到着空港の国コードが同一かつ、そのバウンドの発着空港の国コードが同一ではない場合カウントし、2件以上カウントされた。   1. 操作オフィスに紐づくASWDB(マスタ)のPOSが日本で、全空港の照会用空港コードに紐づく国コードが日本（日本国内単独旅程）である。   1. 操作オフィスに紐づくASWDB(マスタ)のPOSがアメリカで、照会用空港コードに紐づく国コードがキューバの空港を含んでいる。   1. 出発年月日が、オフィスコードをキーにした該当の国の時差を考慮した上で、ローカル日付から数えて設定ファイルに定義した日数の期間外である。   1. バウンドの要素順に、各バウンドの出発年月日が直前のバウンドの出発年月日よりも前である。   1. 出発開始時刻と出発終了時刻のいずれかのみ設定されている。   1. 出発開始時刻が、出発終了時刻以降の時刻になっている。   1. 出発開始時刻と出発終了時刻の時刻の差が2の倍数となる整数値の時間でない。ただし、出発時刻が\&quot;23:59:00\&quot;の場合は、差分に1分を加算した値を用いて判定する。   1. 搭乗者の組み合わせついて、下記のいずれかに合致する。     1. ADTが0名かつ、CHDとINFの合計人数が1名以上である。     1. ADTの人数がINFの人数よりも少ない。     1. ADT/B15/CHDの合計人数が、10名以上である。     1. ADTとB15の合計人数が、0名である。     1. 日本国内単独旅程であった場合に、INFの人数が1名以上である。   1. 日本国内単独旅程の場合、ASWDB(マスタ)のCFF区分が有償日本国内単独運賃かつ、Mixed Cabin Class検索用の区分が「Mixed Cabin Classで検索不可」もしくは「Mixed Cabin ClassとMixed Cabin Classではない検索ともに可能」かつ、該当するキャビンクラス、運賃オプションタイプに合致するCFFが存在しない。   1. 国際旅程の場合、ASWDB(マスタ)のCFF区分が有償国際線運賃かつ、Mixed Cabin Class検索用の区分が「Mixed Cabin Classで検索不可」もしくは「Mixed Cabin ClassとMixed Cabin Classではない検索ともに可能」かつ、該当するキャビンクラス、運賃オプションタイプに合致するCFFが存在しない。   1. プロモーションコードの指定がある場合、ASWDB(マスタ)よりオフィスコードに紐づくプロモーション利用可否を取得し、利用不可である。 1. 往復指定日空席照会(OWD)用APIの【空席照会回数に基づくアクセス制限処理】を実行する。 1. 下記処理を実行の上で、ステータスコード200(正常)として複雑空席照会結果を返却する。   1. DxAPIへのリクエストパラメータとしてのプロモーションコードは、指定されたプロモーションコードがASWDB(マスタ)にCAT25として存在している場合には紐づくアカウントコードを指定する。存在しない場合にはAAMによるプロモーションコードとみなし、指定された値をそのまま指定する。   1. 呼び出し元より渡された出発、到着空港コードそれぞれにおいて、都市コードか空港コードいずれであるかを下記の通り判断の上、DxAPIのリクエストパラメータとしてlocationTypeを指定する。     1. 呼び出し元より渡された各空港コードに、「+」が付与されている場合は、照会用空港コードとして判定。     1. 呼び出し元より渡された各空港コードが、ASWDB(マスタ)の都市コードと一致する場合には、都市コードとして判定。     1. 上記以外の場合には、空港コードとして判定。   1. 呼び出し元より渡された検索条件に基づきDxAPIにリクエストを行い、複雑空席照会結果を取得する。   1. 検索結果に対し、以下の通り【検索結果の書き換え処理】を実施する。     1. 第一バウンド第一セグメントが最終発券期限を過ぎている、もしくは、セグメントのキャビンクラスにFFのキャビンクラスより上位となるキャビンクラスが含まれている場合には、検索結果対象から除去する。最終発券期限は出発時刻まで6時間を切っているかで判定するが、出発時刻はその空港のタイムゾーンの時刻となっているため、比較時は現在時刻に対してASWDB(マスタ)から空港コードをキーに取得した時差を考慮する。     1. 検索結果のAirOfferに複数のFFが混在している場合、Priority Codeが最小のものをAirOfferのFFとして扱うよう、FFを書き換える。なお、内際区間を含むAirOfferの場合は、国内区間を除外し、国際区間の中でPriorityCodeが最も小さいものをAirOfferのFFとして扱う。   1. 以下のいずれか条件に合致する場合、ASWDB(マスタ)に定義する検索条件のCFFに紐づく上位CFFの有無をチェックし、存在する場合は上位CFFにより自動再検索を行う。再検索結果に対しても【検索結果の書き換え処理】を実施する。      1. 残席があるAirOfferを含む検索結果が得られなかった場合         ※搭乗者数&gt;残席数のセグメントを含む場合も、残席なしとして扱う。     1. 検索条件のCFFに紐づくキャビンクラスの結果が得られなかった場合   1. 検索結果を得られなかった場合、warning情報のみ（dataは返却しない）を返却する。   1. 検索結果のうち、それぞれのFFごとに空席があるAirOfferの中で最安となるAirOfferを、返却するFF毎のおすすめ旅程として決定する。ただし、空席のあるAirOfferが得られなかったFFについては、おすすめ旅程は返却せず、検索結果売り切れ判定:trueとして返却する。       ※搭乗者数&gt;残席数のセグメントを含む場合も、残席なしとして扱う。   1. リクエストパラメータの検索結果に最新の運航情報を含める処理の実行要否がtrueの場合、TSリスト中に含まれるNHグループ運航国際便、NH販売キャリア日本国内便のうち、出発予定時刻(STD)までの時間が48時間以内であるセグメントについて、発着APIより最新の運航情報を取得する。  # 3. データ更新内容 なし  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public complexTripPost(
    generated?: ComplexRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<ComplexResponse>;
  public complexTripPost(
    generated?: ComplexRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<ComplexResponse>>;
  public complexTripPost(
    generated?: ComplexRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<ComplexResponse>>;
  public complexTripPost(
    generated?: ComplexRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/complex-trip`;
    return this.httpClient.request<ComplexResponse>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要 検索条件情報を、お気に入り情報としてASWDB(Tx)に対して登録する。  # 2. 処理内容 1. 【フライト検索条件登録共通処理】として、以下の処理を実行する。   1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、エラーハンドリング(API)(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。   1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。   1. 認可検証APIより返却されたuuidを基に、ASWDB(Tx)からパーソナライズ情報を取得する。以下の条件のいずれかに合致する場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。       1. パーソナライズ情報のログインステータスが取得できない       1. パーソナライズ情報のログインステータスが未ログインである       1. パーソナライズ情報から会員番号を取得できない     1. リクエストパラメータの入力チェックとして、以下処理を実施する。     1. 旅程タイプが往復旅程の場合、もしくは旅程タイプが片道又は複雑旅程、かつバウンドリストの要素数&#x3D;1(片道)または2(オープンジョー)の場合、往復指定日空席照会(OWD)用APIの【往復空席照会入力チェック処理】       1. 上記以外の場合、複雑空席照会APIの【複雑空席照会入力チェック処理】 1. AMC会員番号をキーにASWDB(Tx)からお気に入り検索条件を取得し、取得した検索条件にリクエストパラメータと同一条件の検索条件が既に登録済みである場合、重複レコードを削除する。また、取得した検索条件と同一条件ではなく、取得した検索条件数が、設定ファイルに定義された設定最大件数に到達している場合、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。削除時にエラーが発生した場合、ステータスコード500(Internal Server Error)でエラー情報を返して、本処理を中止とする。 1. ASWDB(Tx)に対してAMC会員番号、登録日時をキーにお気に入り検索条件を登録する。   1. ステータスコード201(正常)を返却し処理を終了する。  # 3. データ更新内容 - リクエストパラメータで受け取った検索条件情報をASWDB(Tx)に登録  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public favoritePost(
    generated?: FavoritePostRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<FavoritePostResponse>;
  public favoritePost(
    generated?: FavoritePostRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<FavoritePostResponse>>;
  public favoritePost(
    generated?: FavoritePostRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<FavoritePostResponse>>;
  public favoritePost(
    generated?: FavoritePostRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/favorite`;
    return this.httpClient.request<FavoritePostResponse>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要 1. 複雑空席照会で選択したAir Offer及びバウンドを基にDxAPIのFind more Flights空席照会を行い、検索結果を返却する。  # 2. 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、エラーハンドリング(API)(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返却する。 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。 1. リクエストパラメータについて、以下に合致する場合、エラー項目及びエラー内容と共にステータスコード400(Bad request)でエラー情報を返却し、本処理を中止とする。   1. プロモーションコードの指定がある場合、ASWDB(マスタ)よりオフィスコードに紐づくプロモーション利用可否を取得し、利用不可である。 1. リクエストパラメータにて指定されたバウンドについて、以下に従いDxAPIから空席照会結果を取得する。   1. DxAPIへのリクエストパラメータとしてのプロモーションコードは、指定されたプロモーションコードがASWDB(マスタ)にCAT25として存在している場合には紐づくアカウントコードを指定する。存在しない場合にはAAMによるプロモーションコードとみなし、指定された値をそのまま指定する。   1. 検索対象のバウンドが第一バウンド、かつ第一セグメントが最終発券期限を過ぎている場合は検索結果から除外する。   1. 除外した結果、検索結果が0件の場合は、ステータスコード200(正常)及び検索結果が0件の旨をwarning情報を返却し、本処理を中止とする。   1. TSリスト中に含まれるNHグループ運航国際便、NH販売キャリア日本国内便のうち、出発予定時刻(STD)までの時間が48時間以内であるセグメントについて、発着APIより最新の運航情報を取得する。 1. ステータスコード200(正常)を返却し処理を終了する。  # 3. データ更新内容 なし  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public findMoreFlightsPost(
    generated?: FindMoreFlightsRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<FindMoreFlightsResponse>;
  public findMoreFlightsPost(
    generated?: FindMoreFlightsRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<FindMoreFlightsResponse>>;
  public findMoreFlightsPost(
    generated?: FindMoreFlightsRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<FindMoreFlightsResponse>>;
  public findMoreFlightsPost(
    generated?: FindMoreFlightsRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/find-more-flights`;
    return this.httpClient.request<FindMoreFlightsResponse>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要 リクエストパラメータで特定されるフライト検索履歴又はお気に入りを削除する。  # 2. 処理概要 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、エラーハンドリングAPI(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。 1. 認可検証APIより返却されたuuidを基に、ASWDB(Tx)からパーソナライズ情報を取得する。以下の条件のいずれかに合致する場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。     1. パーソナライズ情報のログインステータスが取得できない     1. パーソナライズ情報のログインステータスが未ログインである     1. パーソナライズ情報から会員番号を取得できない   1. 会員情報および呼び出し元より渡された削除対象データの登録日時に紐づくフライト検索履歴、又はお気に入りを削除する。削除時にエラーが発生した場合、ステータスコード500(Internal Server Error)でエラー情報を返して、本処理を中止とする。削除対象データが存在しない場合はステータスコード400(Bad request)を返して、本処理を中止とする。  1. ステータスコード204(正常)を返却し処理を終了する。  # 3. データ更新内容 - 会員情報および呼び出し元より渡された削除対象データの登録日時に紐づくフライト検索履歴、又はお気に入り情報  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public historyFavoriteDeletePost(
    generated?: HistoryFavoriteDeleteRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any>;
  public historyFavoriteDeletePost(
    generated?: HistoryFavoriteDeleteRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<any>>;
  public historyFavoriteDeletePost(
    generated?: HistoryFavoriteDeleteRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<any>>;
  public historyFavoriteDeletePost(
    generated?: HistoryFavoriteDeleteRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/history-favorite/delete`;
    return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要 検索条件の履歴・お気に入り情報をASWDB(Tx)から返却する。  # 2. 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、エラーハンドリング(API)(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。 1. 認可検証APIより返却されたuuidを基に、ASWDB(Tx)からパーソナライズ情報を取得する。以下の条件のいずれかに合致する場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。     1. パーソナライズ情報のログインステータスが取得できない     1. パーソナライズ情報のログインステータスが未ログインである     1. パーソナライズ情報から会員番号を取得できない   1. ASWDB(Tx)から、ログイン中のAMC会員番号に紐づけられた履歴情報、お気に入り情報を全て取得し返却する。 1. ステータスコード200(正常)を返却し処理を終了する。  # 3. データ更新内容 なし  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public historyFavoriteGet(
    generated?: object,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HistoryFavoriteGetResponse>;
  public historyFavoriteGet(
    generated?: object,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<HistoryFavoriteGetResponse>>;
  public historyFavoriteGet(
    generated?: object,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<HistoryFavoriteGetResponse>>;
  public historyFavoriteGet(
    generated?: object,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/history-favorite`;
    return this.httpClient.request<HistoryFavoriteGetResponse>('get', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要 検索条件情報を、検索履歴情報としてASWDB(Tx)に対して登録する。  # 2. 処理内容 1. お気に入り情報登録APIの【フライト検索条件登録共通処理】を実行する。 1. AMC会員番号をキーにASWDB(Tx)から検索履歴情報を取得し、取得した検索条件にリクエストパラメータと同一条件の検索条件が既に登録済みである場合、会員番号と登録日時に紐づく検索履歴情報を削除する。また、取得した検索条件と同一条件ではなく、取得した検索条件数が、設定ファイルに定義された設定最大件数に到達している場合、最も古い検索履歴情報を削除する。削除時にエラーが発生した場合、ステータスコード500(Internal Server Error)でエラー情報を返して、本処理を中止とする。 1. ASWDB(Tx)に対してAMC会員番号、登録日時をキーに検索履歴として検索条件を登録する。登録時にエラーが発生した場合、ステータスコード500(Internal Server Error)でエラー情報を返して、本処理を中止とする。 1. ステータスコード201(正常)を返却し処理を終了する。  # 3. データ更新内容 - リクエストパラメータで受け取った検索条件情報をASWDB(Tx)に登録  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public historyPost(
    generated?: HistoryPostRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any>;
  public historyPost(
    generated?: HistoryPostRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<any>>;
  public historyPost(
    generated?: HistoryPostRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<any>>;
  public historyPost(
    generated?: HistoryPostRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/history`;
    return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要 アクセストークンに紐づくkaptcha画像を返却する。  # 2. 処理内容 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。  1. アクセストークンをキーにASWDB(Tx)よりkaptcha画像ファイル保存先のパスを取得し、取得したパスのkaptcha画像をエンコードして呼び出し元に返却する。保存先のパス又は画像ファイルが取得できない場合は、ステータスコード400(Bad Request)を返却し、処理を終了する。  1. ステータスコード200(正常)を返却し、処理を終了する。
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public kaptchaImagePost(
    generated?: object,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'image/jpeg' | 'application/json'; context?: HttpContext }
  ): Observable<object>;
  public kaptchaImagePost(
    generated?: object,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'image/jpeg' | 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<object>>;
  public kaptchaImagePost(
    generated?: object,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'image/jpeg' | 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<object>>;
  public kaptchaImagePost(
    generated?: object,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'image/jpeg' | 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['image/jpeg', 'application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/kaptcha-image`;
    return this.httpClient.request<object>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要 【往復指定日空席照会(OWD)用API】   指定された検索条件を基に、指定した日付の前後3日間における最安金額及び、指定した日付のフライト・運賃の候補リストを返却する。  # 2. 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、エラーハンドリング(API)(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返却する。 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。   有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。  1. ASWDB(マスタ)のIPアドレスの制限レベルに基づき下記処理を実施する。【IPアドレスの制限レベルに基づく認証処理】   1. 当該IPアドレスの制限レベルが”BLOCK”の場合は、ステータスコード403(Forbidden)を返却し処理を終了する。   1. 当該IPアドレスの制限レベルが\&quot;CAPTCHA\&quot;で、ASWDB(Tx)のユーザ共通に画像認証「成功」を保持している場合には、認証成功の旨を削除して、以降の処理を継続する。それ以外の場合には、ステータスコード403(Forbidden)を返却し処理を終了する。 1. リクエストパラメータについて、以下いずれかに合致する場合、エラー項目及びエラー内容と共にステータスコード400(Bad request)でエラー情報を返却し、本処理を中止とする。【往復空席照会入力チェック処理】   1. 出発空港、到着空港、乗り継ぎ空港が、ASWDB(マスタ)の照会用空港コードとして存在しない。   1. 1バウンド目出発空港の照会用空港コードに紐づく、ASWDB(マスタ)の有償表示フラグが“出発地＆目的地\&quot; または \&quot;出発地\&quot;でない。   1. 操作オフィスがAPF(TYONH08AP)の場合で、1バウンド目出発空港の照会用空港コードに紐づく、ASWDB(マスタ)の国コードが日本でない。   1. 1バウンド目出発空港以外のいずれかの照会用出発空港コードに紐づく、ASWDB(マスタ)の有償表示フラグが\&quot;出発地＆目的地\&quot;または \&quot;目的地\&quot;でない。   1. バウンドの出発空港と到着空港それぞれに紐づくASWDB(マスタ)の都市コードが同一となるバウンドがある。   1. 操作オフィスに紐づくASWDB(マスタ)のPOSが日本で、全空港の照会用空港コードに紐づく国コードが日本（日本国内単独旅程）である。   1. 操作オフィスに紐づくASWDB(マスタ)のPOSがアメリカで、照会用空港コードに紐づく国コードがキューバの空港を含んでいる。   1. 出発年月日が、オフィスコードをキーにした該当の国の時差を考慮した上で、ローカル日付から数えて設定ファイルに定義した日数の期間外である。   1. 2バウンドの場合、2バウンド目の出発年月日が1バウンド目の出発年月日よりも前である。   1. 出発開始時刻と出発終了時刻のいずれかのみ設定されている。   1. 出発開始時刻が、出発終了時刻以降の時刻になっている。   1. 出発開始時刻と出発終了時刻の時刻の差が2の倍数となる整数値の時間でない。ただし、出発時刻が\&quot;23:59:00\&quot;の場合は、差分に1分を加算した値を用いて判定する。   1. 搭乗者の組み合わせについて、下記のいずれかに合致する。     1. ADTが0名かつ、CHDとINFの合計人数が1名以上である。        1. ADTの人数がINFの人数よりも少ない。     1. ADT/B15/CHDの合計人数が、10名以上である。     1. ADTとB15の合計人数が、0名である。     1. 日本国内単独旅程であった場合に、INFの人数が1名以上である。   1. MixedCabin選択有無がtrueの場合に、下記のいずれかに合致する。     1. Mixed Cabin情報が指定されていない。     1. 日本国内単独旅程の場合、ASWDB(マスタ)のCFF区分が有償日本国内単独運賃かつ、Mixed Cabin Class検索用の区分が「Mixed Cabin Classのみ検索可能」もしくは「Mixed Cabin ClassとMixed Cabin Classではない検索ともに可能」、往路復路それぞれのキャビンクラスに合致するCFFが存在しない。     1. 国際旅程の場合、ASWDB(マスタ)のCFF区分が有償国際線運賃かつ、Mixed Cabin Class検索用の区分が「Mixed Cabin Classのみ検索可能」もしくは「Mixed Cabin ClassとMixed Cabin Classではない検索ともに可能」、往路復路それぞれのキャビンクラスに合致するCFFが存在しない。   1. MixedCabin選択有無がfalseの場合に、下記のいずれかに合致する。     1. キャビンクラスが指定されていない。     1. 日本国内単独旅程の場合、ASWDB(マスタ)のCFF区分が有償日本国内単独運賃かつ、Mixed Cabin Class検索用の区分が「Mixed Cabin Classで検索不可」もしくは「Mixed Cabin ClassとMixed Cabin Classではない検索ともに可能」かつ、該当するキャビンクラス、運賃オプションタイプに合致するCFFが存在しない。     1. 国際旅程の場合、ASWDB(マスタ)のCFF区分が有償国際線運賃かつ、Mixed Cabin Class検索用の区分が「Mixed Cabin Classで検索不可」もしくは「Mixed Cabin ClassとMixed Cabin Classではない検索ともに可能」かつ、該当するキャビンクラス、運賃オプションタイプに合致するCFFが存在しない。   1. プロモーションコードの指定がある場合、ASWDB(マスタ)よりオフィスコードに紐づくプロモーション利用可否を取得し、利用不可である。 1. アクセスを制限に関して、下記処理を実施する。【空席照会回数に基づくアクセス制御処理】   1. ASWDB(Tx)に当該IPアドレス及び1バウンド目の出発地・到着地に紐づく空席照会回数データが存在する場合は、最終更新日時と現在日時が、設定ファイルに定義したアクセス間隔の閾値を超えているかを確認し、その結果に基づき下記の処理を行う。     1. 超えていた場合はASWDB(Tx)の空席照会回数を0リセットし、最終更新日時及び削除予定日時を更新する。最終更新日時は現在日時を、削除予定日時は、現在日時＋設定ファイルで設定した秒で更新する。     1. 超えていない場合は空席照会回数を+1カウントアップさせる。カウントアップ後の空席照会回数が、設定ファイルの空席照会回数の閾値を超えた場合は、ASWDB(Tx)の空席照会回数を0リセットし、ASWDB(Tx)のユーザ情報に画像認証「失敗」を登録し、ステータスコード403(Forbidden)を返却し処理を終了する。   1. ASWDB(Tx)に当該IPアドレスかつ、出発地・到着地がASWDB(マスタ)の画像認証表示対象区間に該当する空席照会回数データが存在しない場合は、空席照会回数を1件として新規登録する。新規登録時は、当該IPアドレス、出発地・到着地、最終更新日時、現在日時＋設定ファイルに設定した秒を削除予定日時として登録する。 1. 下記処理を実行の上で、ステータスコード200(正常)として往復指定日空席照会結果を返却する。   1. DxAPIへのリクエストパラメータとしてのプロモーションコードは、指定されたプロモーションコードがASWDB(マスタ)にCAT25として存在している場合には紐づくアカウントコードを指定する。存在しない場合にはAAMによるプロモーションコードとみなし、指定された値をそのまま指定する。   1. 呼び出し元より渡された出発、到着空港コードそれぞれにおいて、都市コードか空港コードいずれであるかを下記の通り判断の上、DxAPIのリクエストパラメータとしてlocationTypeを指定する。     1. 呼び出し元より渡された各空港コードに、「+」が付与されている場合は、照会用空港コードとして判定。     1. 呼び出し元より渡された各空港コードが、ASWDB(マスタ)の都市コードと一致する場合には、都市コードとして判定。     1. 上記以外の場合には、空港コードとして判定。   1. リクエストパラメータにて、照会結果としてカレンダー情報のみ返却すると指定された場合、下記処理を行う。     1. DxAPIより指定した日付の前後3日間における各日付の最安金額を取得する。     1. 下記の通り、条件に応じて再検索を実行する。          1. DxAPIから取得した、「指定した日付の前後3日間における各日付の最安金額」に対して、下記の条件に合致するかを確認する。【再検索実施要否判定】            1. 有効な検索結果が得られなかった。（※）             ※搭乗者数&gt;残席数のセグメントを含む場合も、残席なしとして扱う。           1. 検索条件のCFFに紐づくキャビンクラスの結果が得られなかった。（※）             ※CFFには、主とするキャビンクラスのFFに加えて、アップセル用の上位キャビンクラスのFFを設定している場合があるが、この上位キャビンクラスの結果しか得られない場合を指す。         1. いずれかの条件に合致した場合、ASWDB(マスタ)に定義する検索条件のCFFに紐づく上位CFFの有無をチェックし、存在する場合は上位CFFにより自動再検索を行う。         1. 初回・再検索時のいずれの場合にも検索結果を得られなかった場合、金額情報を含まないカレンダー日付に関する情報のみを返却する。   1. リクエストパラメータにて、照会結果としてカレンダー情報のみ返却すると指定されていない場合、下記処理を行う。     1. 呼び出し元より渡された検索条件に基づき、並列処理として、指定した1日分のAirOffer一覧、指定した日付の前後3日間における各日付の最安金額を、それぞれDxAPIより取得する。     1. 下記の通り、条件に応じて再検索を実行する。         1. DxAPIから取得した、「指定した1日分のAirOffer一覧」と「指定した日付の前後3日間における各日付の最安金額」の両方の結果に対して、再検索実施可否判定を実施する。         1. DxAPIから取得した結果の両方に対していずれかの条件に合致した場合、ASWDB(マスタ)に定義する検索条件のCFFに紐づく上位CFFの有無をチェックし、存在する場合は上位CFFにより自動再検索を行う。ただし、「指定した1日分のAirOffer一覧」結果に対して、AirOfferがない検索結果となった場合は、CFFを変更しても検索結果は変わらないため再検索は行わない。         1. 再検索時においても、「指定した1日分のAirOffer一覧」に対して、全検索結果が残席なし（※）である結果の場合、初回検索時の検索結果を返却対象とする。ただし、再検索の上、「指定した日付の前後3日間における各日付の最安金額」のみ有効な検索結果を得られている場合には、再検索時の検索結果を返却対象とする。           ※搭乗者数&gt;残席数のセグメントを含む場合も、残席なしとして扱う。         1. DxAPIから取得した結果の両方に対して有効な検索結果を得られなかった場合、warning情報のみ（dataは返却しない）を返却する。     1. リクエストパラメータの検索結果に最新の運航情報を含める処理の実行要否がtrueの場合、TSリスト中に含まれるNHグループ運航国際便、NH販売キャリア日本国内便のうち、出発予定時刻(STD)までの時間が48時間以内であるセグメントについて、発着APIより最新の運航情報を取得する。  # 3. データ更新内容 なし  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public roundtripOwdPost(
    generated?: RoundtripOwdRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<RoundtripOwdResponse>;
  public roundtripOwdPost(
    generated?: RoundtripOwdRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<RoundtripOwdResponse>>;
  public roundtripOwdPost(
    generated?: RoundtripOwdRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<RoundtripOwdResponse>>;
  public roundtripOwdPost(
    generated?: RoundtripOwdRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/roundtrip-owd`;
    return this.httpClient.request<RoundtripOwdResponse>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1 概要 指定されたセグメントのキャビンクラスごとのアップグレード空席待ち人数を取得する。  # 2 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、共通部品「エラーハンドリング」(G01-010)を呼び出してMulesoftが生成したエラー情報を解析し、**HTTPステータスコード:400**及びエラー情報を返却して、本処理を中止とする。  1. 呼び出し元より渡されたアクセストークンについて、認可検証APIを呼び出してcookie、アクセストークンの有効性確認及びTTL延長を行う。&lt;br&gt;   有効でない場合、**HTTPステータスコード:401**及びエラー情報を返却して、本処理を中止とする。  1. 呼び出し元より渡されたアクセストークンを復号し、トークン内に含まれるuuidを基に、ASWDB(Tx)からログイン中の会員情報を取得する。&lt;br&gt;   AMC会員番号を取得できなかった場合、**HTTPステータスコード:401**及びエラー情報を返却して、本処理を中止とする。  1. 呼び出し元より渡された出発日付、販売キャリアコード、便番号を基に、DxAPIを呼び出して、対象セグメント情報を取得する。&lt;br&gt;   取得できなかった場合、**HTTPステータスコード:400**及びエラー情報を返却して、本処理を中止とする。  1. 以下のいずれかの条件に合致する場合、指定されたセグメントがNHグループ運航国際線以外であるとし、**HTTPステータスコード:400**及びエラー情報を返却して、本処理を中止とする。   1. 対象セグメント情報の出発空港コードに紐づくASWDB(マスタ)が存在しない   1. 対象セグメント情報の到着空港コードに紐づくASWDB(マスタ)が存在しない   1. 発着それぞれの空港コードを基に、ASWDB(マスタ)から取得した国コード(2レター)が一致している   1. 対象セグメントの運航キャリアコードが\&quot;NH\&quot;(ANA)、\&quot;NQ\&quot;(エアージャパン)ではない 1. 呼び出し元より渡された出発日付、販売キャリアコード、便番号を基に、Altea Web Serviceを呼び出して、アップグレード空席待ち人数を含んだセグメント情報を取得する。&lt;br&gt;   取得できなかった場合、**HTTPステータスコード:400**及びエラー情報を返却して、本処理を中止とする。  1. **HTTPステータスコード:200**を返却して、本処理を終了する。  # 3 データ更新内容   なし。  # 4 特記事項   なし。
   * @param departureDateTime 出発日付(yyyy-MM-dd\&#39;T\&#39;HH:mm:ss形式)
   * @param marketingAirlineCode 販売キャリアコード
   * @param marketingFlightNumber 便番号
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public searchUpgradeWaitlistGet(
    departureDateTime: string,
    marketingAirlineCode: string,
    marketingFlightNumber: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<Type3>;
  public searchUpgradeWaitlistGet(
    departureDateTime: string,
    marketingAirlineCode: string,
    marketingFlightNumber: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<Type3>>;
  public searchUpgradeWaitlistGet(
    departureDateTime: string,
    marketingAirlineCode: string,
    marketingFlightNumber: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<Type3>>;
  public searchUpgradeWaitlistGet(
    departureDateTime: string,
    marketingAirlineCode: string,
    marketingFlightNumber: string,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    if (departureDateTime === null || departureDateTime === undefined) {
      throw new Error(
        'Required parameter departureDateTime was null or undefined when calling searchUpgradeWaitlistGet.'
      );
    }
    if (marketingAirlineCode === null || marketingAirlineCode === undefined) {
      throw new Error(
        'Required parameter marketingAirlineCode was null or undefined when calling searchUpgradeWaitlistGet.'
      );
    }
    if (marketingFlightNumber === null || marketingFlightNumber === undefined) {
      throw new Error(
        'Required parameter marketingFlightNumber was null or undefined when calling searchUpgradeWaitlistGet.'
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (departureDateTime !== undefined && departureDateTime !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>departureDateTime,
        'departureDateTime'
      );
    }
    if (marketingAirlineCode !== undefined && marketingAirlineCode !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>marketingAirlineCode,
        'marketingAirlineCode'
      );
    }
    if (marketingFlightNumber !== undefined && marketingFlightNumber !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>marketingFlightNumber,
        'marketingFlightNumber'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/search/upgrade-waitlist`;
    return this.httpClient.request<Type3>('get', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1 概要 指定された出発日付と区間ごとに、アップグレード可能な空席状況をキャビンクラス別に取得する。  # 2 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、共通部品「エラーハンドリング」(G01-010)を利用してMulesoftが生成したエラー情報を解析し、**HTTPステータスコード:400** でエラー情報を返却し、本処理を中止とする。 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br&gt; 有効でない場合、**HTTPステータスコード:401** でエラー情報を返却し、本処理を中止とする。 1. 呼び出し元より渡されたアクセストークンを復号し、トークン内に含まれるuuidを基に、ASWDB(Tx)からログイン中の会員情報を取得する。&lt;br&gt; AMC会員番号を取得できなかった場合、**HTTPステータスコード:401** でエラー情報を返却し、本処理を中止とする。 1. 呼び出し元より渡された出発日付と区間ごとに以下の処理を実行する。   1. 対象の出発日付と、出発地の空港情報の空港コード、到着地の空港情報の空港コードに基づき、Altea Web Service経由で空席情報を取得する。&lt;br&gt;   取得できなかった場合、**HTTPステータスコード400**でエラー情報を返却し、本処理を中止とする。   1. 空席情報のセグメントから、NHグループ運航国際線のリストとして、以下全てを満たすセグメントのリストを作成する。&lt;br&gt;   同じ便名の情報が複数存在する場合、「直行便」、「他のNH販売便が含まれるTS」、「他社販売便が含まれるTS」の順で最初に存在するものを対象としてリストを作成する。     1. 対象セグメントの出発地の空港コードに基づき、ASWDB(マスタ)から出発地の空港情報を取得できる。     1. 対象セグメントの到着地の空港コードに基づき、ASWDB(マスタ)から到着地の空港情報を取得できる。     1. 発着それぞれの空港情報より、国コード(2レター)が一致しない。     1. 対象セグメントの運航キャリアコードが\&quot;NH\&quot;(ANA)、\&quot;NQ\&quot;(エアージャパン)のいずれかである。 1. **HTTPステータスコード:200** を返却し、本処理を終了する。  # 3 データ更新内容 なし  # 4 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public upgradeAvailabilityPost(
    generated?: UpgradeAvailabilityRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<UpgradeavailabilityResponse>;
  public upgradeAvailabilityPost(
    generated?: UpgradeAvailabilityRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<UpgradeavailabilityResponse>>;
  public upgradeAvailabilityPost(
    generated?: UpgradeAvailabilityRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<UpgradeavailabilityResponse>>;
  public upgradeAvailabilityPost(
    generated?: UpgradeAvailabilityRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/upgrade-availability`;
    return this.httpClient.request<Type6>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要 便番号と運航日をキーにWi-Fi使用可否を、ASWDB(マスタ)に対して登録・更新する。  # 2. 処理内容 1. リクエストパラメータの便番号と運航日をキーにWi-Fi使用可否を更新する。   1. ASWDB(マスタ)に便番号と運航日が未登録の場合、便番号と運航日をキーにWi-Fi使用可否を新規登録する。 1. ステータスコード200(正常)を返却し処理を終了する。  # 3. データ更新内容 - 呼び出し元より渡された便番号と運航日に紐づくWi-Fi使用可否情報  # 4. 特記事項 - なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public wifiAvailabilityPost(
    generated?: Type2,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<string>;
  public wifiAvailabilityPost(
    generated?: Type2,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<string>>;
  public wifiAvailabilityPost(
    generated?: Type2,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<string>>;
  public wifiAvailabilityPost(
    generated?: Type2,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/wifi-availability`;
    return this.httpClient.request<string>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }
}
