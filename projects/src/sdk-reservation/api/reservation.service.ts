/**
 * aswbe reservation eapi
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import { Inject, Injectable, Optional } from '@angular/core';
import {
  HttpClient,
  HttpHeaders,
  HttpParams,
  HttpResponse,
  HttpEvent,
  HttpParameterCodec,
  HttpContext,
} from '@angular/common/http';
import { CustomHttpParameterCodec } from '../encoder';
import { Observable } from 'rxjs/internal/Observable';
import { of } from 'rxjs/internal/observable/of';
import { CartsAddTravelersRequest } from '../model/cartsAddTravelersRequest';
import { CartsAddTravelersResponse } from '../model/cartsAddTravelersResponse';
import { CartsDeleteTravelerRequest } from '../model/cartsDeleteTravelerRequest';
import { CartsDeleteTravelerResponse } from '../model/cartsDeleteTravelerResponse';
import { CartsUpdateServicesRequest } from '../model/cartsUpdateServicesRequest';
import { CartsUpdateServicesResponse } from '../model/cartsUpdateServicesResponse';
import { CartsUpdateTravelersRequest } from '../model/cartsUpdateTravelersRequest';
import { CartsUpdateTravelersResponse } from '../model/cartsUpdateTravelersResponse';
import { CreateCartRequest } from '../model/createCartRequest';
import { CreateCartResponse } from '../model/createCartResponse';
import { OfflinePaymentRequest } from '../model/offlinePaymentRequest';
import { OfflinePaymentResponse } from '../model/offlinePaymentResponse';
import { OrdersCreateOrderRequest } from '../model/ordersCreateOrderRequest';
import { OrdersCreateOrderResponse } from '../model/ordersCreateOrderResponse';
import { OrdersDeletePrebookedOrderRequest } from '../model/ordersDeletePrebookedOrderRequest';
import { OrdersDeletePrebookedOrderResponse } from '../model/ordersDeletePrebookedOrderResponse';
import { OrdersPaymentRecordsRequest } from '../model/ordersPaymentRecordsRequest';
import { OrdersPaymentRecordsResponse } from '../model/ordersPaymentRecordsResponse';
import { OrdersAnaBizGetApproversResponse } from '../model/ordersAnaBizGetApproversResponse';
import { OrdersAnaBizSendBackTicketingRequestRequest } from '../model/ordersAnaBizSendBackTicketingRequestRequest';
import { OrdersAnaBizSendBackTicketingRequestResponse } from '../model/ordersAnaBizSendBackTicketingRequestResponse';
import { OrdersAnaBizTicketingRequestRequest } from '../model/ordersAnaBizTicketingRequestRequest';
import { OrdersAnaBizTicketingRequestResponse } from '../model/ordersAnaBizTicketingRequestResponse';
import { OrdersRepriceOrderRequest } from '../model/ordersRepriceOrderRequest';
import { OrdersRepriceOrderResponse } from '../model/ordersRepriceOrderResponse';
import { PatchUpdateAirOffersRequest } from '../model/patchUpdateAirOffersRequest';
import { PatchUpdateAirOffersResponse } from '../model/patchUpdateAirOffersResponse';
import { PlansCreatePlansRequest } from '../model/plansCreatePlansRequest';
import { PlansCreatePlansResponse } from '../model/plansCreatePlansResponse';
import { PlansDeletePlansRequest } from '../model/plansDeletePlansRequest';
import { PlansDeletePlansResponse } from '../model/plansDeletePlansResponse';
import { PlansGetEstimationRequest } from '../model/plansGetEstimationRequest';
import { PlansGetEstimationResponse } from '../model/plansGetEstimationResponse';
import { PlansGetPlansRequest } from '../model/plansGetPlansRequest';
import { PlansGetPlansResponse } from '../model/plansGetPlansResponse';
import { PlansUpdatePlannameRequest } from '../model/plansUpdatePlannameRequest';
import { PlansUpdatePlannameResponse } from '../model/plansUpdatePlannameResponse';
import { PostGetCartRequest } from '../model/postGetCartRequest';
import { PostGetCartResponse } from '../model/postGetCartResponse';
import { Type } from '../model/type';
import { BASE_PATH, COLLECTION_FORMATS } from '../variables';
import { Configuration } from '../configuration';
import { CartsUpdatePetRakunoriResponse } from '../model/cartsUpdatePetRakunoriResponse';
import { CartsUpdatePetRakunoriRequest } from '../model/cartsUpdatePetRakunoriRequest';

@Injectable({
  providedIn: 'root',
})
export class ReservationService {
  protected basePath = 'http://localhost:8000';
  public defaultHeaders = new HttpHeaders();
  public configuration = new Configuration();
  public encoder: HttpParameterCodec;

  constructor(
    protected httpClient: HttpClient,
    @Optional() @Inject(BASE_PATH) basePath: string | string[],
    @Optional() configuration: Configuration
  ) {
    if (configuration) {
      this.configuration = configuration;
    }
    if (typeof this.configuration.basePath !== 'string') {
      if (Array.isArray(basePath) && basePath.length > 0) {
        basePath = basePath[0];
      }

      if (typeof basePath !== 'string') {
        basePath = this.basePath;
      }
      this.configuration.basePath = basePath;
    }
    this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
  }

  private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
    if (typeof value === 'object' && value instanceof Date === false) {
      httpParams = this.addToHttpParamsRecursive(httpParams, value);
    } else {
      httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
    }
    return httpParams;
  }

  private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
    if (value == null) {
      return httpParams;
    }

    if (typeof value === 'object') {
      if (Array.isArray(value)) {
        (value as any[]).forEach((elem) => (httpParams = this.addToHttpParamsRecursive(httpParams, elem, key)));
      } else if (value instanceof Date) {
        if (key != null) {
          httpParams = httpParams.append(key, (value as Date).toISOString().substr(0, 10));
        } else {
          throw Error('key may not be null if value is Date');
        }
      } else {
        Object.keys(value).forEach(
          (k) => (httpParams = this.addToHttpParamsRecursive(httpParams, value[k], key != null ? `${key}.${k}` : k))
        );
      }
    } else if (key != null) {
      httpParams = httpParams.append(key, value);
    } else {
      throw Error('key may not be null if value is not object or array');
    }
    return httpParams;
  }

  /**
   * # 1. 概要 カートに登録された搭乗者情報の追加を行う。  # 2. 処理内容   1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、HTTPステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;    1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br/&gt;   有効でない場合、HTTPステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;    1. DxAPIからリクエストパラメータで指定されたカートIDに紐づくカート情報を取得する。取得できない場合、HTTPステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;    1. カート内の搭乗者人数とリクエストパラメータの搭乗者人数を合算し、以下の入力チェックを行う。以下の条件に合致する場合、HTTPステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。     1. 搭乗者人数の確認として、以下のいずれかを満たす。&lt;br/&gt;       1. 幼児を除く搭乗者合計人数が10人以上である。&lt;br/&gt;       1. 大人の搭乗者人数より幼児の搭乗者人数が多い。&lt;br/&gt;       1. 大人の搭乗者人数が0名かつ、小児と幼児の合計人数が1名以上である。&lt;br/&gt;       1. 大人とヤングアダルトの搭乗者合計人数が、0名である。&lt;br/&gt;       1. 日本国内単独旅程であった場合に、幼児の人数が1名以上である。&lt;br/&gt;    1. DxAPIを呼び出し、カートに搭乗者を追加する。&lt;br/&gt;   DxAPIよりHTTPステータスコード201(Created)かつ搭乗者が追加できない旨のエラー（\&quot;UNABLE TO ADD TRAVELERS\&quot;）が返却された場合、HTTPステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;   ※カート更新時、プラン更新日時の更新はしない。&lt;br/&gt;    1. 搭乗者情報更新APIの【最新プラン退避処理】を行う。&lt;br/&gt;    1. 正常終了の場合、HTTPステータスコード201(Created)を返却し、本処理を終了する。&lt;br/&gt;  # 3. データ更新内容 ## 1. カート   | 更新フィールド | 更新内容 | データ取得元 | 条件等 |   | :------------- | :------------- | :------------- | :------------- |   | travelers | 1. 搭乗者種別&lt;br/&gt;2. 同行者搭乗者ID&lt;br/&gt;※幼児の追加の場合は自動的に大人の搭乗者と紐づける。 | 指定した項目 | なし |
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public cartsAddTravelersPost(
    generated?: CartsAddTravelersRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<CartsAddTravelersResponse>;
  public cartsAddTravelersPost(
    generated?: CartsAddTravelersRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<CartsAddTravelersResponse>>;
  public cartsAddTravelersPost(
    generated?: CartsAddTravelersRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<CartsAddTravelersResponse>>;
  public cartsAddTravelersPost(
    generated?: CartsAddTravelersRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/carts/add-travelers`;
    return this.httpClient.request<CartsAddTravelersResponse>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要 AirOfferIDを基にカートを作成する。  # 2. 処理内容   1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br&gt;   有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。 &lt;br&gt;    2. リクエストパラメータについて、呼び出し元より渡されたアクセストークンを復号し、トークン内に含まれるuuidを基に、ASWDB(Tx)からログイン中の会員情報を取得する。&lt;br&gt;    3. リクエストパラメータのAirOfferIDより、DxAPIにてAirOfferを取得する。&lt;br&gt;   AirOfferが存在しない場合、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。&lt;br&gt;   4. ログイン中の会員情報が存在する場合、会員の生年月日と第一便時点に基づく年齢から以下の通り搭乗者種別を求める。&lt;br&gt;      | 条件 | 搭乗者種別     | :------------- | :------------- |     | 16歳以上 | \&quot;ADT\&quot;(大人) |     | 12歳～15歳 | \&quot;B15\&quot;(ヤングアダルト) |     | 3歳～11歳かつ&lt;br&gt;AirOfferの旅程のすべての空港に紐づく国コードが日本 | \&quot;CHD\&quot;(小児) |     | 2歳～11歳かつ&lt;br&gt;AirOfferの旅程のいずれかの空港に紐づく国コードが日本以外 | \&quot;CHD\&quot;(小児) |     | 上記以外 | 設定なし |          ※INF(幼児)の場合、ログイン中の会員情報が存在しないとみなす。   5. リクエストパラメータの出発空港の現在時間が&lt;font color&#x3D;\&quot;red\&quot;&gt;出発予定時刻の6時間前を過ぎている場合、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。&lt;br&gt;     出発予定時刻は以下の優先順位で判定する。&lt;/font&gt;&lt;s&gt;リクエストパラメータの出発時刻の6時間前を過ぎている場合、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。&lt;/s&gt; &lt;br&gt;     1. &lt;font color&#x3D;\&quot;red\&quot;&gt;発着APIより取得した出発時刻（出発予定時刻までの時間が48時間以内の場合のみ）&lt;/font&gt;&lt;br&gt;     2. &lt;font color&#x3D;\&quot;red\&quot;&gt;AirOfferの出発予定時刻(ETD)&lt;/font&gt;&lt;br&gt;     3. &lt;font color&#x3D;\&quot;red\&quot;&gt;AirOfferの出発予定時刻(STD)&lt;/font&gt;&lt;br&gt;    6. 以下の通りカートを作成する。&lt;br&gt;     1. リクエストパラメータのカート作成時点空席照会条件をextensionsのカート作成時点空席照会条件として登録する。&lt;br&gt;     2. ログイン中の会員情報が存在する場合、搭乗者種別が一致する最初の搭乗者に対してカートのcontacts、travelers、frequentFlyerCards、extensionsを登録する。&lt;br&gt;     DxAPIよりカート作成に失敗しエラーが返却された場合は、400(Bad request)でエラー情報を返却し、本処理を中止とする。&lt;br&gt;      7. ログイン中の会員情報が存在する場合、搭乗者種別が一致する最初の搭乗者に対して以下の処理を行う。&lt;br&gt;     1. TravelSkyキャリアが1便以上含まれる場合、パスポート情報を登録する。登録時DxAPIよりエラーが返却された場合は、ワーニングを返却する。&lt;br&gt;     2. 作成したカートのカートIDをキーにサービスカタログ情報を取得する。取得時DxAPIよりエラーが返却された場合は、ワーニングを返却する。&lt;br&gt;     3. サービスカタログ情報を取得した場合、データ更新内容のカート欄services欄に記載したサービス情報を登録する。登録時DxAPIよりエラーが返却された場合は、ワーニングを返却する。&lt;br&gt;    8. 搭乗者情報更新APIの【最新プラン退避処理】を行う。&lt;br&gt;    9. ログイン中の会員情報が存在しない場合、ASWDB(Tx)に、アクセストークンをキーに現在操作中のカートとしてカートIDを登録する。&lt;br&gt;   ※ 非会員の操作の場合、同一アクセストークンでの操作ではカート取得時に搭乗者情報をクリアを行わないようにするため、現在操作しているカートを保持する。&lt;br&gt;      10. 搭乗者情報更新APIの【最新プラン退避処理】で取得したカート情報をHTTPステータスコード200(OK)として返却し、本処理を終了する。ワーニングが存在する場合は、レスポンスのwarningsにワーニングをセットする。&lt;br&gt;    # 3. データ更新内容 ## 1. カート   | 更新フィールド | 更新内容 | データ取得元 | 条件等 |   | :------------- | :------------- | :------------- | :------------- |   | contacts | 代表者電話情報&lt;br&gt;1.電話番号国&lt;br&gt;1.1会員のいつもの携帯番号が存在する場合：日本(81)&lt;br&gt;1.2勤務先電話番号が存在する場合：勤務先の国コード&lt;br&gt;1.3自宅電話番号が存在する場合：自宅の国コード&lt;br&gt;2.電話番号&lt;br&gt;会員のいつもの携帯電話番号、勤務先電話番号、自宅電話番号の順で最初に存在するものを、それぞれ携帯電話番号(purpose&#x3D;standard、category&#x3D;personal、device&#x3D;mobile)、勤務先電話番号(purpose&#x3D;standard、category&#x3D;business)、自宅電話番号(purpose&#x3D;standard、category&#x3D;personal、device&#x3D;landline)として1つ登録する。 | ASWDB(Tx)から取得した会員情報 | ログイン済みかつ大人またはヤングアダルト会員で、更新内容に記載の電話番号が存在する場合、&lt;br&gt;代表者電話情報をログイン会員の搭乗者種別と一致する一番最初の搭乗者に対して登録する。 |   | contacts | 搭乗者電話番号&lt;br&gt;1.電話番号国(日本(81)固定)&lt;br&gt;2.電話番号&lt;br&gt;搭乗者電話情報(purpose&#x3D;notification、category&#x3D;personal、device&#x3D;mobileとしていつもの携帯電話番号を登録する)&lt;br&gt;※ 搭乗者にリレートする。 | ASWDB(Tx)から取得した会員情報 | ログイン済み、かつ大人またはヤングアダルトまたは小児会員で、操作オフィスの搭乗者SMS送信選択初期値が送信希望あり、かつ更新内容に記載の電話番号が存在する、&lt;br&gt;かつ先頭が070/080/090/70/80/90のいずれかの場合、&lt;br&gt;代表者電話情報をログイン会員の搭乗者種別と一致する一番最初の搭乗者に対して登録する。 |   | travelers | 1.敬称&lt;br&gt;※性別と旅客種別に応じた敬称を登録する。&lt;br&gt;・男性、大人またはヤングアダルト：MR&lt;br&gt;・男性、小児または幼児：MSTR&lt;br&gt;・女性、大人またはヤングアダルト：MS&lt;br&gt;・女性、小児または幼児：MISS&lt;br&gt;2.搭乗者姓名&lt;br&gt;※able-I用氏名より取得&lt;br&gt;　2.1.搭乗者名&lt;br&gt;　2.2.搭乗者姓&lt;br&gt;3.生年月日&lt;br&gt;4.性別 | ASWDB(Tx)から取得した会員情報 | ログイン済みの場合、ログイン会員の搭乗者種別と一致する一番最初の搭乗者に対して登録する。 |   | travelers.regulatory-details | パスポート情報(regulatoryApisType&#x3D;ApisDetailRegulatoryDocument、documentType&#x3D;passportとして登録する)&lt;br&gt;1.搭乗者姓名&lt;br&gt;　1.1.搭乗者名&lt;br&gt;　1.2.搭乗者姓&lt;br&gt;2.生年月日&lt;br&gt;3.性別&lt;br&gt;4.パスポート番号 | ASWDB(Tx)から取得した会員情報 | ログイン済みで、販売キャリアまたは運航キャリアが設定ファイルに定めるTravelSkyキャリアとなる便が1便以上含まれる、かつ会員情報のパスポート番号の登録がありの場合、ログイン会員の搭乗者種別と一致する一番最初の搭乗者に対して登録する。 |   | frequentFlyerCards | FQTV&lt;br&gt;　1.キャリアコード(\&quot;NH\&quot;固定)&lt;br&gt;　2.AMC会員番号&lt;br&gt;※ 搭乗者にリレートする。 | ASWDB(Tx)から取得した会員情報 | ログイン済みの場合、ログイン会員の搭乗者種別と一致する一番最初の搭乗者に対して登録する。 |   | frequentFlyerCards | FQTS&lt;br&gt;　1.キャリアコード(\&quot;NH\&quot;固定)&lt;br&gt;　2.AMC会員番号&lt;br&gt;※ 搭乗者にリレートする。 | ASWDB(Tx)から取得した会員情報 | ログイン済みの場合、ログイン会員の搭乗者種別と一致する一番最初の搭乗者に対して登録する。 |   | services | 歩行程度(SSRコード(ShortTextのcode)がWCHR/WCHS/WCHCのサービスとして登録する)&lt;br&gt;※ 搭乗者にリレートする。&lt;br&gt;※ SSRコードからDxAPIのカタログの全セグメント分のサービスIDを特定し、それを指定して登録を行う。 | ASWDB(Tx)から取得した会員情報&lt;br&gt;serviceCatalogue | ログイン済みで、会員情報の歩行状況の登録がありの場合、ログイン会員の搭乗者種別と一致する一番最初の搭乗者に対して登録する。 |   | services | 手動車いす(SSRコード(ShortTextのcode)がWCMPのサービスとして登録する)&lt;br&gt;※ 搭乗者にリレートする。&lt;br&gt;※ SSRコードからDxAPIのカタログの全セグメント分のサービスIDを特定し、それを指定して登録を行う。&lt;br&gt;parametersとして以下の値を指定することで、SSRのフリーテキストに車いす情報を登録する。&lt;br&gt;1.code&#x3D;\&quot;\&quot;TEXT\&quot;\&quot;&lt;br&gt;2.車椅子折り畳み可否が可の場合：&lt;br&gt;value&#x3D;\&quot;\&quot;999X999X999CM 999KG FOLDABLE\&quot;\&quot;&lt;br&gt;3.車椅子折り畳み可否が否の場合：&lt;br&gt;value&#x3D;車椅子高さ + \&quot;\&quot;X\&quot;\&quot; + \&quot;\&quot;車椅子横幅 + \&quot;\&quot;X\&quot;\&quot; + 車椅子奥行き + \&quot;\&quot;CM \&quot;\&quot; + 車椅子重量 + \&quot;\&quot;KG UNFOLDABLE\&quot;\&quot; | ASWDB(Tx)から取得した会員情報&lt;br&gt;serviceCatalogue | ログイン済みで、会員情報の車椅子有無の登録があり、車椅子種類が手動の場合、ログイン会員の搭乗者種別と一致する一番最初の搭乗者に対して登録する。 |   | services | 電動車いす(SSRコード(ShortTextのcode)がWCBD/WCBWのサービスとして登録する)&lt;br&gt;※ 搭乗者にリレートする。&lt;br&gt;※ SSRコードからDxAPIのカタログの全セグメント分のサービスIDを特定し、それを指定して登録を行う。&lt;br&gt;parametersとして以下の値を指定することで、SSRのフリーテキストに電動車いす情報を登録する。&lt;br&gt;1.code&#x3D;\&quot;\&quot;TEXT\&quot;\&quot;&lt;br&gt;2.車椅子折り畳み可否が可の場合：&lt;br&gt;value&#x3D;\&quot;\&quot;999X999X999CM 999KG\&quot;\&quot; + \&quot;\&quot; \&quot;\&quot; + バッテリータイプ(※) + \&quot;\&quot; \&quot;\&quot; + \&quot;\&quot;FOLDABLE\&quot;\&quot;&lt;br&gt;3.車椅子折り畳み可否が否の場合：&lt;br&gt;value&#x3D;車椅子高さ + \&quot;\&quot;X\&quot;\&quot; + \&quot;\&quot;車椅子横幅 + \&quot;\&quot;X\&quot;\&quot; + 車椅子奥行き + \&quot;\&quot;CM \&quot;\&quot; + 車椅子重量 + \&quot;\&quot;KG\&quot;\&quot;  + \&quot;\&quot; \&quot;\&quot; + バッテリータイプ(※)  + \&quot;\&quot; \&quot;\&quot; + \&quot;\&quot;UNFOLDABLE\&quot;\&quot;&lt;br&gt;※予約基本情報に登録されたバッテリータイプに合わせ以下を登録する。&lt;br&gt;ニッカドの場合：\&quot;\&quot;NICKEL CADMIUM BATTERY\&quot;\&quot;&lt;br&gt;ニッケル水素の場合：\&quot;\&quot;NICKEL METAL HYBRIDE BATTERY\&quot;\&quot;&lt;br&gt;リチウムイオンの場合：\&quot;\&quot;LITHIUM ION BATTERY\&quot;\&quot;&lt;br&gt;シールドの場合：\&quot;\&quot;SHIELD BATTERY\&quot;\&quot;&lt;br&gt;ノンシールドの場合：\&quot;\&quot;NON SHIELD BATTERY\&quot;\&quot; | ASWDB(Tx)から取得した会員情報&lt;br&gt;serviceCatalogue | ログイン済みで、会員情報の車椅子有無の登録があり、車椅子種類が電動の場合、ログイン会員の搭乗者種別と一致する一番最初の搭乗者に対して登録する。 |   | services | 視覚障がい(SSRコード(ShortTextのcode)がBLNDのサービスとして登録する)&lt;br&gt;※ 搭乗者にリレートする。&lt;br&gt;※ SSRコードからDxAPIのカタログの全セグメント分のサービスIDを特定し、それを指定して登録を行う。 | ASWDB(Tx)から取得した会員情報&lt;br&gt;serviceCatalogue | ログイン済みで、会員情報の視覚障がい有無の登録があり、かつ値が”BLND”の場合、ログイン会員の搭乗者種別と一致する一番最初の搭乗者に対して登録する。 |   | services | 聴覚障がい(SSRコード(ShortTextのcode)がDEAFのサービスとして登録する)&lt;br&gt;※ 搭乗者にリレートする。&lt;br&gt;※ SSRコードからDxAPIのカタログの全セグメント分のサービスIDを特定し、それを指定して登録を行う。 | ASWDB(Tx)から取得した会員情報&lt;br&gt;serviceCatalogue | ログイン済みで、会員情報の聴覚発語障がい有無の登録があり、かつ値が”DEAF”の場合、ログイン会員の搭乗者種別と一致する一番最初の搭乗者に対して登録する。 |   | extensions | キー&#x3D;\&quot;contacts\&quot;に下記JSON形式で格納する。&lt;br&gt;値＝contacts.representative.emails.address: ログインしているAMC会員のプリセット用のメールアドレス | ASWDB(Tx)から取得した会員情報 | ログイン済みかつ大人またはヤングアダルト会員で、更新内容に記載のメールアドレスが存在する場合 |   | extensions | キー&#x3D;\&quot;travelers\&quot;に下記JSON形式で格納する。&lt;br&gt;値＝contacts.emails.address: ログインしているAMC会員のプリセット用のメールアドレス&lt;br&gt;※搭乗者にリレートする。 | ASWDB(Tx)から取得した会員情報 | ログイン済み、かつ大人またはヤングアダルトまたは小児会員で、更新内容に記載のメールアドレスが存在する場合、ログイン会員の搭乗者種別と一致する一番最初の搭乗者に対して登録する。 |   | extensions | キー&#x3D;\&quot;cartCreationDate\&quot; 値&#x3D;現在日時(GMT) | なし | なし |   | extensions | キー&#x3D;\&quot;searchCriteria\&quot;、値はリクエストのsearchAirOfferをそのままJSON形式で登録する。 | リクエストパラメータ | なし |  ## 2. ASWDB(Tx)   | 更新フィールド | 更新内容 | データ取得元 | 条件等 |   | :------------- | :------------- | :------------- | :------------- |   | カートアクセス管理  | カートID | 呼び出し元 | なし |  # 4. 特記事項   ※ DxAPIのswaggerではカート作成時に同時にregulatory情報の登録ができるようなリクエスト項目が定義されているが、同リクエスト項目の動作がサポートされいないため、別リクエストにて登録を行う。(ANAUIUXS2_1A_DEV-361)
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public cartsCreateCartPost(
    generated?: CreateCartRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<CreateCartResponse>;
  public cartsCreateCartPost(
    generated?: CreateCartRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<CreateCartResponse>>;
  public cartsCreateCartPost(
    generated?: CreateCartRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<CreateCartResponse>>;
  public cartsCreateCartPost(
    generated?: CreateCartRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/carts/create-cart`;
    return this.httpClient.request<CreateCartResponse>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要 カートに登録された搭乗者情報の削除を行う。  # 2. 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、HTTPステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; エラー情報には、エラーコードごとにエラー発生項目を含めるようにする。&lt;br/&gt;  1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br/&gt; 有効でない場合、HTTPステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;  1. DxAPIからリクエストパラメータで指定されたカートIDに紐づくカート情報を取得する。取得できない場合、HTTPステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;  1. カート内の搭乗者人数からリクエストパラメータの搭乗者人数を減算し、以下の入力チェックを行う。以下の条件に合致する場合、HTTPステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。   1. 搭乗者人数の確認として、以下のいずれかを満たす。&lt;br/&gt;     1. 大人の搭乗者人数より幼児の搭乗者人数が多い。&lt;br/&gt;     1. 大人の搭乗者人数が0名かつ、小児と幼児の合計人数が1名以上である。&lt;br/&gt;     1. 大人とヤングアダルトの搭乗者合計人数が、0名である。&lt;br/&gt;  1. DxAPIを呼び出し、搭乗者情報の削除を行う。   1. 幼児を削除する場合は、同伴大人に登録済みの幼児サービス情報を削除する。&lt;br/&gt;   1. 指定された搭乗者IDに紐づくカート内の搭乗者情報の削除を行う。&lt;br/&gt;   ※カート更新時、プラン更新日時の更新はしない。&lt;br/&gt;  1. 搭乗者情報更新APIの【最新プラン退避処理】を行う。&lt;br/&gt;  1. 正常終了の場合、HTTPステータスコード204(No Content)を返却し、本処理を終了する。&lt;br/&gt;  # 3. データ更新内容 ## 1. カート   | 更新フィールド | 更新内容 | データ取得元 | 条件等 |   | :------------- | :------------- | :------------- | :------------- |   | travelers | 指定された搭乗者IDに紐づく搭乗者情報の削除 | カート | なし |
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public cartsDeleteTravelerPost(
    generated?: CartsDeleteTravelerRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<CartsDeleteTravelerResponse>;
  public cartsDeleteTravelerPost(
    generated?: CartsDeleteTravelerRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<CartsDeleteTravelerResponse>>;
  public cartsDeleteTravelerPost(
    generated?: CartsDeleteTravelerRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<CartsDeleteTravelerResponse>>;
  public cartsDeleteTravelerPost(
    generated?: CartsDeleteTravelerRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/carts/delete-traveler`;
    return this.httpClient.request<CartsDeleteTravelerResponse>(
      'post',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: generated,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * # 1. 概要&lt;br&gt; 1. リクエスト項目で送信されたカートIDに紐づくカート情報を返却する。   1. 当APIでは、プランシェア用のカート情報を返却するために、シェア用の一時会員番号での取得も可能とする。この場合、一時会員番号を基にプラン情報を取得し、そのプランのカートIDを基に取得を行い、プランのAir Offer(旅程および運賃)の情報のみ返却する。   1. 非会員ユーザのカート操作時は、搭乗者情報をクリアしたカート情報を返却する。一方、同一フローにおける2回目以降のカート取得の場合は、搭乗者情報のクリアを抑制する。また、会員ユーザのカート操作に関しては、同一フローにおける初回操作時、そのカートのプランを作成したAMC会員以外のカート操作を制限する。   これらの制限を実現するために、同一フローにおける初回のカート取得時に、カートを取得したユーザのアクセストークンにカートIDを紐づけてASWDB(Tx)に保持し、2回目以降の取得の場合は、その情報の有無に応じて2回目以降の操作であるかどうかを判定可能とする。   1. マスキング要否を指定可能とする。マスキング要と指定された場合は、搭乗者情報の内、メールアドレス、電話番号、パスポート番号、FFP番号をマスキングして返却する。   1. 登録されているカート情報の最新化要否を指定可能とし、最新化する旨が指定された場合は、DxAPIのカートを最新化する機能を用いて、最新化されたカート情報を取得する。    # 2. 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、エラーハンドリングAPI(G01-010)を利用してMulesoftが生成したエラー情報を解析し、 ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。   1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。 有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。   1.リクエストパラメータに一時会員番号が指定されている場合、以下の処理を行う。     1. 先頭3文字が\&quot;SHR\&quot;(シェアを表す接頭辞)でない、またはリクエストパラメータの一時会員番号とカートIDに紐づくプラン情報がASWDB(Tx)に存在しない場合、HTTPステータスコード400(Bad Request)を返却し、本処理を中止する。     1. 一時会員番号に紐づくプラン情報に紐づくカートIDにて後続の処理を行う。   1. リクエストパラメータに一時会員番号が指定されていない場合、以下の処理を行う。     1. 認可検証APIより返却されたuuidを基に、ASWDB(Tx)からログイン中の会員情報を取得する。     1. 同一フローにおける初回操作の場合、以下の処理を行う。初回操作であるかどうかは、uuidを基にASWDB(Tx)のS2パーソナライズ情報より操作中のカートIDを取得し、リクエストパラメータで指定されたカートIDと同一のIDが存在するかで判断する。       1. ログイン中の会員情報が取得できた場合、操作対象のカートが自分の登録したカートであるか判定するために、ログイン中のAMC会員番号及びカートIDをキーにASWDB(Tx)よりプランを取得する。プランが取得できない場合、カートに対し不正アクセスが行われたとみなしHTTPステータスコード400(Bad Request)を返却する。       1. ログイン中の会員情報が取得できなかった場合、以下の処理を行う。           1. 未ログイン者がAMC会員のカートを不正操作していないかを判定するために、ASWDB(Tx)よりカートIDに紐づくプランを取得する。取得したプランに、一時作成されたプランではなくAMC会員のプランが存在した場合は、カートに対し不正アクセスが行われたとみなしHTTPステータスコード400(Bad Request)を返却する。           1. 搭乗者情報をクリアするため、DxAPIを実行しリクエストパラメータで指定されたカート情報を取得し、搭乗者にリレートされた情報を抽出する。指定されたカート情報が存在しない場合、またはextensionsに論理削除フラグが登録されている場合、カートが削除されているとみなしステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。           1. カートに予約番号が登録されている場合は、prebook削除APIを実行し、prebookPNRを削除する。           1. カートの搭乗者情報をクリアするため、以下の処理を実行する。             1. 連絡先情報リスト、マイレージプログラム情報、パスポート情報を削除し、登録されている搭乗者情報を指定の値に更新する。              1. DxAPIを呼び出し、extensionsに登録されている予約番号、代表者連絡先情報、搭乗者連絡先情報、発着通知連絡先情報からメールアドレスを削除する。             1. DxAPIを呼び出し、搭乗者のサポート情報を削除する。           1. 搭乗者情報更新APIの【最新プラン退避処理】を行う。       1. ASWDB(Tx)のS2パーソナライズ情報へuuidを基に操作中のカートIDを登録する。   1. 各DxAPIを実行し、カート情報を取得する。     1. リクエストパラメータで指定されたカートIDを基に、カートに登録された情報を取得する。取得時に「refresh&#x3D;true」というパラメータを付与することによって最新の情報を取得する。     指定された情報が存在しない場合、またはextensionsに論理削除フラグが登録されている場合、ステータスコード400(Bad Request)を返却し、本処理を中止とする。     1. リクエストパラメータで指定されたカートIDを基に、サービスカタログ情報を取得する。   1. カート情報中の第一セグメントの出発日時まで6時間を切っている場合、発券期限が過ぎているものと判断し、DxAPIを実行し、カートに登録されているAir Offerの削除を行う。   1. 取得したカート情報を、HTTPステータスコード200(OK)と共に返却する。    # 3. データ更新項目 ## 1. カート  ※未ログイン者の搭乗者情報クリア時 | 更新フィールド | 更新内容 | データ取得元 | 条件等 | | :-------- | :--------- | :-------- | :-------- | | contacts | 登録されている項目を削除 | カート | contacts配下の全ての項目について、ID指定で削除する。 | | travelers | 以下の項目を指定された値に更新&lt;br&gt;&lt;ol&gt;&lt;li&gt;敬称: MR&lt;/li&gt;&lt;li&gt;搭乗者姓名&lt;ol&gt;&lt;li&gt;搭乗者名: 設定ファイルより取得した未設定であることを示すダミーの搭乗者名＋アルファベット1文字(AからZへ順となるように設定)&lt;/li&gt;&lt;li&gt;搭乗者ミドルネーム: \&quot;\&quot;(空文字)&lt;/li&gt;&lt;li&gt;搭乗者性: 設定ファイルより取得した搭乗者名初期値&lt;/li&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;搭乗者の生年月日: 空白&lt;/li&gt;&lt;li&gt;性別: \&quot;unspecified\&quot;&lt;/li&gt;&lt;/ol&gt; | カート&lt;br&gt; 設定ファイル | - | | travelers.regulatory-details | パスポート情報を削除 | カート | regulatory-details配下の全ての項目について、ID指定で削除する。 | | frequentFlyerCards | 登録されている項目を削除 | カート | frequentFlyerCards配下の全ての項目について、ID指定で削除する。 | | extensions | キー&#x3D;\&quot;orderId\&quot;、値&#x3D;予約番号のデータを削除 | カート | - | | extensions | キー&#x3D;\&quot;contacts\&quot;、値&#x3D;代表者連絡先情報のデータを削除&lt;br&gt; ※メールアドレスのみ保持 | カート | - | | extensions | キー&#x3D;\&quot;travelers\&quot;、値&#x3D;搭乗者情報のデータを削除&lt;br&gt; ※メールアドレス、発着通知連絡先情報のみ保持 | カート | - | | extensions | 搭乗者情報クリア後のカート情報を、キー&#x3D;\&quot;previousPlan\&quot;、値&#x3D;保存時点カートとして登録 | カート | - | | services | SSRコード(ShortTextのcode)&#x3D;\&quot;WCHR\&quot;のデータを削除&lt;br&gt; ※ DxAPIのserviceId指定で削除 | カート | 更新内容欄に記載の情報が存在し、搭乗者情報のクリアを行う場合、削除を行う。 | | services | SSRコード(ShortTextのcode)&#x3D;\&quot;WCHS\&quot;のデータを削除&lt;br&gt; ※ DxAPIのserviceId指定で削除 | カート | 更新内容欄に記載の情報が存在し、搭乗者情報のクリアを行う場合、削除を行う。 | | services | SSRコード(ShortTextのcode)&#x3D;\&quot;WCHC\&quot;のデータを削除&lt;br&gt; ※ DxAPIのserviceId指定で削除 | カート | 更新内容欄に記載の情報が存在し、搭乗者情報のクリアを行う場合、削除を行う。 | | services | SSRコード(ShortTextのcode)&#x3D;\&quot;WCMP\&quot;のデータを削除&lt;br&gt; ※ DxAPIのserviceId指定で削除 | カート | 更新内容欄に記載の情報が存在し、搭乗者情報のクリアを行う場合、削除を行う。 | | services | SSRコード(ShortTextのcode)&#x3D;\&quot;WCBD\&quot;のデータを削除&lt;br&gt; ※ DxAPIのserviceId指定で削除 | カート | 更新内容欄に記載の情報が存在し、搭乗者情報のクリアを行う場合、削除を行う。 | | services | SSRコード(ShortTextのcode)&#x3D;\&quot;WCBW\&quot;のデータを削除&lt;br&gt; ※ DxAPIのserviceId指定で削除 | カート | 更新内容欄に記載の情報が存在し、搭乗者情報のクリアを行う場合、削除を行う。 | | services | SSRコード(ShortTextのcode)&#x3D;\&quot;BLND\&quot;のデータを削除&lt;br&gt; ※ DxAPIのserviceId指定で削除 | カート | 更新内容欄に記載の情報が存在し、搭乗者情報のクリアを行う場合、削除を行う。 | | services | SSRコード(ShortTextのcode)&#x3D;\&quot;DEAF\&quot;のデータを削除&lt;br&gt; ※ DxAPIのserviceId指定で削除 | カート | 更新内容欄に記載の情報が存在し、搭乗者情報のクリアを行う場合、削除を行う。 |  ## 1. ASWDB(Tx) | 更新テーブル | 更新フィールド | データ取得元 | 条件等 | | :-------- | :--------- | :-------- | :-------- | | S2パーソナライズ | 認可検証APIより取得したuuidを基に、カートIDの登録を行う。 | リクエストパラメータ | - |
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public cartsGetCartPost(
    generated?: PostGetCartRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<PostGetCartResponse>;
  public cartsGetCartPost(
    generated?: PostGetCartRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<PostGetCartResponse>>;
  public cartsGetCartPost(
    generated?: PostGetCartRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<PostGetCartResponse>>;
  public cartsGetCartPost(
    generated?: PostGetCartRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/carts/get-cart`;
    return this.httpClient.request<PostGetCartResponse>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要&lt;br&gt; 1 指定されたAirOfferIDをもとに、DxAPIへ作成済みのカートに対しAirOfferの更新を行う。&lt;br&gt;   　サポート情報の引継を可能とする。&lt;br&gt;   # 2. 処理概要 1 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br&gt; 　 有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。 &lt;br&gt;&lt;br&gt; 2 呼び出し元より渡されたカートIDより、カート取得APIにてカートを取得する。&lt;br&gt; 　 カートが存在しない場合、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。 &lt;br&gt;&lt;br&gt; 3 DxAPIにて、カートのAirOfferを削除する。&lt;br&gt;&lt;br&gt; 4 リクエストパラメータの出発空港の現在時間がリクエストパラメータの出発時刻の6時間前を過ぎている場合、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。 &lt;br&gt;&lt;br&gt; 5 DxAPIにて、リクエストパラメータより取得したAirOfferをカートに追加する。&lt;br&gt; 　5.1  新しいAirOfferが無効のためDxAPIからエラーが返ってきた場合、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。&lt;br&gt; &lt;br&gt; 6 DxAPIにて、AirOffer更新後のカートに対し、削除前に存在していた搭乗者情報に紐づくサポート情報とAirOffer更新時点空席照会条件を追加する(削除前に保持をしておいて追加を行う)。&lt;br&gt;&lt;br&gt; 更新前のカートにサポート情報が登録済かつ以下のいずれかに合致する場合、サポート情報が取り消された旨のワーニングを返却する。&lt;br&gt;   6.1 SSR/SKの登録に失敗&lt;br&gt;   6.2 NHグループ運航以外のセグメントを含む&lt;br&gt;   6.3 第1便まで出発24時間を切っている&lt;br&gt;&lt;br&gt; 7 更新後のAirOfferがTravel Skyキャリア有となった場合は更新前のパスポート情報を登録する。&lt;br&gt;&lt;br&gt; 8 カート取得APIにてカート情報を取得する。&lt;br&gt;&lt;br&gt; 9 サービス情報更新APIの【最新プラン退避処理】を行う。&lt;br&gt;&lt;br&gt; 10 ステータスコード200(正常)としてAirOffer更新後のカート情報を返却する。   # 3. データ更新内容 ## 1. カート | 更新フィールド  | 更新内容                       | データ取得元 | 条件等        | | :-------- | :--------- | :-------- | :-------- | | SSR(BLND)   | AirOffer更新前の内容をそのまま登録&lt;br&gt;※全てのセグメントに対してセグメントリレートする | AirOffer更新前のカート  | 更新後のAirOfferが全便NHグループ運航で、第1便が出発24時間前を切っていない |     | SSR(DEAF)   | AirOffer更新前の内容をそのまま登録&lt;br&gt;※全てのセグメントに対してセグメントリレートする | AirOffer更新前のカート  | 更新後のAirOfferが全便NHグループ運航で、第1便が出発24時間前を切っていない |   | SSR(WCBD)   | AirOffer更新前の内容をそのまま登録&lt;br&gt;※全てのセグメントに対してセグメントリレートする | AirOffer更新前のカート  | 更新後のAirOfferが全便NHグループ運航で、第1便が出発24時間前を切っていない |   | SSR(WCBW)   | AirOffer更新前の内容をそのまま登録&lt;br&gt;※全てのセグメントに対してセグメントリレートする | AirOffer更新前のカート  | 更新後のAirOfferが全便NHグループ運航で、第1便が出発24時間前を切っていない |   | SSR(WCHC)   | AirOffer更新前の内容をそのまま登録&lt;br&gt;※全てのセグメントに対してセグメントリレートする | AirOffer更新前のカート  | 更新後のAirOfferが全便NHグループ運航で、第1便が出発24時間前を切っていない |   | SSR(WCHR)   | AirOffer更新前の内容をそのまま登録&lt;br&gt;※全てのセグメントに対してセグメントリレートする | AirOffer更新前のカート  | 更新後のAirOfferが全便NHグループ運航で、第1便が出発24時間前を切っていない |   | SSR(WCHS)   | AirOffer更新前の内容をそのまま登録&lt;br&gt;※全てのセグメントに対してセグメントリレートする | AirOffer更新前のカート  | 更新後のAirOfferが全便NHグループ運航で、第1便が出発24時間前を切っていない |   | SSR(WCMP)   | AirOffer更新前の内容をそのまま登録&lt;br&gt;※全てのセグメントに対してセグメントリレートする | AirOffer更新前のカート  | 更新後のAirOfferが全便NHグループ運航で、第1便が出発24時間前を切っていない |   | SSR(OTHS)   | AirOffer更新前の内容をそのまま登録&lt;br&gt;※全てのセグメントに対してセグメントリレートする | AirOffer更新前のカート  | 更新後のAirOfferが全便NHグループ運航で、第1便が出発24時間前を切っていない |   | extensions  | キー&#x3D;\&quot;searchAirOffer\&quot;、値はリクエストのsearchAirOfferをそのままJSON形式で登録する。    | リクエストパラメータ    | なし                                                                      |    # 4. エラー一覧 |No|エラー内容|エラーID| |---:|:---|:---| |1|リクエストパラメータのバリデーションチェックにてエラーが発生した場合|| |2|新しいAirOfferを更新できなかった場合|| |3|更新後のAirOfferが全便NHグループ運航で、第1便が出発24時間前を切っている場合、「サポート情報が取り消された」旨のワーニング||  # 5. 特記事項 - なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public cartsUpdateAirOffersPatch(
    generated?: PatchUpdateAirOffersRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<PatchUpdateAirOffersResponse>;
  public cartsUpdateAirOffersPatch(
    generated?: PatchUpdateAirOffersRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<PatchUpdateAirOffersResponse>>;
  public cartsUpdateAirOffersPatch(
    generated?: PatchUpdateAirOffersRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<PatchUpdateAirOffersResponse>>;
  public cartsUpdateAirOffersPatch(
    generated?: PatchUpdateAirOffersRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/carts/update-air-offer`;
    return this.httpClient.request<PatchUpdateAirOffersResponse>(
      'post',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: generated,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * # 1. 概要 DxAPIを呼び出して指定したサービス情報を基にカートへ登録・削除を行う。&lt;br/&gt; ※新規フローにてカートに登録可能なサービスは、事前追加手荷物、有料ラウンジ、機内食のみとする。&lt;br/&gt; ※リクエストパラメータのサービスの指定は、登録可能なサービスに対し1種類のみとする。&lt;br/&gt; ※変更がないサービス情報についてはリクエストパラメータに指定しないものとする。  # 2. 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、HTTPステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; エラー情報には、エラーコードごとにエラー発生項目を含めるようにする。  1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br/&gt; 有効でない場合、HTTPステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。  1. 登録対象のサービスが存在する場合はセグメントの出発日時を取得するため、削除対象のサービスが存在する場合は削除対象のサービスIDを取得するためにDxAPIを呼び出し、指定されたカートIDに紐づくカート情報を取得する。&lt;br/&gt; 取得できない場合、HTTPステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。    1. 登録可能なサービスか否かを判定するためにDxAPIを呼び出し、指定されたカートIDに紐づくカタログ情報を取得する。&lt;br/&gt; カタログ情報が取得できなかった場合、HTTPステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。  1. 登録可能な機内食か否かを判定するため機内食情報取得APIを呼び出す。&lt;br/&gt; 機内食情報取得APIからカタログ情報が取得できなかった場合、HTTPステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。  1. リクエストパラメータに更新区分\&quot;登録\&quot;のサービスが指定されており、各サービスが以下のいずれかに合致する場合、HTTPステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。   1. リクエストパラメータのバウンドID、セグメントID、搭乗者ID、SSRコードのデータがDxAPIより取得したカタログ情報上に存在しない。   1. リクエストパラメータのSSRコードが以下のいずれかに合致する。     1. ASWDB(マスタ)にて事前追加手荷物、またはラウンジに該当するAncillaryサービスとして定義されている場合、以下のいずれかに合致する。        1. セグメントの出発日時が、ASWDB(マスタ)に設定されているサービス受付可能出発前時間を過ぎている。        1. リクエストパラメータのバウンドID、セグメントID、搭乗者ID、SSRコードのデータで取得したカタログ情報上の在庫がない。        1. 事前追加手荷物が指定されている場合、以下のいずれかに合致する。           1. 日本国内区間で不可として設定された運航キャリアのセグメントを含むバウンドである。&lt;br/&gt;           ※運航キャリアについては設定ファイルにて管理する。           1. 米国発着のセグメント、またはカナダ発着のセグメントが存在する。        1. ラウンジが指定されている場合、セグメントIDと搭乗者IDとカタログ情報から取得したサービス情報より、申込不要でラウンジを利用できる搭乗者である。&lt;br/&gt;       ※申し込み不要の判定は取得したサービス情報の金額が0円の場合とする。     1. リクエストパラメータのSSRコードが機内食情報取得APIから取得した機内食情報に特別機内食、事前ミールオーダーのいずれかとして定義されていて、以下のいずれかに合致する。        1. 機内食取得APIより取得した申込期限識別子が申込期限を過ぎている。        1. 指定されている機内食が特別機内食以外の場合、在庫がない。        1. 同一搭乗者IDに機内食が2つ指定されていて、片方が幼児用のミールではない。     1. リクエストパラメータに上記以外のSSRコードが指定されている場合※ASWDB(マスタ)にてAncillaryサービスとして定義されていないとみなす  1. 各DxAPIを呼び出し、サービス申込に関する処理を実施する。   1. カート情報内のサービス情報を確認し、リクエストパラメータに指定されているすべてが以下の内容で一致しているかを確認する。     1. リクエストパラメータのSSRコード：”FBAG”の場合、予約情報の登録済みサービス情報の手荷物情報と一致する。     1. リクエストパラメータのSSRコード：ASWDB(マスタ)にてラウンジに該当するAncillaryサービスとして定義されている場合、予約情報の登録済みサービス情報のラウンジ情報と一致する。     1. リクエストパラメータのSSRコード：上記以外の場合、予約情報の登録済みサービス情報の機内食情報と更新区分：登録のときは一致し、更新区分：削除の時は一致しない。   1. 申込済みサービスがある場合、DXAPIを呼び出して、変更する前の既存サービス、または、リクエストパラメータの更新区分：削除に指定されているサービスの削除を行う。   1.  DxAPIを呼び出して、リクエストパラメータの更新区分：登録に指定されているサービスの登録を行う。   ※カート更新時、プラン更新日時の更新はしない。  1. 搭乗者情報更新APIの【最新プラン退避処理】を行う。  1. 正常終了の場合、HTTPステータスコード201(Created)を返却し、本処理を終了する。  # 3. データ更新内容 ## 1. カート   | 更新フィールド | 更新内容 | データ取得元 | 条件等 |   | :------------- | :------------- | :------------- | :------------- |   | services | ラウンジ情報(SSRコード(ShortTextのcode)がLOUG)のサービスとして登録する。&lt;br/&gt;※搭乗者とセグメントにリレートする。&lt;br/&gt;※登録の場合はカタログ情報から取得したserviceID、削除の場合はカートに登録されているserviceIDを指定する。 | 指定した項目 | ラウンジ情報の登録有無が指定された場合。&lt;br/&gt;ラウンジ情報の更新区分の指定、登録状況に応じて、以下の処理を行う。&lt;br/&gt;&lt;ol&gt;&lt;li&gt;更新区分\&quot;登録\&quot;で未登録の場合、登録&lt;/li&gt;&lt;li&gt;更新区分\&quot;削除\&quot;で未登録の場合、処理を行わない&lt;/li&gt;&lt;li&gt;更新区分\&quot;登録\&quot;で登録済みの場合、既存を削除、指定したSSRコードを登録&lt;/li&gt;&lt;li&gt;更新区分\&quot;削除\&quot;で登録済みの場合、削除&lt;/li&gt;&lt;/ol&gt; |   | services | 事前追加手荷物情報(SSRコード(ShortTextのcode)がFBAG)のサービスとして登録する。&lt;br/&gt;※搭乗者とセグメントにリレートする。&lt;br/&gt;※登録の場合はカタログ情報から取得したserviceID、削除の場合はカートに登録されているserviceIDを指定する。 | 指定した項目 | 事前追加手荷物情報の登録有無が指定された場合。&lt;br/&gt;事前追加手荷物情報の更新区分の指定、登録状況に応じて、以下の処理を行う。&lt;br/&gt;&lt;ol&gt;&lt;li&gt;更新区分\&quot;登録\&quot;で未登録の場合、登録&lt;/li&gt;&lt;li&gt;更新区分\&quot;削除\&quot;で未登録の場合、処理を行わない&lt;/li&gt;&lt;li&gt;更新区分\&quot;登録\&quot;で登録済みの場合、既存を削除、指定したSSRコードを登録&lt;/li&gt;&lt;li&gt;更新区分\&quot;削除\&quot;で登録済みの場合、削除&lt;/li&gt;&lt;/ol&gt; |   | services | 機内食情報(SSRコード(ShortTextのcode)がメニュー毎のSSRコード)のサービスとして登録する。&lt;br/&gt;※搭乗者とセグメントにリレートする。&lt;br/&gt;※登録の場合はカタログ情報から取得したserviceID、削除の場合はカートに登録されているserviceIDを指定する。 | 指定した項目 | 機内食情報の登録有無が指定された場合。&lt;br/&gt;機内食情報の更新区分の指定、登録状況に応じて、以下の処理を行う。&lt;br/&gt;&lt;ol&gt;&lt;li&gt;更新区分\&quot;登録\&quot;で未登録の場合、登録&lt;/li&gt;&lt;li&gt;更新区分\&quot;削除\&quot;で未登録の場合、処理を行わない&lt;/li&gt;&lt;li&gt;更新区分\&quot;登録\&quot;で登録済みの場合、既存を削除、指定したSSRコードを登録&lt;/li&gt;&lt;li&gt;更新区分\&quot;削除\&quot;で登録済みの場合、削除&lt;/li&gt;&lt;/ol&gt; |
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public cartsUpdateServicesPost(
    generated?: CartsUpdateServicesRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<CartsUpdateServicesResponse>;
  public cartsUpdateServicesPost(
    generated?: CartsUpdateServicesRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<CartsUpdateServicesResponse>>;
  public cartsUpdateServicesPost(
    generated?: CartsUpdateServicesRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<CartsUpdateServicesResponse>>;
  public cartsUpdateServicesPost(
    generated?: CartsUpdateServicesRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/carts/update-services`;
    return this.httpClient.request<CartsUpdateServicesResponse>(
      'post',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: generated,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * # 1. 概要 指定された搭乗者情報を基に、カートに登録された搭乗者情報の更新を行う。&lt;br/&gt; 代表者の連絡先情報、搭乗者毎の情報の更新を可能とする。  # 2. 処理概要 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、HTTPステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; エラー情報には、エラーコードごとにエラー発生項目を含めるようにする。&lt;br/&gt;  1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br/&gt; 有効でない場合、HTTPステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。  1. ~~代表者メールアドレス、搭乗者メールアドレス、発着通知連絡先メールアドレスについて、共通部品「入力値変換・入力チェック」(G03-501)の結果がフォーマット不正の場合、HTTPステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。~~  1. 代表者電話情報、搭乗者電話情報について、~~以下条件のいずれかに合致する場合、~~&lt;span style&#x3D;\&quot;color: red\&quot;&gt;共通部品「入力値変換・入力チェック」(G03-501)の結果がfalseの場合、&lt;/span&gt;HTTPステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。   1. ~~国番号が日本で、電話番号が9～11桁でない。&lt;br/&gt;~~   1. ~~国番号が日本以外の国で、国番号に紐づく国番号+電話番号が9桁以上でない。~~  1. DxAPIからリクエストパラメータで指定されたカートIDに紐づくカート情報を取得する。取得できない場合、HTTPステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。  1. 以下の項目について、日付有効範囲外の場合、HTTPステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。   1. 生年月日&lt;br/&gt;      日付有効範囲は以下とし、年齢の基準日を旅程内の第一便出発日として計算を行う。&lt;br/&gt;     1. 大人：16歳から99歳&lt;br/&gt;     1. ヤングアダルト：12歳から15歳&lt;br/&gt;     1. 小児：2歳から11歳(POSが日本以外かつ日本国内旅程の場合は3歳から11歳)&lt;br/&gt;     1. 幼児：生後8日から1歳  1. リクエストで受け取ったパラメータを基に、各搭乗者の入力チェックを行う。以下の条件のいずれかに合致する場合、HTTPステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;   1. 名、ミドルネームの合計文字数が26文字以上である。&lt;br/&gt;   1. 姓、名、ミドルネームの合計文字数が49文字以上である。&lt;br/&gt;   1. リクエストパラメータに搭乗者情報リストtravelers構造が存在するかつ、販売キャリアないしは運航キャリアとして、設定ファイルに定めたTravelSkyキャリアを含まないが、リクエストパラメータのパスポート番号に値が設定されている。&lt;br/&gt;   1. 幼児不可認識の確認として、以下~~全て~~&lt;span style&#x3D;\&quot;color: red\&quot;&gt;のいずれか&lt;/span&gt;を満たす。&lt;br/&gt;     1. 旅程に含まれる各フライトの出発日までに誕生日が訪れて、小児となる幼児が存在することを許可しない他社キャリアが、旅程中にNHグループ（NH、NQ）便名の運航キャリアとして含まれている。&lt;br/&gt;     ※小児となる幼児が存在することを許可しない他社キャリアはASWDB(マスタ)から取得する。&lt;br/&gt;     1. NHグループ便名でない。&lt;br/&gt;   1.マイレージプログラムがAMC、かつ以下のいずれかに一致する。&lt;br/&gt;     1. マイル積算用FFP会員番号が10桁の数字でない。&lt;br/&gt;     1. マイル積算用FFP会員番号が上9桁の数字を7で割った余りに1を足した値が、下1桁と一致しない。&lt;br/&gt;     1. マイル積算用FFP会員番号をもとにMindsからAMC会員情報が取得できない、または、搭乗者姓名が取得したAMC会員情報の搭乗者姓名と一致しない。&lt;br/&gt;   1. マイレージプログラムがAMC以外の場合、マイル積算用FFP会員番号が16桁以下の英数字でない。&lt;br/&gt;   1. マイレージプログラムがAMC以外である。&lt;br/&gt;   1. 車いす種別が電動の場合、バッテリータイプが入力されていない。&lt;br/&gt;   1. 車いす折りたたみが不可の場合、以下のいずれかが入力されていない。&lt;br/&gt;     1. 車いすサイズ（奥行）&lt;br/&gt;     1. 車いすサイズ（横幅）&lt;br/&gt;     1. 車いすサイズ（高さ）&lt;br/&gt;     1. 車いすサイズ（重さ）&lt;br/&gt;   1. 発着通知連絡先情報リストの送信言語がASWDB(マスタ)に言語コード(メール)として登録されていない。&lt;br/&gt;   1.代表者連絡先情報と搭乗者情報の国番号がASWDB(マスタ)に連絡国番号として登録されていない。&lt;br/&gt;  1. リクエストで受け取ったパラメータとカートに登録済みの搭乗者情報を基に、各搭乗者情報の相関チェックを行う。&lt;br/&gt; 以下の条件のいずれかに合致する場合、HTTPステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;   1. 姓、名、生年月日、性別の組み合わせが完全に同じである搭乗者情報が複数存在する。&lt;br/&gt;   1. 旅程に含まれる各フライトについて、運航キャリアが他社で、ASWDB(マスタ)で管理しているキャリア情報に単独搭乗制限年齢の設定があるキャリアの場合、当該フライトの出発日(出発地のローカル時刻)時点の搭乗者の年齢について、キャリアの単独搭乗制限年齢より大きい搭乗者が1人でも存在しない。&lt;br/&gt;   1. マイレージプログラムとマイル積算用FFP会員番号が完全に同じである搭乗者情報が複数存在する。&lt;br/&gt;  1. 各DxAPIを呼び出し、以下処理を行う。   1. 未登録の代表者電話情報、滞在中の連絡先情報、搭乗者電話情報のいずれかの指定がある場合、DxAPIを呼び出し、カート内の連絡先情報の登録を行う。&lt;br/&gt;   1. 登録済み代表者電話情報、滞在中の連絡先情報、搭乗者電話情報のいずれかに変更がある場合、DxAPIを呼び出し、カート内の連絡先情報の更新を行う。&lt;br/&gt;   1. 滞在中の連絡先情報の削除がある場合、DxAPIを呼び出し、カート内の連絡先情報の削除を行う。&lt;br/&gt;   1. 搭乗者情報の指定がある場合、DxAPIを呼び出し、カート内の搭乗者情報の更新を行う。&lt;br/&gt;   1. 未登録のマイレージ情報の指定がある場合、DxAPIを呼び出し、カート内のマイレージ情報の登録を行う。&lt;br/&gt;   1. 登録済みのマイレージ情報の変更がある場合、DxAPIを呼び出し、カート内のマイレージ情報の更新を行う。&lt;br/&gt;   1. 登録済みのマイレージ情報の削除がある場合、DxAPIを呼び出し、カート内のマイレージ情報の削除を行う。&lt;br/&gt;   1. 登録済みのサポート情報の削除がある場合、DxAPIを呼び出し、サポート情報の削除を行う。&lt;br/&gt;   1. 未登録のサポート情報の指定がある場合、以下の処理を行う。&lt;br/&gt;     1. DxAPIを呼び出し、カートIDに紐づくカタログ情報を取得する。カタログ情報が取得できなかった場合、HTTPステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;     1. 上記カタログ情報を基に、サポート情報の登録を行う。&lt;br/&gt;   1. 未登録の代表者メールアドレス、搭乗者メールアドレス、発着通知連絡先情報リストのいずれかの指定がある場合、DxAPIを呼び出し、extensions情報の登録を行う。&lt;br/&gt;   1. 登録済みの代表者メールアドレス、搭乗者メールアドレス、発着通知連絡先情報リストのいずれかに変更がある場合、DxAPIを呼び出し、extensions情報の更新を行う。&lt;br/&gt; ※詳細はデータ更新内容の条件を参照&lt;br/&gt; ※カート更新時、プラン更新日時の更新はしない。&lt;br/&gt;  1. カートリフレッシュ後の差分比較のため、カート取得API(eAPI)から取得したプランを用いて、DxAPIを呼び出して最新のプラン情報をextensionsにコピーする。【最新プラン退避処理】&lt;br/&gt;  1. 正常終了の場合、HTTPステータスコード201(Created)を返却し、本処理を終了する。&lt;br/&gt;  # 3. データ更新内容 ## 1. カート | 更新フィールド | 更新内容 | データ取得元 | 条件等 | | :------------- | :------------- | :------------- | :------------- | | contacs | 代表者連絡先情報(携帯：category&#x3D;personal、purpose&#x3D;standard、device&#x3D;mobile　自宅：category&#x3D;personal、purpose&#x3D;standard、device&#x3D;landline　勤務先：category&#x3D;business、purpose&#x3D;standardとして登録する)&lt;br/&gt;&lt;ol&gt;&lt;li&gt;国番号&lt;/li&gt;&lt;li&gt;電話番号&lt;/li&gt;&lt;/ol&gt; | 指定した情報 | 代表者電話情報の指定有無と登録状況に応じて、以下の処理を行う。&lt;br/&gt;&lt;ol&gt;&lt;li&gt;指定ありで未登録の場合、登録&lt;/li&gt;&lt;li&gt;指定ありで登録済みの場合、更新&lt;/li&gt;&lt;/ol&gt; | | contacs | 滞在中の連絡先情報(category&#x3D;XXX, contactType&#x3D;XXXとして登録する) | 指定した情報 | 滞在先の連絡先情報について、指定有無と登録状況に応じて以下の処理を行う。&lt;br/&gt;&lt;ol&gt;&lt;li&gt;指定が1件以上で、登録が0件の場合、すべて登録&lt;/li&gt;&lt;li&gt;指定が0件で、登録が1件以上の場合、すべて削除&lt;/li&gt;&lt;li&gt;指定と登録の件数が同じで、ともに1件以上の場合、すべて更新&lt;/li&gt;&lt;li&gt;指定が2件で、登録が1件の場合、1件目を更新し、2件目を登録&lt;/li&gt;&lt;li&gt;指定が1件で、登録が2件の場合、1件目を更新し、2件目を削除&lt;/li&gt;&lt;/ol&gt; | | contacs | 搭乗者電話情報(category&#x3D;personal, contactType&#x3D;Phone,purpose&#x3D;notificationとして登録する)&lt;br/&gt;&lt;ol&gt;&lt;li&gt;国番号&lt;/li&gt;&lt;li&gt;電話番号&lt;/li&gt;&lt;li&gt;言語コード&lt;/li&gt;&lt;/ol&gt;※ 搭乗者にリレートする。 | 指定した情報 | 搭乗者数分登録する。&lt;br/&gt;搭乗者電話情報の指定有無と登録状況に応じて、以下の処理を行う。&lt;br/&gt;&lt;ol&gt;&lt;li&gt;指定ありで未登録の場合、登録&lt;/li&gt;&lt;li&gt;指定ありで登録済みの場合、更新&lt;/li&gt;&lt;/ol&gt; | | travelers | &lt;ol&gt;&lt;li&gt;敬称&lt;/li&gt;※未指定、および非表示の場合は性別と旅客種別に応じた敬称を登録する。&lt;ul&gt;&lt;li&gt;男性、大人またはヤングアダルト：MR&lt;/li&gt;&lt;li&gt;男性、小児または幼児：MSTR&lt;/li&gt;&lt;li&gt;女性、大人またはヤングアダルト：MS&lt;/li&gt;&lt;li&gt;女性、小児または幼児：MISS&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;搭乗者姓名&lt;/li&gt;&lt;ol&gt;&lt;li&gt;搭乗者名＋半角スペース＋搭乗者ミドルネーム&lt;br/&gt;※半角スペース＋搭乗者ミドルネームはリクエストミドルネームがリクエストされた場合のみ登録する。&lt;/li&gt;&lt;li&gt;搭乗者姓&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;生年月日&lt;/li&gt;&lt;li&gt;性別&lt;/li&gt;&lt;/ol&gt; | 指定した情報 | 搭乗者数分登録する。&lt;br/&gt;搭乗者情報の指定有無に応じて、以下の処理を行う。&lt;br/&gt;&lt;ol&gt;&lt;li&gt;指定ありの場合、更新&lt;/li&gt;&lt;/ol&gt; | | travelers.regulatory-details | パスポート情報(regulatoryApisType&#x3D;ApisDetailRegulatoryDocument、documentType&#x3D;passportとして登録する)&lt;ol&gt;&lt;li&gt;搭乗者姓名&lt;/li&gt;&lt;ol&gt;&lt;li&gt;搭乗者名&lt;/li&gt;&lt;li&gt;搭乗者ミドルネーム&lt;/li&gt;&lt;li&gt;搭乗者姓&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;生年月日&lt;/li&gt;&lt;li&gt;性別&lt;/li&gt;&lt;li&gt;パスポート番号(指定された場合のみ)&lt;/li&gt;&lt;/ol&gt;※搭乗者にリレートする。 | 指定した情報 | 搭乗者数分登録する。&lt;br/&gt;搭乗者情報とパスポート情報の指定有無に応じて、以下の処理を行う。&lt;br/&gt;&lt;ol&gt;&lt;li&gt;指定ありの場合、更新&lt;/li&gt;&lt;/ol&gt; | | frequentFlyerCards&lt;br/&gt;※SSR FQTVおよびFQTS兼用の項目 | マイル積算用FFP会員番号&lt;ol&gt;&lt;li&gt;マイレージプログラム&lt;/li&gt;&lt;li&gt;FFP番号&lt;/li&gt;&lt;/ol&gt;※搭乗者にリレートする。 | 指定した情報 | マイレージプログラム情報リストの指定有無と登録状況に応じて、以下の処理を行う。&lt;br/&gt;&lt;ol&gt;&lt;li&gt;指定ありで未登録の場合、登録&lt;/li&gt;&lt;li&gt;指定ありで登録済みの場合、更新&lt;/li&gt;&lt;li&gt;指定なしで登録済みの場合、削除&lt;/li&gt;&lt;/ol&gt; | | services | 歩行程度(SSRコード(ShortTextのcode)がWCHR/WCHS/WCHCのサービスとして登録する)&lt;br/&gt;※搭乗者にリレートする。&lt;br/&gt;※SSRコードからDxAPIのカタログの全セグメント分のサービスIDを特定し、そのサービスIDを指定して登録/更新/削除を行う。 | 指定した情報&lt;br/&gt;serviceCatalogue | 歩行程度が指定された場合。&lt;br/&gt;歩行程度の指定有無と登録状況に応じて、以下の処理を行う。&lt;br/&gt;&lt;ol&gt;&lt;li&gt;指定ありで未登録の場合、登録&lt;/li&gt;&lt;li&gt;指定ありで登録済みの場合かつ既存を削除、指定したSSRコードを登録&lt;/li&gt;&lt;li&gt;指定なしで登録済みの場合、削除&lt;/li&gt;&lt;/ol&gt; | | services | 手動車いす(SSRコード(ShortTextのcode)がWCMPのサービスとして登録する)&lt;br/&gt;※搭乗者にリレートする。&lt;br/&gt;※SSRコードからDxAPIのカタログの全セグメント分のサービスIDを特定し、そのサービスIDを指定して登録/更新/削除を行う。&lt;br/&gt;SSRフリーテキスト(parameters.code&#x3D;TEXTとして登録する)&lt;br/&gt;折り畳み式ではない場合：高さ + \&quot;×\&quot; + 横幅 + \&quot;×\&quot; + 奥行 + \&quot;CM\&quot;+半角スペース＋重さ + \&quot;KG\&quot;+半角スペース＋UNFOLDABLE&lt;br/&gt;折り畳み式の場合：\&quot;999×999×999CM\&quot;＋半角スペース＋\&quot;999KG\&quot;＋半角スペース＋FOLDABLE | 指定した情報&lt;br/&gt;serviceCatalogue | 車いす情報が指定された場合。&lt;br/&gt;手動車いす、電動車いすの指定有無と登録状況に応じて、以下の処理を行う。&lt;br/&gt;&lt;ol&gt;&lt;li&gt;指定ありで未登録の場合、登録&lt;/li&gt;&lt;li&gt;指定ありで登録済みの場合、既存を削除、指定したSSRコードを登録&lt;/li&gt;&lt;li&gt;指定なしで登録済みの場合、削除&lt;/li&gt;&lt;/ol&gt; | | services | 電動車いす(SSRコード(ShortTextのcode)がWCBD/WCBWのサービスとして登録する)&lt;br/&gt;※搭乗者にリレートする。&lt;br/&gt;※SSRコードからDxAPIのカタログの全セグメント分のサービスIDを特定し、そのサービスIDを指定して登録/更新/削除を行う。&lt;br/&gt;SSRフリーテキスト(parameters.code&#x3D;TEXTとして登録する)&lt;br/&gt;折り畳み式ではない場合：高さ + \&quot;×\&quot; + 横幅 + \&quot;×\&quot; + 奥行 + \&quot;CM\&quot;+半角スペース＋重さ + \&quot;KG\&quot;+半角スペース＋UNFOLDABLE+半角スペース＋※バッテリータイプ&lt;br/&gt;折り畳み式の場合：\&quot;999×999×999CM\&quot;＋半角スペース＋\&quot;999KG\&quot;＋半角スペース＋FOLDABLE+半角スペース＋※バッテリータイプ&lt;br/&gt;※バッテリータイプは以下参照&lt;br/&gt;nickelCadmiumの場合：NICKEL CADMIUM BATTERY&lt;br/&gt;nickelMetalHydrideの場合：NICKEL METAL HYBRIDE BATTERY&lt;br/&gt;lithiumIonの場合：LITHIUM ION BATTERY&lt;br/&gt;nonSpillableBatteryの場合：SHIELD BATTERY&lt;br/&gt;spillableBatteryの場合：NON SHIELD BATTERY | 指定した情報&lt;br/&gt;serviceCatalogue | 車いす情報が指定された場合。&lt;br/&gt;手動車いす、電動車いすの指定有無と登録状況に応じて、以下の処理を行う。&lt;br/&gt;&lt;ol&gt;&lt;li&gt;指定ありで未登録の場合、登録&lt;/li&gt;&lt;li&gt;指定ありで登録済みの場合、既存を削除、指定したSSRコードを登録&lt;/li&gt;&lt;li&gt;指定なしで登録済みの場合、削除&lt;/li&gt;&lt;/ol&gt; | | services | 視覚障がい(SSRコード(ShortTextのcode)がBLNDのサービスとして登録する)&lt;br/&gt;※搭乗者にリレートする。&lt;br/&gt;※SSRコードからDxAPIのカタログの全セグメント分のサービスIDを特定し、そのサービスIDを指定して登録/削除を行う。 | 指定した情報&lt;br/&gt;serviceCatalogue | 視覚障がいの登録有無が指定された場合。&lt;br/&gt;覚障がいの指定有無と登録状況に応じて、以下の処理を行う。&lt;br/&gt;&lt;ol&gt;&lt;li&gt;指定ありで未登録の場合、登録&lt;/li&gt;&lt;li&gt;指定ありで登録済みの場合、処理を行わない&lt;/li&gt;&lt;li&gt;指定なしで登録済みの場合、削除&lt;/li&gt;&lt;/ol&gt; | | services | 聴覚障がい(SSRコード(ShortTextのcode)がDEAFのサービスとして登録する)&lt;br/&gt;※搭乗者にリレートする。&lt;br/&gt;※SSRコードからDxAPIのカタログの全セグメント分のサービスIDを特定し、そのサービスIDを指定して登録/削除を行う。 | 指定した情報&lt;br/&gt;serviceCatalogue | 聴覚障害の登録有無が指定された場合。&lt;br/&gt;聴覚障がいの指定有無と登録状況に応じて、以下の処理を行う。&lt;ol&gt;&lt;li&gt;指定ありで未登録の場合、登録&lt;/li&gt;&lt;li&gt;指定ありで登録済みの場合、処理を行わない&lt;/li&gt;&lt;li&gt;指定なしで登録済みの場合、削除&lt;/li&gt;&lt;/ol&gt; | | extensions | キー&#x3D;\&quot;contacts\&quot;、値は下記JSON形式で格納する。&lt;br/&gt;値&#x3D;{representative:{email:{address:代表者メールアドレス}}} | 指定した情報 | 代表者メールアドレス情報が指定された場合。&lt;br/&gt;代表者メールアドレス情報の指定有無と登録状況に応じて、以下の処理を行う。&lt;ol&gt;&lt;li&gt;指定ありで未登録の場合、登録&lt;/li&gt;&lt;li&gt;指定ありで登録済みの場合、更新&lt;/li&gt;&lt;/ol&gt; | | extensions | キー&#x3D;\&quot;travelers\&quot;、値は下記JSON形式で格納する。&lt;br/&gt;値&#x3D;{email:{address:搭乗者メールアドレス},departureArrivalNotifications:{email:{address:発着通知連絡先メールアドレス,},recipient:発着通知連絡先メール受信者名,lang:発着通知連絡先送信言語}}&lt;br/&gt;※搭乗者にリレートする。 | 指定した情報 | 搭乗者メールアドレス情報、発着通知連絡先情報リストが指定された場合。&lt;br/&gt;搭乗者メールアドレス情報の指定有無と登録状況に応じて、以下の処理を行う。&lt;ol&gt;&lt;li&gt;指定ありで未登録の場合、登録&lt;/li&gt;&lt;li&gt;指定ありで登録済みの場合、更新&lt;/li&gt;&lt;/ol&gt;発着通知連絡先情報リストの指定有無と登録状況に応じて、以下の処理を行う。&lt;ol&gt;&lt;li&gt;指定ありで未登録の場合、登録&lt;/li&gt;&lt;li&gt;指定ありで登録済みの場合、更新&lt;/li&gt;&lt;li&gt;指定なしで登録済みの場合、削除&lt;/li&gt;&lt;/ol&gt; | | extensions | キー&#x3D;\&quot;isTravelersInput\&quot;、値&#x3D;搭乗者情報登録識別子 | なし | なし |  ※プラン退避の構造はカート取得APIのレスポンスを参照
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public cartsUpdateTravelersPatch(
    generated?: CartsUpdateTravelersRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<CartsUpdateTravelersResponse>;
  public cartsUpdateTravelersPatch(
    generated?: CartsUpdateTravelersRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<CartsUpdateTravelersResponse>>;
  public cartsUpdateTravelersPatch(
    generated?: CartsUpdateTravelersRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<CartsUpdateTravelersResponse>>;
  public cartsUpdateTravelersPatch(
    generated?: CartsUpdateTravelersRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/carts/update-travelers`;
    return this.httpClient.request<CartsUpdateTravelersResponse>(
      'patch',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: generated,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * ペットらくのりAPI
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public cartsUpdatePetRakunoriPost(
    generated?: CartsUpdatePetRakunoriRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<CartsUpdatePetRakunoriResponse>;
  public cartsUpdatePetRakunoriPost(
    generated?: CartsUpdatePetRakunoriRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<CartsUpdatePetRakunoriResponse>>;
  public cartsUpdatePetRakunoriPost(
    generated?: CartsUpdatePetRakunoriRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<CartsUpdatePetRakunoriResponse>>;
  public cartsUpdatePetRakunoriPost(
    generated?: CartsUpdatePetRakunoriRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/carts/update-pet-rakunori`;
    return this.httpClient.request<CartsUpdatePetRakunoriResponse>(
      'post',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: generated,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * # 1. 概要   prebook PNRを作成する為、リクエストから受け取ったカートIDからprebook PNRの作成を行う。   prebook PNRの作成後、プランをprebook済みに変更し、予約番号をプランに登録する。   非会員で別端末にて同一プランを操作する場合、操作した端末のみでprebookを有効にさせる。そのため、prebook済みの同一プランに対して再度prebookを試行した場合は、別端末でprebookしていた可能性を考慮し、  前のprebook済みPNRを破棄し、再度prebookを行うものとする。   (同一端末からの再prebookや、会員のプランの再prebook時も再prebookを行ってしまうが、そのような使われ方は想定しない前提とし、再prebookされてしまって問題なしとする)     # 2. 処理内容   1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、エラーハンドリング(API)(G01-010)を利用してMulesoftが生成したエラー情報を解析し、 ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。   1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。有効でない場合、HTTPステータスコード 401(unauthorized)を返して、本処理を中止とする。    1. リクエストで受け取ったカートIDを基に、カート情報の取得を行う。   カートが取得できなかった、またはカートのextensionsに論理削除識別子が登録されている場合、HTTPステータスコード400(Bad Request)を返却し、本処理を中止する。   1. prebookに際して、現在日時が、第一便の出発時刻の6時間前を過ぎている場合、HTTPステータスコード400(Bad request)を返却し、本処理を中止する。    1. 代表者連絡先情報、搭乗者情報について、以下のいずれかに該当する場合、HTTPステータスコード400(Bad Request)を返却し、本処理を中止する。      1. カートに代表者連絡先電話番号、代表者連絡先メールアドレスが登録されていない。     1. カートに登録されている各搭乗者情報の内、以下のいずれかが入力されていない。       1. 姓       1. 名       1. 性別       1. 生年月日       1. 搭乗者連絡先メールアドレス  ※幼児を除く   1. カートに登録されている各搭乗者情報の生年月日に関して、第一便出発日時点の年齢が、以下に該当しない場合、HTTPステータスコード400(Bad Request)を返却し、本処理を中止する。     1. 大人：16歳から99歳     1. ヤングアダルト：12歳から15歳     1. 小児：2歳から11歳(操作オフィスのPOSが日本以外かつ日本国内単独旅程の場合は3歳から11歳)     1. 幼児：生後8日から1歳   1. 幼児不可認識の確認として、旅程に含まれる各セグメントの出発日までに誕生日が訪れて、小児となる幼児が存在する、かつ以下のいずれかを満たす場合、HTTPステータスコード400(Bad Request)を返却し、本処理を中止する。      1. 小児となる幼児が存在することを許可しない他社キャリアが、旅程中にNHグループ（NH、NQ）便名の運航キャリアとして含まれている      ※小児となる幼児が存在することを許可しない他社キャリアはASWDB(マスタ)から取得する     1. NHグループ便名でない   1. 旅程に含まれる各セグメントについて、運航キャリアにASWDB(マスタ)にて管理している単独搭乗制限年齢の設定があり、全ての搭乗者の年齢（当該セグメントの現地出発日時点）が単独搭乗制限年齢以下となるセグメントが存在する場合、HTTPステータスコード400(Bad Request)を返却し、本処理を中止する。   1. カート情報に、搭乗者サポート情報、もしくは機内食情報、もしくはラウンジ情報が登録されており、かつ、現在日時が、第一便の出発時刻の24時間前を過ぎている場合、サービスの登録が失敗したエラーとして、HTTPステータスコード400(Bad Request)を返却し、本処理を中止する。    1. リクエストで受け取ったカートIDのextensionsに予約番号が登録されている場合は、prebook削除APIを実行する。(予約削除処理)   prebook削除に失敗した場合、HTTPステータスコード500(サーバエラー)を返却し、本処理を中止する。   1. リクエストより受け取ったカートIDを基に、DxAPIを実行しprebook PNRの作成を行う。   ※代表者連絡先電話番号は以降の処理でAltea Web Serviceを用いてAPエレメントのフリーテキストに登録するが、prebook PNRを作成する為には代表者連絡先電話番号は必須である為、カートに登録されている代表者連絡先電話番号を登録する。   1. prebook PNRが作成できなかったエラーが返却された場合、以下の処理を行う。     1. サービスの登録失敗エラーが返却され、カートに有料ラウンジが含まれている、かつ有料ラウンジを申し込んでいる搭乗者のFFP情報が、ラウンジを無料で利用できる会員(※)の場合、以下の処理を行う。     ※Tierレベルが、ダイヤモンド、プラチナ、SFC、Star Alliance Goldのいずれかである会員       1. 登録失敗したサービスを、そのサービスIDをキーに、DxAPIを呼び出し、カートから削除する。       1. ラウンジが無料になったエラーとして、HTTPステータスコード400(Bad Request)を返却し、本処理を中止する。     1. 上記以外でサービスの登録失敗エラーが返却された場合、サービスの登録が失敗したエラーとして、HTTPステータスコード400(Bad Request)を返却し、本処理を中止する。     1. 上記以外の場合、prebook PNR作成失敗エラーとして、HTTPステータスコード400(Bad Request)を返却し、本処理を中止する。 1. 以下のワーニングが返却された場合、作成されたprebook PNRの削除を行い、HTTPステータスコード400(Bad Request)を返却し、本処理を中止する。    1. FQTVの登録に失敗     1. スケジュール変更が発生     1. スケジュール変更の発生によるMCTエラー(カボタージュエラーを含む)   1. DxAPIにて作成されたPNRのAPEエレメントに対して、カートのextensionsに登録されている代表者メールアドレスをDxAPIを呼び出し登録する。   作成したPNRへ登録ができなかった場合、作成されたprebook PNRの削除を行い、HTTPステータスコード400(Bad Request)を返却し、処理を中断する。 1. DxAPIにて作成されたPNRに対し、Altea Web Serviceを用いてAPエレメントに代表者連絡先電話番号のフリーテキストの登録を行う為、一度作成されたAPエレメントの削除を行い、再度カートに登録されている代表者連絡先電話番号を用いて登録を行う。    APエレメントの削除ができなかった、又はAPエレメントの登録できなかった場合、HTTPステータスコード500(Internal Server Error)を返却し、処理を中断する。   1. DxAPIを呼び出し、カートのextensionsに、prebook PNR作成時に返却されたprebook有効期限、予約番号、第一搭乗者姓を登録する。   1. 呼び出し元より渡されたアクセストークンを復号し、トークン内に含まれるuuidを基に、ASWDB(Tx)からパーソナライズ情報を取得する。   1. パーソナライズ情報にAMC会員番号が設定されている場合、AMC会員番号、リクエストパラメータのカートIDをキーにASWDB(Tx)よりプランの取得を行う。 プランの取得有無により、ASWDB(Tx)のプランに以下の内容にて、更新または登録を行う。     1. プランの取得が出来た場合、該当プランのprebook有効期限、prebook済みであるかどうかを、それぞれprebook PNR作成時に返却されたprebook有効期限、trueに更新する。      1. プランの取得が出来なかった場合、当該AMC会員のprebook済みプランとしてASWDB(Tx)に保持する為、新たにプランを登録する。※登録内容は、更新テーブルのプラン参照。   1. HTTPステータスコード201(Created)と共に返却し、処理を終了する。    # 3. データ更新項目   1. PNR   | 更新フィールド | 更新内容 | データ取得元 | 条件等 | | :------ | :------ | :------ | :------ | | SEG | DxAPIのOrder作成機能に準じて作られる | リクエストパラメータのカートIDにおけるカート情報 | - | | NAME | DxAPIのOrder作成機能に準じて作られる &lt;br&gt;氏名として、以下のフォーマットで登録される。 &lt;br&gt;搭乗者姓 + \&quot;/\&quot; + 搭乗者名 + 搭乗者ミドルネーム + \&quot; \&quot; + 敬称 &lt;br&gt;また、搭乗者種別が小児もしくは幼児の場合、搭乗者種別に加え生年月日が登録される。 | リクエストパラメータのカートIDにおけるカート情報 | - | | APE | クレジット決済時のFraudチェック用メールアドレスとして、カートのextensionsの代表者メールアドレスを登録する(contactsに対してpurposeは未指定、category&#x3D;personalで登録する)&lt;br&gt;※SEGリレートなし、PAXリレートなし | リクエストパラメータのカートIDにおけるカート情報 | - | | AP | 代表者連絡先電話番号 &lt;br&gt;フリーテキスト &#x3D; \&quot;+\&quot; + 国番号 + \&quot;-\&quot; + 電話番号 + \&quot;/CTC HERE-\&quot; + 種別(※) &lt;br&gt;※種別に関しては、登録されている電話番号種別が自宅の場合\&quot;H\&quot;、勤務先の場合は\&quot;B\&quot;、携帯の場合は\&quot;M\&quot;を設定する。 | リクエストパラメータのカートIDにおけるカート情報 | - | | SSR | コード&#x3D;CTCM &lt;br&gt;キャリアコード＝NH &lt;br&gt;フリーテキスト&#x3D;国番号 + 電話番号 + \&quot;/\&quot; + 当該contactsの言語 &lt;br&gt;※SEGリレートなし、PAXリレートあり &lt;br&gt;※電話番号国番号が日本 かつ 電話番号の先頭が0の場合、電話番号の先頭の0を取り除く。 | リクエストパラメータのカートIDにおけるカート情報 | カート情報のcontactsにおいて、以下を満たす連絡先が登録されている搭乗者の場合 &lt;br&gt;1. category&#x3D;personal &lt;br&gt;2. contactType&#x3D;Phone &lt;br&gt;3. purpose&#x3D;notification | | SSR | コード&#x3D;FQTV &lt;br&gt;キャリアコード＝DxAPIのprebook PNR作成機能に準じて登録される &lt;br&gt;カートのfrequentFlyerCardsに登録済みのFFP番号 &lt;br&gt;※SEGリレートなし、PAXリレートあり | リクエストパラメータのカートIDにおけるカート情報 | カート情報のfrequentFlyerCardsが登録された搭乗者の場合 | | SSR | コード&#x3D;FQTS &lt;br&gt;キャリアコード＝DxAPIのprebook PNR作成機能に準じて登録される &lt;br&gt;カートのfrequentFlyerCardsに登録済みのFFP番号 &lt;br&gt;※SEGリレートなし、PAXリレートあり | リクエストパラメータのカートIDにおけるカート情報 | カート情報のfrequentFlyerCardsが登録された搭乗者の場合 | | SSR | コード&#x3D;DOCS &lt;br&gt;フリーテキスト＝\&quot;P//\&quot; + パスポート番号 + \&quot;//\&quot; + 生年月日(ddMMMyy形式) + \&quot;/\&quot; + 性別コード(※) + \&quot;//\&quot; + 搭乗者姓 + \&quot;/\&quot; + 搭乗者名 + \&quot;/\&quot; + 搭乗者ミドルネーム &lt;br&gt;※性別コードは搭乗者の性別および搭乗者種別に従い以下の通り登録される。 &lt;br&gt;男性で大人もしくはヤングアダルト：M &lt;br&gt;男性で小児または幼児：MI &lt;br&gt;女性で大人もしくはヤングアダルト：F &lt;br&gt;女性で小児または幼児：FI &lt;br&gt;※SEGリレートなし、PAXリレートあり | リクエストパラメータのカートIDにおけるカート情報 | カート情報のtravelers.regulatoryDetailsにパスポート情報が登録された搭乗者の場合 | | SSR | コード &#x3D; 歩行程度のSSRコード &lt;br&gt;※SEGリレートなし、PAXリレートあり | リクエストパラメータのカートIDにおけるカート情報 | カート情報のservicesに歩行程度のSSRコードを含む搭乗者の場合 | | SSR | コード＝車いす種類と、バッテリータイプに応じて以下。 &lt;br&gt;1.車いす種類が「手動」の場合、\&quot;WCMP\&quot; &lt;br&gt;2.バッテリータイプが「ニッカド」「ニッケル水素」「リチウムイオン」の場合、\&quot;WCBD\&quot; &lt;br&gt;3.バッテリータイプが「シールド」「ノンシールド」の場合、\&quot;WCBW\&quot; &lt;br&gt;フリーテキスト ＝ カート情報の当該サービスに登録済のフリーテキスト &lt;br&gt;※SEGリレートなし、PAXリレートあり | リクエストパラメータのカートIDにおけるカート情報 | カート情報のservicesに車いす種類のSSRコードを含む搭乗者の場合 | | SSR | コード &#x3D; \&quot;BLND\&quot; &lt;br&gt;※SEGリレートなし、PAXリレートあり | リクエストパラメータのカートIDにおけるカート情報 | 搭乗者サポート情報の登録を行った搭乗者の場合、登録される | | SSR | コード &#x3D; \&quot;DEAF\&quot; &lt;br&gt;※SEGリレートなし、PAXリレートあり | リクエストパラメータのカートIDにおけるカート情報 | 搭乗者サポート情報の登録を行った搭乗者の場合、登録される | | SSR | コード＝ASWDB(マスタ)で管理されているラウンジのSSRコード &lt;br&gt;※SEGリレートあり、PAXリレートあり | リクエストパラメータのカートIDにおけるカート情報 | ラウンジの登録を行った搭乗者の場合、登録される | | SSR | コード ＝ \&quot;FBAG\&quot; &lt;br&gt;※SEGリレートあり、PAXリレートあり | リクエストパラメータのカートIDにおけるカート情報 | 事前追加手荷物の登録を行った搭乗者の場合、登録される | | SSR | コード＝ASWDB(マスタ)で管理されている有料機内食のSSRコード &lt;br&gt;※SEGリレートあり、PAXリレートあり | リクエストパラメータのカートIDにおけるカート情報 | 有料機内食の登録を行った搭乗者の場合、登録される | | SSR | コード＝ASWDB(マスタ)で管理されている特別機内食のSSRコード &lt;br&gt;※SEGリレートあり、PAXリレートあり | リクエストパラメータのカートIDにおけるカート情報 | 特別機内食の登録を行った搭乗者の場合、登録される | | SSR | コード＝ASWDB(マスタ)で管理されている事前ミールのSSRコード &lt;br&gt;※SEGリレートあり、PAXリレートあり | リクエストパラメータのカートIDにおけるカート情報 | 事前ミールの登録を行った搭乗者の場合、登録される | | TK XL | DxAPIのprebook PNR作成機能に準じて作成される &lt;br&gt;※設定ファイルより取得したprebook有効期限をDxAPIでのキー項目:minutesBeforeExpirationに指定することで実現する。 | 設定ファイル | - |  1. ASWDB(Tx) | 更新テーブル | 更新内容 | データ取得元 | 条件等 | | :------ | :------ | :------ | :------ | | プランリスト | 1. プラン保存済みの場合、prebook済みフラグをtrue、prebook有効期限をprebook PNR作成時に返却されたprebook有効期限に設定し、更新する。&lt;br&gt;2. プラン未保存の場合、以下の内容で登録を行う。  &lt;br&gt;   2-1. プラン作成日：現在日時(GMT) &lt;br&gt;   2-2. プラン有効期限：prebook PNR作成時に返却されたprebook有効期限 &lt;br&gt;   2-3. prebook有効期限：prebook PNR作成時に返却されたprebook有効期限 &lt;br&gt;   2-4. プラン未保存であるかどうか：true &lt;br&gt;   2-5. prebook済みであるかどうか：true  &lt;br&gt;   2-6. 有効期限：prebook PNR作成時に返却されたprebook有効期限 | - | - |  1. カート | 更新フィールド | 更新内容 | データ取得元 | 条件等 | | :------ | :------ | :------ | :------ | | extensions | キー&#x3D;\&quot;orderInfo\&quot;、値&#x3D;prebook時に発行された予約番号、prebook有効期限、第一搭乗者姓 | DxAPI | - |  # 4. 特記事項 1. PNRにメールアドレスが登録されていると、iCASが自動でメール配信を行う可能性がある。prebook状態のPNRに対するメール配信は行うべきでないため、本APIでは代表者メールアドレス、搭乗者メールアドレス、発着通知連絡先メールアドレスをPNRへ登録せず、購入発券後に登録を行う。  # 5. ToDo 1. 滞在先情報はAltea WBS経由で登録する必要があるが、こちらの取り込み可否についてASY内部検討中のため未記載。
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public ordersCreateOrderPost(
    generated?: OrdersCreateOrderRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<OrdersCreateOrderResponse>;
  public ordersCreateOrderPost(
    generated?: OrdersCreateOrderRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<OrdersCreateOrderResponse>>;
  public ordersCreateOrderPost(
    generated?: OrdersCreateOrderRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<OrdersCreateOrderResponse>>;
  public ordersCreateOrderPost(
    generated?: OrdersCreateOrderRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/orders/create-order`;
    return this.httpClient.request<OrdersCreateOrderResponse>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要 prebookPNRを削除し、カートのextensionsに保持しているprebook情報を削除する。また、AMC会員の場合は、プランリストに保持しているprebook情報を削除する。&lt;br&gt; ※未ログインユーザの場合は、ユーザ端末にプランリストを保持しているため、SPA側にてプランリストに保持しているprebook情報を削除する。  # 2. 処理概要 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、エラーハンドリングAPI(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。         1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。有効でない場合、HTTPステータスコード401(unauthorized)を返して、本処理を中止とする。         1. リクエストパラメータより受け取ったカートIDを基にDxAPIを呼び出し、カートのextensionsよりprebook PNRの予約番号と姓を取得する。&lt;br&gt; カート情報を取得できなかった場合、またはカートの論理削除フラグが登録されていた場合、HTTPステータスコード400(Bad Request)を返却し、処理を中断する。   1. prebook PNRの予約番号と姓を基にprebook情報を削除するDxAPIを呼び出し、prebookPNRを削除する。&lt;br&gt; ※DxAPIによるPNR削除は全旅程の削除であるため、PNR自体は残る。&lt;br&gt; また、カートのextensionsの削除を行うDxAPIを実行し、prebook PNRの予約番号を削除する。 1. 呼び出し元より渡されたアクセストークンを復号し、トークン内に含まれるuuidを基に、ASWDB(Tx)からログイン中の会員情報を取得できた場合、リクエストパラメータより受け取ったカートIDを基に、ASWDB(Tx)よりプランを取得する。取得したプランのプラン未保存であるかどうかにより、以下の処理を行う。           1. プラン未保存の場合、該当プランをASWDB(Tx)より削除する。           1. プラン未保存でない場合、該当プランを未prebook、prebook有効期限を空欄となるように更新する。 1. 上記処理完了後、HTTPステータスコード204(Deleted)を返却し、処理を終了する。  # 3. データ更新内容 1. ASWDB(Tx) | 更新テーブル | 更新内容 | データ取得元 | 条件等 | | :------ | :------ | :------ | :------ | | プラン | リクエストパラメータより取得したカートIDと、ユーザ共通のログイン情報より、prebook済み判定をfalse、prebook有効期限を空欄に更新する | リクエストパラメータ&lt;br&gt;ユーザ共通情報 | - |  1. カート | 更新フィールド | 更新内容 | データ取得元 | 条件等 | | :------ | :------ | :------ | :------ | | extensions | キー&#x3D;\&quot;orderId\&quot;(prebook PNRの予約番号)を削除する。 | - | キー&#x3D;\&quot;orderId\&quot;のextensionsIdを基に削除する。 |  1. PNR | 更新フィールド | 更新内容 | データ取得元 | 条件等 | | :------ | :------ | :------ | :------ | | セグメント情報 | 全てのセグメントの削除 | - | カートのextensionsに登録されている予約番号を基に削除する。 |
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public ordersDeletePrebookedOrderPost(
    generated?: OrdersDeletePrebookedOrderRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<OrdersDeletePrebookedOrderResponse>;
  public ordersDeletePrebookedOrderPost(
    generated?: OrdersDeletePrebookedOrderRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<OrdersDeletePrebookedOrderResponse>>;
  public ordersDeletePrebookedOrderPost(
    generated?: OrdersDeletePrebookedOrderRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<OrdersDeletePrebookedOrderResponse>>;
  public ordersDeletePrebookedOrderPost(
    generated?: OrdersDeletePrebookedOrderRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/orders/delete-prebooked-order`;
    return this.httpClient.request<OrdersDeletePrebookedOrderResponse>(
      'post',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: generated,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * # 1. 概要 1. GMOP(コンビニエンスストア、インターネットバンキング)による決済方式を選択した予約について、ウェルネット入金システムから入金情報を受信し、発券を行うことを目的とする。当機能では、ウェルネット入金システムより送信される入金情報に対して妥当性のチェックを行い、Alteaに対してPNRを決済完了状態へ更新、ARIと連携するキューへのキューイング、及び入金実績をASWDB(Tx)へ登録し、Wellnetへの入金完了通知を返却を行う。   ※IFに関する詳細は[[別添]決済用接続仕様書_V1.27.pdf][3-4-2 入金通知CGI通信仕様]付近参照  # 2. 処理内容 1. リクエストパラメータについて、以下条件を上から確認し、条件に合致した場合には、後述の共通エラー処理を実施し、【入金実績処理】まで処理をスキップする。   1. 入金ステータスが、ステータス：”000”以外である。   1. 支払いコードが、半角英数字の20桁以内ではない。   1. 受付番号が、半角英数字6桁ではない。   1. CVS本部コードが、半角英字及び半角スペースのみの5桁ではない。   1. 決済金額が、半角数字9桁より大きい、もしくは空文字である。   1. 入金日時：yyyyMMddHHmmss形式でない。 1. 以下の通り、リクエストパラメータを元に、MD5ハッシュ値を算出し、リクエストパラメータの整合性を確認する。   1. リクエストパラメータを以下のとおり連結する。（例：ret000scd111rno12345xxxxxxxxx）       “ret” + ステータス + “scd” + 支払コード + “rno” + 受付番号 + 秘密鍵       ※なお、秘密鍵の詳細については、「[別添]決済用接続仕様書_V1.27.pdf」[入金通知パラメータ]参照。   1. 連結文字列を暗号化する(ハッシュ値を算出)。（暗号化方式：MD5）（例：1b5805b6d10e137666ebacf94b79ad96）   1. ハッシュ値と、入金情報のMD5ハッシュ値を比較し、不一致の場合、後述の共通エラー処理を実施し、【入金実績処理】まで処理をスキップする。 1. FP更新に使用するため、AlteaWebServiceに対し、入金情報[受付番号（R/L）]を元にAltea I/F[PNR_Retrieve]を使用し、当該PNR情報を取得する。レスポンスはI/F[PNR_Reply]で返却される。     Alteaよりエラーが返却された場合には、後述の共通エラー処理を実施し、【入金実績処理】まで処理をスキップする。 1. 取得したPNR情報に対して、下記の通り妥当性を確認し、該当しない場合には、後述の共通エラー処理を実施し、【入金実績処理】まで処理をスキップする。   1. PNR情報.旅程情報が1件以上であること。   1. PNR情報.FP情報が1件であること。   1. PNR情報.FP情報の0～6桁目の値に、\&quot;WCCASH\&quot;(コンビニエンスストア)、\&quot;WBCASH\&quot;(インターネットバンキング)のいずれかを含んでいること。   1. PNR情報.FP情報が\&quot;WCCASH\&quot;(コンビニエンスストア)、\&quot;WBCASH\&quot;(インターネットバンキング)のみで構成されていないこと。 1. 合計金額取得のため、AlteaWebServiceに対し、入金情報[受付番号]を基に、AlteaのI/F[Ticket_DisplayTST]を使用し、当該TST情報を取得する。レスポンスはI/F[Ticket_DisplayTSTReply]で返却される。正常に取得できない場合には、後述の共通エラー処理を実施し、【入金実績処理】まで処理をスキップする。 1. 取得したTST情報に対して、下記の通り妥当性を確認し、条件に合致しない場合には、後述の共通エラー処理を実施し、【入金実績処理】まで処理をスキップする。   1. TST情報.運賃情報が1レコード以上であること。   1. TST情報.運賃情報がfareListにつき1件であること。   1. TST情報.合計金額の通貨が”JPY”であること。   1. TST情報.合計金額が1円以上であること。   1. TST情報.合計金額が入金金額と同額であること。 1. AlteaWebServiceに対し、AlteaのI/F[PNR_Cancel]を使用し、旧FPフィールドの削除をおこなう。レスポンスはI/F[PNR_Reply]で返却される。その後、AlteaのI/F[FOP_CreateFormOfPayment]を使用し、新FPフィールドの作成を行う。レスポンスはI/F[FOP_CreateFormOfPaymentReply]で返却される。正常に更新できない場合には、後述の共通エラー処理を実施し、【入金実績処理】まで処理をスキップする。 1. AlteaWebServiceに対し、AlteaのI/F[PNR_AddMultiElements]を使用し、PNR情報のEOT(コミット)を行う。レスポンスはI/F[PNR_Reply]で返却される。正常にコミット処理が行えない場合、もしくは、システムエラー発生時は、後述の共通エラー処理を実施し、【入金実績処理】まで処理をスキップする。 1. AlteaWebServiceに対し、AlteaのI/F[Queue_PlacePNR]を使用し、当該予約情報のキューイングを行う。レスポンスはI/F[Queue_PlacePNRReply]で返却される。正常にキューイングできない場合、後述の共通エラー処理を実施し、【入金実績処理】まで処理をスキップする。     なお、PNRのオフィスコードを基に、オフィスがWebのオフィスコードの場合はWeb用のキュー、それ以外の場合は設定ファイルより取得した有人オフィス用のキューへキューイングを行う。Q-BOX番号、カテゴリにおいても、設定ファイルより取得した値を利用する。 1. 入金情報、及びPNR情報を基に、入金実績としてASWDB(Tx)に登録する。登録対象は以下の内容とする。【入金実績処理】     なお、入金処理結果、国際詳細コード、国際詳細メッセージについては、各状況に沿った内容を設定する。（国際詳細コード・メッセージ一覧参照）     |NO|登録対象|   |---:|:---|   |1|ウェルネットから受信した入金情報のステータス|   |2|ウェルネットから受信した入金情報の支払いコード|   |3|ウェルネットから受信した入金情報の受付番号|   |4|ウェルネットから受信した入金情報のCVS本部コード|   |5|ウェルネットから受信した入金情報の入金日時|   |6|ウェルネットから受信した入金情報の決済金額|   |7|ウェルネットに返却する処理結果コード|   |8|TST情報より取得した合計金額|   |9|金額差異(お客様が支払った金額から、TST情報の合計金額を引いた数値)|   |10|入金処理の結果。正常であれば「OK」、業務エラーであれば「NG」、システムエラーであれば「ER」|   |11|キューイング先OFFICE(コード値)|   |12|キューイング先Q-BOX番号|   |13|国際詳細コード|   |14|国際詳細メッセージ|   |15|API基盤のローカル日本日時(操作日時・処理日時)|   |16|対象PNRの旅客搭乗者人数（旅客種別によらず全旅客をカウントする(席なし幼児も含む)）※|   |17|対象PNRの第一便出発日時（Alteaが返すローカル日付を日本時間に変換した日付および時刻）※|   |18|ユニークID（correlationId）※パーティションキーとして利用|      ※ウェルネット利用、2名以上のPNRかつ搭乗日が近い場合、入金確認時に発券エラーが発生することが確認されているため、入金データ上に「PNRの搭乗者数」「第一出発日」を追加している   【共通エラー処理】   1. 統合監視ログの出力   1. システムエラーログの出力  # 3. データ更新内容   # 4. 特記事項 1. アクセストークン、client_id、client_secretを用いた認証認可検証は実施しない。 1. 発券処理は、当機能でキューイング後、ARIにて実施するため、発券処理、及び発券処理に関連するチェック処理については当機能では考慮しない。 1. 決済完了案内メール及び、航空券(eチケット)に関するItinerary Receipt(I/R)の控えメールの送信はiCASにて実施する。 1. ASWより返却したレスポンスから、ウェルネット側にてタイムアウト、或いは通信異常等、一時的な問題であると判断した場合、ウェルネットの入金通知は、際限なくリトライされる可能性があるため、自動入金処理ではウェルネットからのリトライ処理回数に応じたエラーハンドリングについては考慮しない。それ以外と判断された場合、リトライは最大2回とする。 1. コールセンター作成PNRでI/Rの郵送が必要な場合は、運用にて送付する。 1. ATDへの入金実績ファイル送付処理は当機能では考慮不要とする。  # 5. 参考資料 1. 国際詳細コード・メッセージ一覧(※1)     |No|入金結果|国際詳細コード(※2)|国際詳細メッセージ|   |---:|:---:|:---|:---|   |1|OK|C 00|-|   |2|NG|C 24|通貨が混在している(入金金額：[お客様の入金金額]円)|   |3|NG|C 21|TST情報取得処理でシステムエラー(入金金額：[お客様の入金金額]円)|   |4|NG|C 23|TST情報内に運賃情報が複数存在する(入金金額：[お客様の入金金額]円)|   |5|NG|C 25|TST合計金額が0円(入金金額：[お客様の入金金額]円)|   |6|NG|C 22|TST情報データ不正(入金金額：[お客様の入金金額]円)|   |7|NG|C 12|旅程情報が無い(入金金額：[お客様の入金金額]円)|   |8|NG|C 1|入金情報にレコードロケータがない(入金金額：[お客様の入金金額]円)|   |9|NG|C 14|既に支払い済みである(入金金額：[お客様の入金金額]円)|   |10|NG|C 30|運賃不整合(入金金額：[お客様の入金金額]円 差分：[入金金額とTST合計金額の差分]円)|   |11|NG|C 2|入金データ不正(入金金額：[お客様の入金金額]円)|   |12|NG|C 13|支払方法が不正(入金金額：[お客様の入金金額]円)|   |13|NG|C 11|対象PNR情報が無い(入金金額：[お客様の入金金額]円)|   |14|ER|C 90|その他システムエラー(入金金額：[お客様の入金金額]円)(エラーコード：[Alteaのエラーコード])|      ※1：表項目説明     &amp;emsp;A)　入金結果：ASWDB(Tx)に登録する入金結果項目となる情報     &amp;emsp;B)　国際詳細コード(固定)：CODEを示す固定値     &amp;emsp;C)　国際詳細コード(入金結果コード)：ASWにて管理するコード内容に対する管理番号     &amp;emsp;D)　国際詳細メッセージ：国際詳細コードに対応するメッセージ文言     ※2：国際詳細コードは、「固定」「入金結果コード」「プリチェック結果」「郵便即日振替結果」を連結した7桁の半角英数字をコード値とする    1. SOAP Faultエラーコード一覧   |Fault Code|Error Code|OSI Layer|SOAP faultactor|一時的/永続的|Error Text|   |:---|:---:|:---|:---|:---:|:---|   |Client|11|Application|SI:Backend|永続|Incorrect authentication. You must get authenticated prior to any functional query.|   |Client|99|Session|Not specified|永続|Not authenticated|   |Client|18|Presentation|SI:APA|永続|detail of exception&lt;BR&gt;18\\|Presentation\\|Fusion&lt;BR&gt;DSC found an exception !&lt;BR&gt;+ text giving the location of error in the message|   |Client|18|Unknown error|SI:APA|永続|An unknown error has occured. Please contact your helpdesk|   |Client|12|Presentation|SI:\\&lt;mux name&gt;|永続|soap message header incorrect|   |Client|17|Session|Not specified|永続|No agreement on destination|   |Client|91|Session|SI:\\&lt;srv name&gt;|一時|No error text&lt;BR&gt;Future text: Not enough resources|   |Client|93|Session|SI:\\&lt;srv name&gt;|一時|Illogical conversation|   |Client|95|Session|SI:\\&lt;srv name&gt;|一時|Inactive conversation|   |Client|96|Session|SI:\\&lt;srv name&gt;|一時|Not specified&lt;BR&gt;Future: Too many opened conversations|   |Client|97|Session|SI:\\&lt;srv name&gt;|一時|Aborted conversation|   |Client|98|Session|SI:\\&lt;srv name&gt;|一時|Bad security token|   |Server|各IF指定|Application|SI:Backend|永続|各IF任意|   |Server|18|Presentation|SI:Backend|永続|The backend didn\&#39;t understand the incoming query. Please contact your helpdesk.&lt;BR&gt;Future: Message decoding/encoding on the target application failed|   |Server|18|Presentation|SI:APA|永続|detail of exception&lt;BR&gt;18\\|Presentation\\|Fusion DSC found an exception !&lt;BR&gt;+ text giving the location of error in the message&lt;BR&gt;Future: 18\\| Internal syntax error|   |Server|42|Presentation|SI:Backend|一時|Too many opened conversations. Please close them and try again.&lt;BR&gt;Future: No resource available|   |Server|42|Transport|Not specified|一時|Temporary network error: unable to reach targeted|
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public ordersOfflinePaymentPost(
    generated?: OfflinePaymentRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<OfflinePaymentResponse>;
  public ordersOfflinePaymentPost(
    generated?: OfflinePaymentRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<OfflinePaymentResponse>>;
  public ordersOfflinePaymentPost(
    generated?: OfflinePaymentRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<OfflinePaymentResponse>>;
  public ordersOfflinePaymentPost(
    generated?: OfflinePaymentRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/orders/offline-payment`;
    return this.httpClient.request<OfflinePaymentResponse>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1.概要&lt;br/&gt; DxAPIを呼び出して購入/発券処理(またはKeep my fareを利用した予約の取り置き)を行う。&lt;br/&gt; Ancillaryサービスが申し込まれている場合、航空券だけではなくAncillaryサービスの購入/発券処理(またはKeep my fareを利用した予約の取り置き)を同時に行う。&lt;br/&gt; 支払方法に応じたDxAPIの購入/発券処理は以下の流れとなる。&lt;br/&gt; 1. クレジットカード決済の場合、3Dセキュア(以下、3DSとする)による認証要否に応じて以下の処理となる。&lt;br/&gt;     1. Cardinalを利用した決済になる場合&lt;br/&gt;         1. 当APIの処理を一度中断し、呼び出し元にてCardinalを利用して端末情報を収集し、収集した情報にて再度購入/発券処理を行う。&lt;br/&gt;         中断時、呼び出し元にて実施する処理に必要な情報を返却する。&lt;br/&gt;         1. リクエストされたクレジットカード情報に対して3DSv2チャレンジフローまたは3DSv1が適用される場合、再度当APIの処理を中断し、呼び出し元にて認証を行い、&lt;br/&gt;         その認証結果にて再度購入/発券処理を行う。中断時、呼び出し元にて実施する処理に必要な情報を返却する。&lt;br/&gt;     1. Cardinalを利用した決済にならず、リクエストされたカード情報に対して3DSv1が適用される場合&lt;br/&gt;     当APIの処理を一度中断し、呼び出し元にて認証を行う。その認証結果にて再度購入/発券処理を行う。&lt;br/&gt;     中断時、呼び出し元にて実施する処理に必要な情報を返却する。&lt;br/&gt;     1. 3DSが適用されない場合、リクエストされたクレジットカード情報により購入/発券処理を行う。&lt;br/&gt; &lt;br/&gt; 1. ANA SKYコインによる決済は、クレジットカード決済と併用可能(全額ANA SKYコインも可能)とし、上記クレジットカード支払の処理において、&lt;br/&gt; ANA SKYコイン利用分の金額を指定し、クレジットカードの決済とANA SKYコインの同時決済および購入/発券処理を行う。&lt;br/&gt; &lt;br/&gt; 1. AMOP(銀聯、Alipay、Paypal)による決済の場合、当APIの処理を一度中断し、呼び出し元にて外部決済サイトへリダイレクトして認証を行う。&lt;br/&gt; その認証結果にて再度購入/発券処理を行う。&lt;br/&gt; 中断時、呼び出し元にて実施する処理に必要な情報を返却する。&lt;br/&gt; &lt;br/&gt; 1. GMOP(インターネットバンキング/コンビニエンスストア)による決済の場合、購入/発券処理を行いFPエレメントを登録して未発券のまま購入完了とする。&lt;br/&gt; &lt;br/&gt; 1. 当APIは、プランから作成したprebook PNRに対する購入・発券と、Keep My Fareによって予約済みのPNRに対する購入・発券の2つをサポートする。&lt;br/&gt; prebook PNRの購入・発券の際は、プランの削除を同時に行うため、呼び出し元より予約番号とカートIDの両方を指定してもらうものとし、DxAPIによる購入・発券完了後に以下も同時に行う。&lt;br/&gt;     1. プランに保存されている代表者、搭乗者、発着通知メールの登録&lt;br/&gt;     (prebook時に登録されてしまうとメールが送信されてしまうため、PNRが確定してから登録を行う)&lt;br/&gt;     1. プランの削除&lt;br/&gt;     1. ご紹介ねっと利用予約である場合、ASWDB(Tx)に社員紹介実績を登録&lt;br/&gt; &lt;br/&gt; 1. 航空券の購入を完了した場合、以下の処理を行う。&lt;br/&gt; ※Keep My Fareによる予約の場合は実施しない。&lt;br/&gt;     1. SK STEBを登録したPNRについて、実際には座席を選択しなかった場合、SK STEBを削除する。&lt;br/&gt;     1. カウチを購入したPNRについて、カウチ用NCP作成のためにPNRをキューイングする。&lt;br/&gt; &lt;br/&gt; 1. 購入/発券完了後、条件に応じて以下のメールを送信する。&lt;br/&gt;     1. 購入完了メールまたは予約完了メール&lt;br/&gt;     リクエストにクレジットカードまたはANA SKYコインによる支払を指定した場合、メールに以下のファイルが添付される。&lt;br/&gt;         1. クレジットカードによる支払額が存在する場合、CCCFが添付される。&lt;br/&gt;         1. 操作オフィスのPOSが日本である場合、領収書が添付される。&lt;br/&gt;         1. &lt;span style&#x3D;\&quot;color: red\&quot;&gt;予約完了メールである場合、EMD控えが添付される。&lt;/span&gt;&lt;br/&gt;     1. IRメール(PDFファイル形式のお客様情報控え）&lt;br/&gt;     メールに以下のファイルが添付される。&lt;br/&gt;         1. IR&lt;br/&gt;         1. オーバーブッキングの案内&lt;br/&gt;         ※~~CAS~~&lt;span style&#x3D;\&quot;color: red\&quot;&gt;iCAS&lt;/span&gt;により添付要否が決定される。&lt;br/&gt;     1. 有料サービス申込完了メール&lt;br/&gt;       ※Ancillaryサービスの購入/発券を同時に行った場合、購入完了メール送信と同時に~~CAS~~&lt;span style&#x3D;\&quot;color: red\&quot;&gt;iCAS&lt;/span&gt;により代表者メールへ送信される。&lt;br/&gt;         メールに以下のファイルが添付される。&lt;br/&gt;         1. EMD控え&lt;br/&gt;         1. クレジットカードによる支払額が存在する場合、CCCF&lt;br/&gt;         1. 操作オフィスのPOSが日本である場合、領収書&lt;br/&gt; &lt;br/&gt; 1. リクエストパラメータに予約基本情報更新内容が存在する場合、予約基本情報の更新を行う。 &lt;!-- list end --&gt;  # 2.処理内容&lt;br/&gt;   1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、 エラーハンドリング(API)(G01-010)を利用してMulesoftが生成したエラー情報を解析し、&lt;br/&gt; ステータスコード400(Bad request)でエラー情報を返却する。&lt;br/&gt; ※エラー情報には、エラーコードごとにエラー発生項目が含まれる。&lt;br/&gt; &lt;br/&gt; 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br/&gt;    有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; &lt;br/&gt; 1. 呼び出し元より渡されたアクセストークンを復号し、トークン内に含まれるuuidを基に、ASWDB(Tx)からログイン中の会員情報を取得する。&lt;br/&gt;    ログインステータスがリアルログインではない、かつリクエストパラメータが以下のいずれかに合致する場合は、    ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;    ※COMMON-005共通部品利用予定 ※詳細処理は確認中&lt;br/&gt;     1. ANA SKYコイン利用情報が存在する。&lt;br/&gt;     1. クレジットカード情報が存在する、かつ予約基本情報利用カード種別が存在する。&lt;br/&gt;     1. 予約基本情報更新内容が存在する。&lt;br/&gt; &lt;br/&gt; 1. PNR情報取得APIを呼び出す。&lt;br/&gt;    PNR情報取得APIからPNRが取得できなかった場合ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; &lt;br/&gt; 1. PNR情報取得APIにて返却された購入可否が不可の場合、不可理由に応じて以下パターンごとにステータス400(Bad Request)で&lt;br/&gt;    エラー情報を返して、本処理を中止する。&lt;br/&gt;     1. 発券期限エラー&lt;br/&gt;     1. それ以外&lt;br/&gt; &lt;br/&gt; 1. リクエストパラメータについて、以下いずれかに合致する場合、ステータスコード400(Bad request)でエラー情報を返して、&lt;br/&gt;    本処理を中止とする。&lt;br/&gt;    エラー情報には、エラー発生項目を含めるようにする。&lt;br/&gt;     1. 支払リクエスト情報に以下のいずれも存在しない。&lt;br/&gt;         1. クレジットカード情報&lt;br/&gt;         1. ANA SKYコイン利用情報&lt;br/&gt;         1. AMOP情報&lt;br/&gt;         1. GMOP情報&lt;br/&gt;     1. クレジットカード情報、AMOP情報、GMOP情報のうち、いずれか2つ以上が同時に存在する。&lt;br/&gt;     1. ANA SKYコイン利用情報が存在するかつ、AMOP情報とGMOP情報のいずれかまたは両方が存在する。&lt;br/&gt;     1. 操作デバイスが、支払方法ごとに定義した利用可能デバイス(PC/SP/TAB)ではない。&lt;br/&gt;        支払方法ごとの利用可能デバイスはASWDB(マスタ)から取得する。&lt;br/&gt;     1. クレジットカード情報が存在する、かつ以下のいずれかに合致する。&lt;br/&gt;         1. 予約基本情報更新内容のクレジットカード登録名称が存在するかつ、&lt;br/&gt;            クレジットカード情報のクレジットカード番号が存在しない。&lt;br/&gt;         1. 予約基本情報利用カード種別とクレジットカード番号が両方存在しない。&lt;br/&gt;         1. 予約基本情報利用カード種別とクレジットカード番号が両方存在する。&lt;br/&gt;         1. セキュリティコードが存在しないかつ、以下の全てに合致する。&lt;br/&gt;             1. 認証パラメータ(3DSv1支払認証パラメータまたは3DSv2支払認証パラメータ)が存在しない。&lt;br/&gt;             1. UATPカードであるかがUATPカードではない。&lt;br/&gt;         1. UATPカードであるかがUATPカードである場合、操作オフィスのPOSがUATPカード利用可能POSではない。&lt;br/&gt;            UATPカード利用可能POSはASWDB(マスタ)から取得する。&lt;br/&gt;         1. クレジットカード有効期限の年が現在の年から14年後の範囲ではない。&lt;br/&gt;         1. 認証パラメータ(3DSv1支払認証パラメータまたは3DSv2支払認証パラメータ)が存在しないかつ、支払者識別情報が存在しない。&lt;br/&gt;         1. 支払者識別情報が存在する、かつ以下~~のいずれか~~に合致する。&lt;br/&gt;             1. ~~メールアドレスのフォーマットが不正(共通部品、G03-501を使用)である。~~&lt;br/&gt;             1. 電話番号の国コードが日本である、かつ&lt;span style&#x3D;\&quot;color: red\&quot;&gt;電話番号のフォーマットが不正(共通部品、G03-501を使用)である&lt;/span&gt;~~電話番号が9～11桁ではない~~。&lt;br/&gt;     1. ANA SKYコイン利用情報が存在するかつ、以下のいずれかに合致する。&lt;br/&gt;         1. 操作オフィスのPOSが日本ではない。&lt;br/&gt;         1. 旅程中に、NHグループ便名(NH、NQ)ではない便が存在する。&lt;br/&gt;         1. 搭乗者IDに指定したANA SKYコイン利用搭乗者が以下のいずれかに合致する。&lt;br/&gt;            (条件を満たす搭乗者について以下、ANA SKYコイン利用可能搭乗者とする。)&lt;br/&gt;             1. ログインユーザ本人ではない。&lt;br/&gt;             1. Mindsから特典利用者情報を取得したが取得できない、または取得できたがその情報に登録されていない。&lt;br/&gt;         1. クレジットカード情報が存在しないかつ、ANA SKYコイン適用額の合計が支払総額未満である。&lt;br/&gt;         1. ANA SKYコイン適用額が10円単位となっていない。&lt;br/&gt;         1. ANA SKYコイン適用額が上限を超えている。&lt;br/&gt;            上限は各ANA SKYコイン利用可能搭乗者の航空券に対する支払額までとする。&lt;br/&gt;            各ANA SKYコイン利用可能搭乗者の支払額が1円単位の場合は、10円単位で切り上げた額を上限とする。&lt;br/&gt;         1. ANA SKYコイン適用額の合計がANA SKYコイン残高を超過している。&lt;br/&gt;            ANA SKYコインの残高はMindsから取得する。&lt;br/&gt;     1. GMOP情報が存在する、かつ以下のいずれかに合致する。&lt;br/&gt;         1. 操作オフィスのPOSが日本ではない。&lt;br/&gt;         1. 旅程中のいずれかのフライトが、以下のいずれかに合致する。&lt;br/&gt;             1. NHグループ便名かつNHグループ運航(NH、NQ、EH)ではない。&lt;br/&gt;             1. 日本国内線かつNHグループ便名ではない。&lt;br/&gt;         1. 支払対象にAncillaryサービスが含まれる。&lt;br/&gt;         1. 払込期限が、操作日時 + ウェルネット用支払猶予時間より前である。&lt;br/&gt;            ウェルネット用支払猶予時間は設定ファイルから取得する。&lt;br/&gt;            払込期限は、以下のうち最も早いものを払込期限とする。&lt;br/&gt;             1. OPCもしくは日本の現在日時 + ウェルネット用発券期限延長時間のうち、遅い時間。&lt;br/&gt;                ※ウェルネット用発券期限延長時間は設定ファイルから取得する。             1. 運賃のLast Ticketing Date(LTD)の23:59:59&lt;br/&gt;             1. ANAが定める第1便の最終発券期限&lt;br/&gt;                ※最終発券期限は出発何時間前とするかを設定ファイルに定義する。&lt;/br&gt;                ※出発日時は日本時間に換算して判定する。&lt;/br&gt;         1. ユーザ共通情報の&lt;span style&#x3D;\&quot;color: red\&quot;&gt;ご紹介ねっと&lt;/span&gt;紹介番号が存在する。&lt;br/&gt;         1. GMOP情報の支払方法にインターネットバンキングを指定した、かつ以下のいずれかに合致する。&lt;br/&gt;             1. 銀行コードが存在しない。&lt;br/&gt;             1. 銀行コードがASWDB(マスタ)に存在しない。&lt;br/&gt;         1. DxAPIから取得したPNRに登録された支払総額が、GMOPの支払方法ごとに定義した上限額を超過する。&lt;br/&gt;            支払方法がインターネットバンキングである場合、上限額は銀行単位の額をASWDB(マスタ)から取得する。&lt;br/&gt;            支払方法がコンビニエンスストア支払である場合、上限額は設定ファイルから取得する。&lt;br/&gt;     1. AMOP情報が存在する場合、かつ以下のいずれかに合致する。&lt;br/&gt;         1. AMOP情報の支払方法が銀聯またはAlipayである、かつ操作オフィスのPOSが中国ではない。&lt;br/&gt;         1. AMOP情報の支払方法がPaypalである、かつ利用可能POSではない。&lt;br/&gt;            操作オフィスごとのPaypalの利用可否はASWDB(マスタ)から取得する。&lt;br/&gt;         1. 支払認証用HTTPリクエスト情報のHTTPメソッドの値が\&quot;POST\&quot;である、かつリクエストパラメータ情報リストが存在しない。&lt;br/&gt;     1. Keep My Fare利用フラグでKeep My Fareの利用を指定したかつ以下のいずれかに合致する。&lt;br/&gt;         1. PNR情報取得APIよりKeep My Fare利用可の旨が返却されていない。&lt;br/&gt;         1. DxAPIより取得するOPCのtime limitが操作日時 + Keep My Fareホールド時間より過去の日付である。&lt;br/&gt;            Keep My Fareホールド時間は、設定ファイルから取得する。&lt;br/&gt;            ※分の切り捨てを行わず72時間後に設定する。&lt;br/&gt;         1. 日本国内単独旅程である、または旅程中のいずれかの便が、以下のいずれかに合致する。&lt;br/&gt;             1. NHグループ便名かつNHグループ運航ではない。&lt;br/&gt;             1. NHグループ便名の日本国内線ではない。&lt;br/&gt;         1. クレジットカード情報が存在しない、またはANA SKYコイン利用情報が存在する。&lt;br/&gt;     1. 領収書宛名が存在する、かつShift_JISで取り扱い可能な文字ではない。(共通部品、G03-501を使用)&lt;br/&gt; &lt;br/&gt; 1. 現在日付が有料ミール申込対象便の出発24時間前を過ぎている場合、ステータスコード400(Bad request)でエラー情報を返して、&lt;br/&gt;    本処理を中止とする。&lt;br/&gt;    ※現在日付は、出発空港コードに紐づく空港のタイムゾーンを考慮した時刻換算を行って比較を行う。&lt;br/&gt;    空港ごとの時差はASWDB(マスタ)から取得する。&lt;br/&gt; &lt;br/&gt; 1. DxAPIを呼び出して支払に関する処理を行う。&lt;br/&gt;     1. 以下のいずれかに合致する場合、PNRに登録済みかつ支払認証の行われていないFPエレメントを削除する。&lt;br/&gt;        ※PNRに登録済みかつ支払認証の行われていないFPエレメントが存在しない場合は処理を行わない。&lt;br/&gt;         1. リクエストにクレジットカード情報が存在する、かつ支払認証パラメータ(3DSv1支払認証パラメータまたは3DSv2支払認証パラメータ)&lt;br/&gt;            が存在しない。&lt;br/&gt;         1. リクエストにAMOP情報が存在する、かつ支払認証用HTTPリクエスト情報が存在しない。&lt;br/&gt;     1. リクエストパラメータのKeep My Fare利用フラグでKeep My Fareの利用を指定した場合、以下の処理を行う。&lt;br/&gt;         1. Keep My Fare申込に利用する情報を取得するためにDxAPIを呼び出し、指定した予約番号に紐づくカタログ情報を取得する。&lt;br/&gt;         1. DxAPIを呼び出して、Keep My Fareの申込を行う。&lt;br/&gt;     1. 支払方法に応じて以下の処理を行う。&lt;br/&gt;         1. リクエストにクレジットカード情報が存在する場合、以下の処理を行う。&lt;br/&gt;             1.リクエストに予約基本情報利用カード種別が存在する場合、ユーザ共通情報の一般用クレジットカード番号を取得する。&lt;br/&gt;             1. リクエストにCardinalから返却されるセッションID、支払認証パラメータ(3DSv1支払認証パラメータまたは3DSv2支払認証パラメータ)が&lt;br/&gt;                いずれも存在しない場合、DxAPIへクレジットカード情報を送信してDxAPIの3DS初期化処理のリクエストを行い、jwtトークンを取得する。&lt;br/&gt;                jwtトークンを取得できた場合、セキュアプロバイダがCardinalであるとしてステータスコード201(Created)でjwtトークンを返却して、本処理を中止とする。&lt;br/&gt;                ※取得できなかった場合はセキュアプロバイダがAmadeusであるとし、以降の処理を継続する。&lt;br/&gt;         1. リクエストパラメータにGMOP情報が存在する場合、以下の情報を設定してウェルネットから決済番号を取得する。&lt;br/&gt;&lt;span style&#x3D;\&quot;color: red\&quot;&gt;※パス未定/マルチペイメントサービス仕様書1.0.4.pdfに基づき設定する。&lt;/span&gt;&lt;/br&gt;             | 項目名  | 設定内容 |              | :------------- | :--------------------------------------- |             | データ種別 | 設定ファイルへ定義するデータ種別 |             | 支払コード | 設定ファイルへ定義する言語に応じた支払コード |             | 受付番号 | リクエストパラメータの予約番号 |             | 事業者番号 | 設定ファイルへ定義する言語に応じた事業者番号 |             | 契約案件番号 | 設定ファイルへ定義する契約案件番号 |             | 認証キー | リクエストパラメータの予約番号 |             | データ区分 | 設定ファイルへ定義するデータ区分 |             | 企業コード | 設定ファイルへ定義する言語に応じた企業コード |             | 電話番号 | 設定ファイルへ定義する電話番号 |             | お客様氏名(全角漢字) | PNRに登録された1番目の搭乗者の姓と名を結合した値。(40バイトを超える文字は切り捨てる。)&lt;br/&gt;※姓と名の間には半角スペースを挿入する。 |             | 支払期限 | PNRのFPに登録する払込期限&lt;/br&gt;(フォーマットはyyyyMMddHHmm) |             | 支払金額 | PNRに登録された支払総額 |             | 予約番号 | \&quot;\&quot;(空文字) |             | 会員番号 | 以下の通り設定する。&lt;br/&gt;&lt;ol&gt;&lt;li&gt;ログインステータスがリアルログインである場合、会員情報の会員番号&lt;/li&gt;&lt;li&gt;ログインステータスがリアルログインではない場合、\&quot;\&quot;(空文字)&lt;/li&gt;&lt;/ol&gt; |             | お客様氏名(全角カナ) | PNRに登録された1番目の搭乗者の姓と名を結合した値。(40バイトを超える文字は切り捨てる。)&lt;br/&gt;※姓と名の間には半角スペースを挿入する。 |             | フリースペース1 | 設定ファイルへ定義する予約を受け付けた旨の文言 |             | フリースペース2 | 設定ファイルへ定義する何名分の請求金額か示す旨の文言 |             | フリースペース3 | 設定ファイルへ定義する、出発日、便名、区間、出発時刻を示す旨の文言 |             |フリースペース4|旅程中のセグメントの件数が2件以上の場合、フリースペース3と同じ内容を設定する。&lt;br/&gt;2件未満の場合は空文字を設定する。|             |フリースペース5|PNRの1番目のセグメントの出発日+\&quot; \&quot;+便名+\&quot; \&quot;+出発空港コード+\&quot;-\&quot;+到着空港コード+\&quot; \&quot;+出発時間&lt;br/&gt;※各項目を結合する際に挿入するスペースは半角スペースとする。|             |フリースペース6|PNRの2番目のセグメントの出発日+\&quot; \&quot;+便名+\&quot; \&quot;+出発空港コード+\&quot;-\&quot;+到着空港コード+\&quot; \&quot;+出発時間&lt;br/&gt;対象となるセグメントが存在しない場合は空文字を設定する。&lt;br/&gt;※各項目を結合する際に挿入するスペースは半角スペースとする。|             |フリースペース7|PNRの3番目のセグメントの出発日+\&quot; \&quot;+便名+\&quot; \&quot;+出発空港コード+\&quot;-\&quot;+到着空港コード+\&quot; \&quot;+出発時間&lt;br/&gt;対象となるセグメントが存在しない場合は空文字を設定する。&lt;br/&gt;※各項目を結合する際に挿入するスペースは半角スペースとする。|             |フリースペース8|PNRの4番目のセグメントの出発日+\&quot; \&quot;+便名+\&quot; \&quot;+出発空港コード+\&quot;-\&quot;+到着空港コード+\&quot; \&quot;+出発時間&lt;br/&gt;対象となるセグメントが存在しない場合は空文字を設定する。&lt;br/&gt;※各項目を結合する際に挿入するスペースは半角スペースとする。|             | 以下のお客様へのご案内&lt;br/&gt;&lt;ol&gt;&lt;li&gt;お客様へのご案内1&lt;/li&gt;&lt;li&gt;お客様へのご案内2&lt;/li&gt;&lt;li&gt;お客様へのご案内3&lt;/li&gt;&lt;li&gt;お客様へのご案内4&lt;/li&gt;&lt;li&gt;お客様へのご案内5&lt;/li&gt;&lt;li&gt;お客様へのご案内6&lt;/li&gt;&lt;li&gt;お客様へのご案内7&lt;/li&gt;&lt;li&gt;お客様へのご案内8&lt;/li&gt;&lt;li&gt;お客様へのご案内9&lt;/li&gt;&lt;li&gt;お客様へのご案内10&lt;/li&gt;&lt;/ol&gt; | 設定ファイルへ定義するお客様に注意を促す旨の文言 |             | お問い合わせ先 | 設定ファイルへ定義するお問い合わせ先名称を示す旨の文言 |             | お問い合わせ先電話番号 | 以下の通り設定する。&lt;/br&gt;&lt;ol&gt;&lt;li&gt;ログインステータスがリアルログインである場合、設定ファイルへ定義する言語に応じたお問い合わせ先電話番号(ANAマイレージクラブ会員用)&lt;/li&gt;&lt;li&gt;ログインステータスがリアルログインではない場合、設定ファイルへ定義する言語に応じたお問い合わせ先電話番号(未ログイン会員用)&lt;/li&gt;&lt;/ol&gt; |             | お問い合わせ受付時間 | 設定ファイルへ定義するお問合せ先受付時間を示す旨の文言 |             | 戻り先URL | \&quot;\&quot;(空文字) |             | お客様へのご案内タイトル | \&quot;\&quot;(空文字) |             | チケット枚数 | \&quot;0\&quot; |             | 以下の個別スクリプト&lt;/br&gt;&lt;ol&gt;&lt;li&gt;個別スクリプト1&lt;/li&gt;&lt;li&gt;個別スクリプト2&lt;/li&gt;&lt;li&gt;個別スクリプト3&lt;/li&gt;&lt;li&gt;個別スクリプト4&lt;/li&gt;&lt;li&gt;個別スクリプト5&lt;/li&gt;&lt;li&gt;個別スクリプト6&lt;/li&gt;&lt;li&gt;個別スクリプト7&lt;/li&gt;&lt;li&gt;個別スクリプト8&lt;/li&gt;&lt;li&gt;個別スクリプト9&lt;/li&gt;&lt;li&gt;個別スクリプト10&lt;/li&gt;&lt;/ol&gt; | 設定ファイルへ定義する支払についての注意書きを示す旨の文言 |             | 以下の個別スクリプト&lt;/li&gt;&lt;ol&gt;&lt;li&gt;個別スクリプト11&lt;/li&gt;&lt;li&gt;個別スクリプト12&lt;/li&gt;&lt;li&gt;個別スクリプト13&lt;/li&gt;&lt;li&gt;個別スクリプト14&lt;/li&gt;&lt;li&gt;個別スクリプト15&lt;/li&gt;&lt;li&gt;個別スクリプト16&lt;/li&gt;&lt;li&gt;個別スクリプト17&lt;/li&gt;&lt;li&gt;個別スクリプト18&lt;/li&gt;&lt;li&gt;個別スクリプト19&lt;/li&gt;&lt;li&gt;個別スクリプト20&lt;/li&gt;&lt;/ol&gt; | \&quot;\&quot;(空文字) |     1. 以下のいずれかが存在する場合、その内容をDxAPIへ送信する情報として設定してDxAPIの購入/発券処理(外部サイトでの認証後用)を行う。&lt;br/&gt;         1. クレジットカード情報と支払認証パラメータ(3DSv1支払認証パラメータまたは3DSv2支払認証パラメータ)&lt;br/&gt;         1. AMOP情報と支払認証用HTTPリクエスト情報&lt;br/&gt;     1. 上記にて購入/発券処理(外部サイトでの認証後用)を実施しなかった場合、以下の処理を行う。         1. ユーザ共通情報のAPFコードが存在する場合、FTエレメントにAPFコードを登録する為、Altea Web Service(PNR_AddMultiElements)を利用して登録を行う。         1. DxAPIの購入/発券処理を行う。支払方法に応じてDxAPIへ送信する情報として、以下の内容を設定する。&lt;br/&gt;         ※GMOPによる支払である場合、未発券のまま購入完了となる。           1. リクエストにANA SKYコイン利用情報が存在する場合、\&quot;paymentMethod\&quot;に以下を設定する。&lt;br/&gt;               1. \&quot;id\&quot;に\&quot;SKYC\&quot;&lt;br/&gt;               1. \&quot;paymentType\&quot;に\&quot;CustomPayment\&quot;&lt;br/&gt;               1. \&quot;parameters\&quot;に以下を設定する。&lt;br/&gt;                   1. \&quot;key\&quot;に\&quot;accountNumber\&quot;、\&quot;value\&quot;にAMC会員番号&lt;br/&gt;                   1. \&quot;key\&quot;に\&quot;routingVendor\&quot;、\&quot;value\&quot;に\&quot;NH\&quot;&lt;br/&gt;           1. リクエストにクレジットカード情報が存在する場合、クレジットカード情報を設定する。&lt;br/&gt;              ※送信するクレジットカード情報のうち、カードブランドについては、UATPカード以外はブランドを指定せずに&lt;br/&gt;                カード番号のみを指定する。&lt;br/&gt;              DxAPIから3DS認証が必要である旨の回答がされた場合、ステータスコード201(Created)で支払認証パラメータ(3DSv1支払認証パラメータまたは3DSv2支払認証パラメータ)を&lt;br/&gt;              返却して、本処理を中止とする。&lt;br/&gt;              ※3DS認証が必要である旨の回答がされなかった場合、以降の処理を継続する。&lt;br/&gt;           1. リクエストにAMOP情報が存在する、かつ支払認証用HTTPリクエスト情報が存在しない場合、&lt;br/&gt;              AMOP情報の支払方法に応じて、\&quot;paymentMethod\&quot;の\&quot;id\&quot;に設定ファイルにて定義した値を設定する。&lt;br/&gt;              DxAPIから取得した外部サイト用支払認証用HTTPリクエスト情報をステータスコード201(Created)で返却して、本処理を中止とする。&lt;br/&gt;           1. リクエストパラメータのGMOP情報の支払方法にインターネットバンキングを指定した場合、\&quot;paymentMethod\&quot;に以下を設定する。&lt;br/&gt;               1. \&quot;id\&quot;に\&quot;WBCASH\&quot;&lt;br/&gt;               1. \&quot;paymentType\&quot;に\&quot;CustomPayment\&quot;&lt;br/&gt;               1. \&quot;parameters\&quot;に以下を設定する。&lt;br/&gt;                   1. \&quot;key\&quot;に\&quot;additionalInput[1]\&quot;、\&quot;value\&quot;に\&quot;I\&quot;&lt;br/&gt;                   1. \&quot;key\&quot;に\&quot;additionalInput[2]\&quot;、\&quot;value\&quot;に銀行コード&lt;br/&gt;                   1. \&quot;key\&quot;に\&quot;additionalInput[3]\&quot;、\&quot;value\&quot;にウェルネットから取得した決済番号&lt;br/&gt;                   1. \&quot;key\&quot;に\&quot;additionalInput[4]\&quot;、\&quot;value\&quot;に払込期限(yyyyMMddhhmm)&lt;br/&gt;                      払込期限は、操作日時 + ウェルネット用払込期限(FP登録用)とする。&lt;br/&gt;                      ※操作日時は、日本の現在日時とする。&lt;br/&gt;           1. リクエストパラメータのGMOP情報の支払方法にコンビニエンスストア支払い指定した場合、\&quot;paymentMethod\&quot;に以下を設定する。&lt;br/&gt;               1. \&quot;id\&quot;に\&quot;WCCASH\&quot;&lt;br/&gt;               1. \&quot;paymentType\&quot;に\&quot;CustomPayment\&quot;&lt;br/&gt;               1. \&quot;parameters\&quot;に以下を設定する。&lt;br/&gt;                   1. \&quot;key\&quot;に\&quot;additionalInput[2]\&quot;、\&quot;value\&quot;にウェルネットから取得した決済番号&lt;br/&gt;                   1. \&quot;key\&quot;に\&quot;additionalInput[3]\&quot;、\&quot;value\&quot;に払込期限(yyyyMMddhhmm)&lt;br/&gt;                      払込期限は、操作日時 + ウェルネット用払込期限(FP登録用)とする。&lt;br/&gt;                      ※操作日時は、日本の現在日時とする。&lt;br/&gt;     1. DxAPIの呼び出し時に、以下いずれかのエラーが返却された場合、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;         1. 決済エラー&lt;br/&gt;         1. 支払方法不正エラー&lt;br/&gt;         1. クレジットカード不正利用検知エラー&lt;br/&gt;         1. 購入期限切れエラー&lt;br/&gt;         1. 購入時スケジュールチェンジエラー&lt;br/&gt;         1. 以下のMinds処理エラー&lt;br/&gt;            ※ANA SKYコインを含む決済の場合のみ発生&lt;br/&gt;             1. Mindsとのコネクション確立に失敗した。&lt;br/&gt;             1. ANA SKYコイン不足である。&lt;br/&gt;             1. Mindsが一時的に更新制限状態である。&lt;br/&gt;             1. 二重受信チェックエラーである。&lt;br/&gt; &lt;br/&gt; 1. 航空券の購入を完了した場合、以下の処理を行う。&lt;br/&gt;     1. SK STEBを登録したPNRについて、実際には座席を選択しなかった場合、SK STEBを削除する。&lt;br/&gt;     1. 以下の全てに合致する場合、カウチ用NCP作成のためにPNRをキューイングする。&lt;br/&gt;     キューイング先は設定ファイルから取得する。&lt;br/&gt;         1. 購入したPNRにカウチが申し込まれている。&lt;br/&gt;         1. 申し込んだカウチ席のうち、利用人数が座席数より少なくなるカウチ席が1つでも存在する。&lt;br/&gt; &lt;br/&gt; 1. リクエストにカートIDが存在する場合、以下の処理を行う。&lt;br/&gt;     1. リクエストパラメータのカートIDに紐づくプラン情報のextensionsから以下のメールアドレスを取得して、PNRに登録する。&lt;br/&gt;         1. 代表者(extensionsのキー：contacts)&lt;br/&gt;         1. 搭乗者(extensionsのキー：~~travelars~~&lt;span style&#x3D;\&quot;color: red\&quot;&gt;travelers&lt;/span&gt;)&lt;br/&gt;         1. 発着通知(extensionsのキー：~~travelars~~&lt;span style&#x3D;\&quot;color: red\&quot;&gt;travelers&lt;/span&gt;)&lt;br/&gt;     1. リアルログイン済みAMC会員である場合、会員番号とリクエストのカートIDに指定したプランをASWDB(Tx)から削除する。&lt;br/&gt;     1. リクエストパラメータのカートIDに指定したカートのextensionsに論理削除フラグを登録する。&lt;br/&gt; &lt;br/&gt; 1. ユーザ共通情報の&lt;span style&#x3D;\&quot;color: red\&quot;&gt;ご紹介ねっと&lt;/span&gt;紹介番号が存在する場合、ASWDB(Tx)に社員紹介実績を登録する。&lt;br/&gt;    社員紹介実績を保存する際、旅程区分として日本国内線のみの旅程か国際線の旅程かを合わせて保存する。&lt;br/&gt; &lt;br/&gt; 1. ASWDB(Tx)に予約購入実績を登録する。&lt;br/&gt; &lt;br/&gt; 1. 以下のメールの送信をiCASへリクエストする。&lt;br/&gt;     iCASへのリクエストに領収書宛名を設定する場合は、リクエストパラメータの領収書宛名に敬称を付与した値を設定する。&lt;br/&gt;     敬称は設定ファイルから取得する。&lt;br/&gt;     1. iCASへのリクエストに利用する項目を取得するため、DxAPIから購入後のPNRを取得する。&lt;br/&gt;     1. 航空券の購入が完了した場合、購入完了メールを送信する。&lt;br/&gt;        Keep My Fareによる予約が完了した場合、代表者メールに予約完了メールを送信する。&lt;br/&gt;        いずれのメールも操作オフィスのPOSが日本である場合、領収書が添付される。&lt;br/&gt;     1. 航空券の購入が完了した、かつ発券に成功している場合、搭乗者ごとのメールアドレスに対して&lt;br/&gt;        IRメール(PDFファイル形式のお客様情報控え)を送信する。&lt;br/&gt; &lt;br/&gt; 1. リクエストパラメータの予約基本情報の支払方法更新要否に支払方法の更新が指定された、&lt;br/&gt;    かつリクエストパラメータが以下のいずれかに合致する場合、利用した支払方法を「予約基本情報」としてMindsへ登録する。&lt;br/&gt;    リクエストパラメータのGMOP情報の支払方法にインターネットバンキングを指定した場合、銀行コードに指定した銀行まで含めた&lt;br/&gt;    支払方法として登録する。&lt;br/&gt;     1. クレジットカード情報が存在する。&lt;br/&gt;     1. GMOP情報の支払方法がコンビニエンスストア支払である。&lt;br/&gt;     1. GMOP情報の支払方法がインターネットバンキングかつ登録可能な銀行コードである。&lt;br/&gt;     銀行コードが登録可能であるかはASWDB(マスタ)から取得する。&lt;br/&gt; &lt;br/&gt; 1. ~~クエストパラメータに予約基本情報更新内容が存在する場合、~~&lt;span style&#x3D;\&quot;color: red\&quot;&gt;リクエストパラメータの予約基本情報更新要否に予約基本情報の更新が指定された場合&lt;/span&gt;、決済時の情報を基にMindsへ「予約基本情報」の登録、更新を行う。&lt;br/&gt;     ~~「予約基本情報」の登録、更新対象項目は、リクエストパラメータの予約基本情報更新対象が\&quot;paymentCard1\&quot;である場合は&lt;br/&gt;     いつもの情報クレジットカード1とし、\&quot;paymentCard2\&quot;である場合はいつもの情報クレジットカード2とする。~~&lt;br/&gt;     1. ~~リクエストパラメータのクレジットカード登録名称が存在しない場合~~&lt;span style&#x3D;\&quot;color: red\&quot;&gt;リクエストパラメータの予約基本情報利用カード種別が指定されている場合&lt;/span&gt;、リクエストパラメータのクレジットカード有効期限の値で、&lt;br/&gt;        予約基本情報のクレジットカード有効期限を更新する。&lt;br/&gt;&lt;span style&#x3D;\&quot;color: red\&quot;&gt;更新対象のいつもの情報クレジットカードは以下とする。&lt;/span&gt;&lt;br/&gt;         1. &lt;span style&#x3D;\&quot;color: red\&quot;&gt;リクエストパラメータの予約基本情報利用カード種別が\&quot;paymentCard1\&quot;である場合、いつもの情報クレジットカード1。&lt;/span&gt;&lt;br/&gt;         1. &lt;span style&#x3D;\&quot;color: red\&quot;&gt;リクエストパラメータの予約基本情報利用カード種別が\&quot;paymentCard2\&quot;である場合、いつもの情報クレジットカード2。&lt;/span&gt;&lt;br/&gt;     1. ~~リクエストパラメータのクレジットカード登録名称が存在する、かつ以下の全てに合致する~~&lt;span style&#x3D;\&quot;color: red\&quot;&gt;リクエストパラメータの予約基本情報利用カード種別が指定されていない&lt;/span&gt;場合、以下の処理にて予約基本情報にリクエストパラメータのクレジットカード情報を登録する。&lt;br/&gt;&lt;span style&#x3D;\&quot;color: red\&quot;&gt;※登録時に指定するクレジットカード名称はASWDB(マスタ)に定義する。&lt;br/&gt;&lt;/span&gt;         1. &lt;span style&#x3D;\&quot;color: red\&quot;&gt;以下のいずれかに合致する場合、予約基本情報の登録は行わず、返却する情報にワーニング情報を含める。&lt;/span&gt;&lt;br/&gt;             1. &lt;span style&#x3D;\&quot;color: red\&quot;&gt;いつもの情報クレジットカード1およびいつもの情報クレジットカード2のクレジットカード番号が両方存在する。&lt;/span&gt;             1. &lt;span style&#x3D;\&quot;color: red\&quot;&gt;リクエストパラメータのクレジットカード番号がいつもの情報クレジットカード1またはいつもの情報クレジットカード2のクレジットカード番号と合致する。&lt;/span&gt;         1. &lt;span style&#x3D;\&quot;color: red\&quot;&gt;以下のいずれかを登録対象として、予約基本情報の登録を行う。&lt;/span&gt;             1. &lt;span style&#x3D;\&quot;color: red\&quot;&gt;いつもの情報クレジットカード1のクレジットカード番号が存在しない場合、いつもの情報クレジットカード1。&lt;/span&gt;             1. &lt;span style&#x3D;\&quot;color: red\&quot;&gt;いつもの情報クレジットカード2のクレジットカード番号が存在しない場合、いつもの情報クレジットカード2。&lt;/span&gt;         1. ~~&lt;span style&#x3D;\&quot;color: red\&quot;&gt;登録対象となる予約基本情報の一般用いつものクレジットカード情報のクレジットカード番号とリクエストパラメータのクレジットカード番号が合致しない。&lt;/span&gt;、かつ登録対象となる予約基本情報の一般用クレジットカード情報のクレジットカード名称とリクエストパラメータのクレジットカード登録名称が合致しない。~~&lt;br/&gt;         1. ~~&lt;span style&#x3D;\&quot;color: red\&quot;&gt;いつもの情報クレジットカード1予約基本情報の一般用クレジットカード1およびいつもの情報クレジットカード2一般用クレジットカード2のクレジットカード番号に、リクエストパラメータのクレジットカード番号が合致しない。&lt;/span&gt;、かつ予約基本情報の一般用クレジットカード1および一般用クレジットカード2のクレジットカード名称に、リクエストパラメータのクレジットカード登録名称が合致しない。~~&lt;br/&gt;     1. 「予約基本情報」の登録、更新が成功した場合、登録、更新した内容と同じ内容でASWDB(Tx)のパーソナライズ情報の更新を行う。 &lt;!-- list end --&gt;  # 3.データ更新内容&lt;br/&gt; ## 1.PNR&lt;br/&gt; | 更新フィールド  | 更新内容 | データ取得元 | 条件等 | | :------------- | :------------- | :------------- | :------------- | | FP | クレジット支払情報、クレジット関連情報&lt;br/&gt;(DxAPIの仕様に従う)  |&lt;ol&gt;&lt;li&gt;リクエストパラメータ&lt;ol&gt;&lt;li&gt;クレジットカード番号&lt;/li&gt;&lt;li&gt;クレジットカード有効期限&lt;/li&gt;&lt;li&gt;クレジットカード名義&lt;/li&gt;&lt;li&gt;セキュリティコード&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;br/&gt;※FPのエレメント長を超える値を登録しようとするとエラーになるため、設定ファイルに定義した新規購入用の長さを超える長さの値の場合は、先頭からその長さ分の文字のみを登録するようにする。|クレジットカードによって全額支払う場合 | | FP | クレジット支払情報、クレジット関連情報、ANA SKYコイン支払情報、&lt;br/&gt;ANA SKYコイン減算対象会員番号、ANA SKYコイン適用額&lt;br/&gt;(PAXリレートする。)|&lt;ol&gt;&lt;li&gt;リクエストパラメータ&lt;ol&gt;&lt;li&gt;クレジットカード番号&lt;/li&gt;&lt;li&gt;クレジットカード有効期限&lt;/li&gt;&lt;li&gt;クレジットカード名義&lt;/li&gt;&lt;li&gt;セキュリティコード&lt;/li&gt;&lt;li&gt;ANA SKYコイン適用額&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;ログインユーザの会員番号&lt;/li&gt;&lt;/ol&gt;&lt;br/&gt;※FPのエレメント長を超える値を登録しようとするとエラーになるため、設定ファイルに定義した新規購入用の長さを超える長さの値の場合は、先頭からその長さ分の文字のみを登録するようにする。 |クレジットカードとANA SKYコインの併用によって支払う場合  | | FP | ANA SKYコイン支払情報、ANA SKYコイン減算対象会員番号、&lt;br/&gt;ANA SKYコイン適用額&lt;br/&gt;(PAXリレートする。)  |&lt;ol&gt;&lt;li&gt;リクエストパラメータ&lt;ol&gt;&lt;li&gt;ANA SKYコイン適用額&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;ログインユーザの会員番号&lt;/li&gt;&lt;/ol&gt; |ANA SKYコインによって全額支払う場合   | | FP&lt;br/&gt;(hiddenフィールド)  | Redemption ID  | |ANA SKYコインによる支払額が存在する場合  | | FP | インターネットバンキング支払情報、金融機関コード、払込期限&lt;br/&gt;※各情報がDxAPIにて\&quot;/\&quot;区切りで結合される。 ||インターネットバンキングによって全額支払う場合  | | FP | コンビニエンスストア支払情報、コンビニエンスストア関連情報、払込期限&lt;br&gt;/※各情報がDxAPIにて\&quot;/\&quot;区切りで結合される。||コンビニエンスストア支払いによって全額支払う場合  | | FP | “PAX” + “ (半角スペース)” ”UPAMP” + 銀聯カード決済番号 + “/” + “A”  &lt;br/&gt;※フォーマットはDxAPIにて自動で登録される。  |  |銀聯によって全額支払う場合  | | FP | “PAX” + “ (半角スペース)” ”APAMP” + Alipay決済番号 + “/” + “A” &lt;br/&gt;※フォーマットはDxAPIにて自動で登録される。  |  |Alipayによって全額支払う場合  | | FP | “PAX” + “ (半角スペース)” ”PPAMP” + PayPal決済番号 + “/” + “A”&lt;br/&gt;※フォーマットはDxAPIにて自動で登録される。  |  |PayPalによって全額支払う場合  | | FT | APFコード  |&lt;ol&gt;&lt;li&gt;ユーザ共通情報&lt;ol&gt;&lt;li&gt;APFコード&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt; |APFサイト利用による購入である場合  | | FZ | “RA” + “ “(半角スペース) + 実績コード  |ASWDB(マスタ)から取得した操作オフィスのPOSと操作時の端末の&lt;br/&gt;組み合わせに応じた実績コード&lt;br/&gt;※端末がTABの場合はSPの実績コードを利用する。| DxAPIで当要素を更新する際は、リクエストヘッダの\&quot;ama-client-facts\&quot;に、以下のJSONデータをBase64エンコードしたものを設定することで実現する。&lt;br/&gt;{\&quot;sub\&quot;:\&quot;fact\&quot;, \&quot;fzelement\&quot;,更新内容に記載の値} | | SSR |  TIME |  | Keep My Fareの場合のみ、DxAPIにて自動で&lt;br/&gt;登録される | | SSR | 搭乗者メールアドレス&lt;br/&gt;コード＝\&quot;CTCE\&quot;&lt;br/&gt;フリーテキスト&#x3D;搭乗者メールアドレス&lt;br/&gt;キャリアコード＝便名キャリアコード&lt;/br&gt;(PAXリレートする。)&lt;br/&gt;※旅程の全便名キャリア分登録する | カートのextensionsの搭乗者メールアドレス | | | SK | 代表者メールアドレス&lt;br/&gt;フォーマットはキーワード ＝ MAIL、&lt;br/&gt;フリーテキスト ＝ “A” + 言語コード + “T” + メールアドレス&lt;br/&gt;(PAXリレートする。)&lt;br/&gt;※PNRに登録された1人目の搭乗者にリレートする。 | &lt;ol&gt;&lt;li&gt;カートのextensionsの代表者メールアドレス&lt;/li&gt;&lt;li&gt;ユーザ共通情報の言語コード&lt;/li&gt;&lt;/ol&gt; |  | | SK | 搭乗者メールアドレス&lt;br/&gt;フォーマットはキーワード ＝ MAIL、&lt;br/&gt;フリーテキスト ＝ “P” + 言語コード + “T” + メールアドレス&lt;br/&gt;(PAXリレートする。) | &lt;ol&gt;&lt;li&gt;カートのextensionsの搭乗者メールアドレス&lt;/li&gt;&lt;li&gt;ユーザ共通情報の言語コード&lt;/li&gt;&lt;/ol&gt;  |  | | RM | 発着通知メールアドレス&lt;br/&gt;フォーマットはフリーテキスト &#x3D; \&quot;//MAIL\&quot; + “D” + 言語コード + “T” + メールアドレス + “:”(コロン) + メール受取人名&lt;br/&gt;(PAXリレートする。)&lt;br/&gt;※フリーテキストに加えて、DxAPIのリクエスト項目としてcategoryに\&quot;L\&quot;を指定する。| &lt;ol&gt;&lt;li&gt;カートのextensions&lt;ol&gt;&lt;li&gt;発着通知メールアドレス&lt;/li&gt;&lt;li&gt;メール受信者名&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;ユーザ共通情報の言語コード&lt;/li&gt;&lt;/ol&gt;  |  | | OPC | 購入期限(TL)&lt;br/&gt;(Keep My Fareの場合は、設定ファイルで管理するKeep My Fareホールド時間と同じ時間が設定される。支払方法がインターネットバンキングまたは&lt;br/&gt;コンビニエンスストア支払いの場合は、&lt;br/&gt;操作日+支払方法に応じた日数の値が再設定される)|  | DxAPIにて自動で更新される | | TKTL | DxAPIの設定に従った保持期限 |  | 支払方法がインターネットバンキング・コンビニエンスストア支払いの場合、DxAPIにて自動で登録される | | RM | “@FF” + “ “(半角スペース) + “FareFamilyのShort Name(FFコード)”&lt;br/&gt;(SEGリレートする。) |当該セグメントのFareFamily  |購入処理実行時、FareFamilyがDxAPIから取得できた場合のみ登録する。&lt;br/&gt;購入する旅程のセグメント数分登録する。 | | RM | “@SKYCOIN”&lt;br/&gt;(PAXリレートする。) | | ANA SKYコインを適用するPAX(大人、ヤングアダルト、小児)にのみ登録する。&lt;br/&gt;※同伴幼児有のPAXは、大人、ヤングアダルトまたは同伴幼児のいずれかに適用されている場合に登録する。| | &lt;span style&#x3D;\&quot;color: red ;\&quot;&gt;RM&lt;/span&gt; |&lt;span style&#x3D;\&quot;color: red ;\&quot;&gt;“SKYLINK” + ”/” + ”P” + ”/” + 予約番号 + “/” + カウチ種別(カウチ登録時のSSRコード) + “/” + 座席番号(※1) + “/” + カウチ用NCP作成要否(※2) + “//” + NCP座席番号(※3) &lt;br/&gt;(SEG、PAXリレートする。) &lt;br/&gt;※1 1カウチに対する利用人数分の座席番号を設定する。&lt;br/&gt;複数座席存在する場合は、代表者の座席から順に列挙し、”,”区切りとする。&lt;br/&gt;※2 カウチ用NCPの作成要否に応じて値を設定する。1カウチ席の座席数 ＞ 当該カウチ席利用人数の場合は”B”(カウチ用NCP作成前)を設定、”B”ではない場合、”N”(カウチ用NCP作成不要)を設定する。&lt;br/&gt;※3 カウチ用NCP作成要の場合のみ設定する。1カウチ席内に属する座席について、搭乗者が割り当てられていない座席番号を”,”区切りで列挙する。&lt;/span&gt;|&lt;span style&#x3D;\&quot;color: red ;\&quot;&gt;PNRに登録済みのカウチ情報&lt;/span&gt;|&lt;span style&#x3D;\&quot;color: red ;\&quot;&gt;カウチ席利用時のみ登録する。&lt;br/&gt;※ リレートする搭乗者は、カウチ席を利用する代表者、同席者となる全ての搭乗者とする。&lt;/span&gt;|  ## 2.ASWDB(Tx)&lt;br/&gt; | 更新テーブル  | 更新内容 | データ取得元 | 条件等 | | :------------- | :------------- | :------------- | :------------- | | 予約購入実績 | 実績内容  | &lt;ol&gt;&lt;li&gt;リクエストパラメータ&lt;/li&gt;&lt;li&gt;PNR&lt;/li&gt;&lt;li&gt;ユーザ共通情報&lt;/li&gt;&lt;/ol&gt; | | | 社員紹介実績 | 実績内容  | &lt;ol&gt;&lt;li&gt;リクエストパラメータ&lt;/li&gt;&lt;li&gt;PNR&lt;/li&gt;&lt;li&gt;ユーザ共通情報&lt;/li&gt;&lt;/ol&gt; | | | プラン | カートIDを基に、プランを削除  | 決済手段区分 | prebook PNRの購入が完了した場合 | | S2パーソナライズ情報 | 更新に成功した予約基本情報と対応する項目  | リクエストパラメータ | 予約基本情報の更新が完了した場合 |  ## 3.カート | 更新フィールド | 更新内容 | データ取得元 | 条件等 | | :-------- | :--------- | :-------- | :-------- | | extensions | キー&#x3D;\&quot;deleted\&quot;(論理削除フラグ)、値&#x3D;\&quot;true\&quot; | - | - |  ## 4.AMC会員情報&lt;br/&gt; | 更新フィールド  | 更新内容 | データ取得元 | 条件等 | | :------------- | :------------- | :------------- | :------------- | | 予約基本情報 | 決済手段区分&lt;br/&gt;※インターネットバンキングによる支払の場合は&lt;br/&gt;指定された銀行の情報も含めて更新する。| リクエストパラメータ  | いつもの情報の支払方法の更新が指定された場合 |           | 予約基本情報 |  一般用クレジットカード有効期限 | リクエストパラメータ  | いつもの情報のクレジットカード情報の有効期限更新が指定された場合 |           | 予約基本情報 | 一般用クレジットカード番号、一般用クレジットカード名称、一般用クレジットカード有効期限  | &lt;ol&gt;&lt;li&gt;リクエストパラメータ&lt;/li&gt;&lt;li&gt;設定ファイル&lt;/li&gt;&lt;/ol&gt;  | いつもの情報のクレジットカード情報新規登録が指定された場合 | &lt;!-- list end --&gt;  # 4.特記事項&lt;br/&gt; 1. 予約基本情報の更新時に更新対象項目のみをMindsへのリクエストとして設定すると、その他の登録済み情報が空で更新されてしまう。&lt;br/&gt;    そのため、Mindsへ予約基本情報の更新を行う際に更新対象外の項目については、既に登録済みの情報をリクエストとして設定する。&lt;br/&gt;  1. 購入/発券時に登録されるTKエレメントの種別はDxAPIの設定によってコントロールする。&lt;br/&gt; 1. &lt;span style&#x3D;\&quot;color: red ;\&quot;&gt;ASWDB(マスタ)に定義するいつもの情報クレジットカードの登録名称は多言語化するが、操作言語が日本である場合に対応するデータは日本語、それ以外の言語に対応するデータは全て英語で定義する。&lt;/span&gt; &lt;!-- list end --&gt;  # ToDo(未決課題) 1. 2.処理内容の項番15および201レスポンスの項番15について、以下未決のため仮修正状態となり、解決後に設計へ反映する必要有。     1. https://asy-pd.backlog.com/view/ANAUIUXS2_DEV-3555 1. 3.データ更新内容の1.PNRに記載のRM SKYLINKについて、仮反映状態。&lt;br/&gt; サービス情報登録APIのレビューがFIX次第、正式に取り込みの必要有。&lt;br/&gt; 1. 2.処理内容の項番8.3.2について、マルチペイメントサービス仕様書1.0.4.pdfの格納場所が正式決定次第、パスを反映する必要有。&lt;br/&gt; 1. 2.処理内容の項番6.8について、CTC様変更影響の確認が取れ次第修正反映を確定。&lt;br/&gt;
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public ordersPaymentRecordsPost(
    generated?: OrdersPaymentRecordsRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<OrdersPaymentRecordsResponse>;
  public ordersPaymentRecordsPost(
    generated?: OrdersPaymentRecordsRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<OrdersPaymentRecordsResponse>>;
  public ordersPaymentRecordsPost(
    generated?: OrdersPaymentRecordsRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<OrdersPaymentRecordsResponse>>;
  public ordersPaymentRecordsPost(
    generated?: OrdersPaymentRecordsRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/orders/payment-records`;
    return this.httpClient.request<OrdersPaymentRecordsResponse>(
      'post',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: generated,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * # 1.概要&lt;br/&gt; DxAPIを呼び出して、PNRに対して指定した運賃計算オプションでの運賃の再計算を行い、再計算結果を返却する。&lt;br/&gt; &lt;!-- list end --&gt;  # 2.処理内容&lt;br/&gt;                     1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、エラーハンドリング(API)(G01-010)を利用して&lt;br/&gt; Mulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返却する。&lt;br/&gt; ※エラー情報には、エラーコードごとにエラー発生項目が含まれる。&lt;br/&gt; &lt;br/&gt; 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br/&gt; 有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; &lt;br/&gt; 1. PNR情報取得APIを呼び出す。&lt;br/&gt; PNR情報取得APIからPNRが取得できなかった場合ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; &lt;br/&gt; 1. PNR情報取得APIにて返却された購入可否が不可の場合、不可理由に応じて以下パターンごとにステータス400(Bad Request)でエラー情報を返して、本処理を中止する。&lt;br/&gt;     1. 発券期限エラー&lt;br/&gt;     1. それ以外&lt;br/&gt; &lt;br/&gt; 1. PNRにCAT25プロモーションコードが適用済みである場合、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; &lt;br/&gt; 1. リクエストパラメータにAAMプロモーション情報が存在する、かつAAMプロモーションコードがASWDB(マスタ)にCAT25プロモーションコードとして存在する場合、&lt;br/&gt; ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; ※ エラー情報には、エラーコードごとにエラー発生項目が含まれる。&lt;br/&gt; &lt;br/&gt; 1. DxAPIを呼び出して、PNRに対して指定した運賃計算オプションでの運賃の再計算を行う。&lt;br/&gt;     1. DxAPIの呼び出し時に、以下いずれかのエラーが返却された場合、400(Bad request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;         1. 運賃再計算失敗エラー&lt;br/&gt;         1. プロモーションコード不正エラー&lt;br/&gt;         1. プロモーションコード適用失敗ワーニング&lt;br/&gt;     1. ステータスコード201(Created)で再計算結果を返却する。 &lt;!-- list end --&gt;  # 3.データ更新内容&lt;br/&gt; なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public ordersRepriceOrderPost(
    generated?: OrdersRepriceOrderRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<OrdersRepriceOrderResponse>;
  public ordersRepriceOrderPost(
    generated?: OrdersRepriceOrderRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<OrdersRepriceOrderResponse>>;
  public ordersRepriceOrderPost(
    generated?: OrdersRepriceOrderRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<OrdersRepriceOrderResponse>>;
  public ordersRepriceOrderPost(
    generated?: OrdersRepriceOrderRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/orders/reprice-order`;
    return this.httpClient.request<OrdersRepriceOrderResponse>(
      'post',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: generated,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * # 1. 概要                 呼び出し元より渡されたプラン情報を基にASWDB(Tx)に対してプランの登録を行う。操作中のカート情報をプランとして登録(1件登録。以降「新規登録」)と、非会員で作成していたプランリストを会員のプランリストにマージ(複数件登録。以降「マージ」)の2つの機能に対してサポートする。また、以下の機能を実現するためのプランの一時保存もサポートする。&lt;br&gt; 1. プランのシェア(以降、シェア)：特定のプランの複製を作成するための機能。当APIで一時保存したプランを、任意の端末で複製を可能とするために一時保存を行う。&lt;br&gt;    1. 他端末へのプランの引継ぎ(以降、端末引継ぎ)：ユーザ端末に保存されているプランリストを他端末へコピーするための機能。当APIで一時保存したプランリストを、他端末から取得させるために一時保存を行う。&lt;br&gt;    1. deeplink：特定のプランに対して任意の端末からそのプランのプラン確認画面に直接流入する機能。当APIで一時保存したプランを、任意の端末から取得させるために一時保存を行う。&lt;br&gt;  プランの登録は、ログイン中のAMC会員番号に紐づける形で登録を行う。一時保存を行う場合は、会員番号の代わりに一時保存用の会員番号を発行し、その一時会員番号に紐づける形で登録を行う。&lt;br&gt; また、一時会員番号にて登録したデータは有効期限(設定ファイルに定義)を設定し、有効期限が過ぎたら利用不可にする。 &lt;br&gt; prebook済みプランをプランテーブルへ追加する際は、プラン登録上限数に含めずASWDB(Tx)へ登録を行う。&lt;br&gt;  # 2. 処理内容                 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、エラーハンドリングAPI(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。&lt;br&gt;  1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。&lt;br&gt;   1. リクエストパラメータで指定されたプランのカートIDより、DxAPIを実行しカートのextensionsよりカート作成日時を取得する。カート作成日時が取得できなかった場合、不正なカートIDが指定されたとみなし、HTTPステータスコード400(Bad Request)を返却し、処理を中止する。  1. 処理種別が新規追加、マージ、の場合、呼び出し元より渡されたアクセストークンを復号し、トークン内に含まれるuuidを基に、ASWDB(Tx)からログイン中の会員情報を取得する。AMC会員番号を取得できなかった場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。&lt;br&gt;  1. 処理種別が新規追加の場合、AMC会員番号をキーに、指定されたプランをASWDB(Tx)に登録する。ただし、以下のいずれかに該当する場合、HTTPステータスコード400(Bad Request)を返却し、処理を中断する。       1. リクエストパラメータで指定されたカートIDが複数件の場合&lt;br&gt;   1. prebook済みプランでない場合、ASWDB(Tx)からAMC会員の登録済みプラン数(※)を取得し、追加プラン数（1件）を含めたプラン合計数を算出し、プラン合計数がプラン登録上限（設定ファイルより取得）を超過する場合&lt;br&gt;   ※登録済みプラン数はプラン有効期限切れのプラン、またはprebook済みプランを除外してカウントする。&lt;br&gt; 1. 処理種別がマージの場合、AMC会員番号をキーに、指定されたプランを全件ASWDB(Tx)に登録する。但し、ASWDB(Tx)からAMC会員の登録済みプラン数(※)を取得して、非会員状態で作成したprebook済みプランを除いたプラン数よりプラン合計数を算出(※)し、 プラン合計数がプラン登録上限（設定ファイルより取得）を超過する場合は、リクエストのプランリストのプラン作成日が新しい順から超過しない件数分をASWDB(Tx)に登録する。&lt;br&gt; prebook済みプランがなく、プラン登録上限数を超過した結果、1件も登録できなかった場合はHTTPステータスコード400(Bad Request)を返却し、本処理を中止する。&lt;br&gt; ※登録済みプラン数はプラン有効期限切れのプラン、またはprebook済みプランを除外してカウントする。&lt;br&gt; 1. 処理種別が端末引継ぎの場合、引継ぎ対象のプランを特定するための一時会員番号を\&quot;MIG\&quot; + 半角英数字16文字のランダム文字列にて生成し、その一時会員番号をキーに指定されたプランを全件ASWDB(Tx)に登録する。 &lt;br&gt; 1. 処理種別がdeeplinkの場合、以下の処理を行う。           1. 呼び出し元より渡されたアクセストークンを復号し、トークン内に含まれるuuidを基に、ASWDB(Tx)からログイン中の会員情報を取得する。&lt;br&gt;   ※会員による操作の場合、ASWDB(Tx)にdeeplinkを作成する会員番号を登録するために会員情報の取得を行う。    1. deeplinkのプランを特定するための一時会員番号を\&quot;DPL\&quot;(deeplinkを表す接頭辞) + 半角英数字16文字のランダム文字列にて生成し、その一時会員番号をキーに指定されたプランをASWDB(Tx)に登録する。 1.処理種別がシェアの場合、シェア対象のプランを特定するための一時会員番号を\&quot;SHR\&quot;(シェアを表す接頭辞) + 半角英数字16文字のランダム文字列にて生成し、その一時会員番号をキーに指定されたプランをASWDB(Tx)に登録する。  1. HTTPステータスコード201(Created)を返却し、本処理を終了する。       # 3. データ更新項目 1. ASWDB(Tx)           | 更新テーブル | 更新内容 | データ取得元 | 条件等 | | :------ | :------ | :------ | :------ | | プラン | 処理種別により、以下の登録を行う。&lt;br&gt;1. AMC会員番号:新規追加、マージの場合、ユーザ共通により取得したAMC会員番号、それ以外の場合、当処理で生成した一時会員番号&lt;br&gt;2. カートID: リクエストにて指定された値&lt;br&gt;3. プラン名称: リクエストにて指定された値&lt;br&gt;4. プラン有効期限:extensionsより取得したカート作成日時+設定ファイルより取得した値&lt;br&gt;5. プラン作成日時:extensionsより取得したカートIDに紐づくカート作成日時&lt;br&gt;6. プラン更新日時:extensionsより取得したカートIDに紐づくカート作成日時&lt;br&gt;7. prebook済みであるかどうか:extensionsにprebook有効期限が登録されていた場合、true&lt;br&gt;8. prebook有効期限:extensionsより取得&lt;br&gt;9. deeplink作成者AMC会員番号:deeplinkで共通よりログイン情報が取得できた場合のみ、ログインしているユーザのAMC会員番号&lt;br&gt;10. TTL:現在日付(GMT)+設定ファイルより取得した値 | リクエストパラメータ&lt;br&gt;カート&lt;br&gt;設定ファイル | - |  # 4. 特記事項 1. 設定ファイルに定義するFY23リリース時点におけるプラン保存上限数は10件とする。   1. 設定ファイルに定義するFY23リリース時点におけるプラン有効期限は90日とする。
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public plansCreatePlansPost(
    generated?: PlansCreatePlansRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<PlansCreatePlansResponse>;
  public plansCreatePlansPost(
    generated?: PlansCreatePlansRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<PlansCreatePlansResponse>>;
  public plansCreatePlansPost(
    generated?: PlansCreatePlansRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<PlansCreatePlansResponse>>;
  public plansCreatePlansPost(
    generated?: PlansCreatePlansRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/plans/create-plans`;
    return this.httpClient.request<PlansCreatePlansResponse>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要                 リクエストパラメータに紐づくプラン(1件または複数件)をASWDB(Tx)から削除し、カートの論理削除を行う。 当APIでは、端末引継ぎの場合に、端末引継ぎ後のプランリストの削除を行うためにも利用する。この場合、カートの論理削除は行われない。  # 2. 処理内容                 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、エラーハンドリングAPI(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。                1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。                  1. リクエストパラメータについて以下に合致する場合、指定したHTTPステータスコードを返却し、処理を中止する。          1. 削除対象一時会員番号とカートIDが同時に指定されている場合、HTTPステータスコード400(Bad Request)を返却する                   1. 削除対象一時会員番号の先頭3文字が\&quot;MIG\&quot;でない場合、HTTPステータスコード400(Bad Request)を返却する               1. 指定されたカートIDが設定ファイルで定めた上限件数を超過している場合、HTTPステータスコード500(Server Error)を返却する               1. リクエストパラメータの削除対象一時会員番号が指定された場合、削除対象一時会員番号を基にASWDB(Tx)に登録されているプランリストの削除を行う。                                1. リクエストパラメータのカートIDが指定された場合、以下の処理を繰り返し行う。                   1. リクエストパラメータのカートIDに紐づくASWDB(Tx)のプランがある場合、該当のプランを削除する。   1. リクエストパラメータのカートIDよりDxAPIを呼び出し、カートのextensionsに論理削除フラグを登録する。   ※カート更新時、プラン更新日時は更新しない 1. 上記処理の完了後、HTTPステータスコード204(Deleted)を返却し、処理を終了する。    # 3. データ更新項目 1. カート | データ更新項目 | 更新内容 | データ取得元 | 条件等 |                 | :-------- | :--------- | :-------- | :-------- |                 | extensions | キー&#x3D;\&quot;deleted\&quot;(論理削除フラグ)、値&#x3D;\&quot;\&quot;(空白) | - | - |          1. ASWDB(Tx)           | 更新テーブル | 更新内容 | データ取得元 | 条件等 |                | :-------- | :--------- | :-------- | :-------- |                 | プランリスト | 1. 削除対象一時会員番号を基に、プランリストを削除&lt;br&gt;2. カートIDを基に、プランを削除 | リクエストパラメータ | - |
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public plansDeletePlansDelete(
    generated?: PlansDeletePlansRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<PlansDeletePlansResponse>;
  public plansDeletePlansDelete(
    generated?: PlansDeletePlansRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<PlansDeletePlansResponse>>;
  public plansDeletePlansDelete(
    generated?: PlansDeletePlansRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<PlansDeletePlansResponse>>;
  public plansDeletePlansDelete(
    generated?: PlansDeletePlansRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/plans/delete-plans`;
    return this.httpClient.request<PlansDeletePlansResponse>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要 リクエスト項目を取得し、見積もりPDFを生成する。  # 2. 機能前提 PDF生成に必要な情報は、当APIの呼び出し時に言語に応じたフォーマット済の状態で連携されるものとする。&lt;br/&gt; リクエスト項目で取得した値以外はPDF出力しないものとする。&lt;br/&gt;  # 3. 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 　エラー情報には、エラーコードごとにエラー発生項目を含めるようにする。&lt;br/&gt;  1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br/&gt; 有効でない場合、HTTPステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。      1. リクエスト項目を取得し、共通部品「PDF生成サービス接続」(G03-511)を用いて見積もりPDFを生成する。生成できない場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 各帳票出力項目のタイトル及び重要なお知らせは、静的文言より取得する。&lt;br/&gt; ※PDFのフォーマットは【外部設計書】R01-P041_お見積り 1.2画面項目説明 1.2.1.1画面イメージを参照  1. 正常終了の場合、HTTPステータスコード200(OK)を返却し、本処理を終了する。  # 4.データ更新内容 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public plansGetEstimationPost(
    generated?: PlansGetEstimationRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<PlansGetEstimationResponse>;
  public plansGetEstimationPost(
    generated?: PlansGetEstimationRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<PlansGetEstimationResponse>>;
  public plansGetEstimationPost(
    generated?: PlansGetEstimationRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<PlansGetEstimationResponse>>;
  public plansGetEstimationPost(
    generated?: PlansGetEstimationRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/plans/get-estimation`;
    return this.httpClient.request<PlansGetEstimationResponse>(
      'post',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: generated,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * # 1. 概要&lt;br&gt; AMC会員番号、もしくは一時会員番号にてASWDB(Tx)よりプランリスト情報を取得し、呼び出し元に返却する。&lt;br&gt;         AmadeusカートについてはカートIDのみ返却し、プランの詳細は返却しない。         プランの詳細を取得するためには当エンドポイントにて返却するカートIDを基に、カート取得APIを利用する。&lt;br&gt;       当APIではdeeplink(特定のプランに対して任意の端末からそのプランのプラン確認画面に直接流入する機能)利用時のプラン取得もサポートする。&lt;br&gt;         また、非会員のプランに対する搭乗者情報の取り扱いが異なる(会員では搭乗者情報を保持するが、非会員ではクリアする)ため、deeplink利用においては、AMC会員が作成したdeeplinkのプランを非会員が利用すること、およびその逆も制限する。 &lt;br&gt;        また、当APIでは、ユーザ端末に保存されているプランリストを他端末へコピー(端末引継ぎ)、および特定のプランを複製(シェア)する際、ASWDB(Tx)に一時保存したプランリストを取得するためにも利用する。 &lt;br&gt; これらの取得を行う際は有効期限が切れたプランを利用不可とするため、該当のプランをプランリストから除外する。&lt;br&gt;         なお、シェアについては当APIが返却するプラン情報を基に別途登録処理を行うことによって複製を行うものとし、当APIでは登録に必要な情報の返却のみを行うものとする。&lt;br&gt;&lt;br&gt;  ### 【アクセス情報】&lt;br&gt; ASWTOPからの呼び出しは、以下のURLとする。   | 環境 | URL |  | :--- | :--- |  | 本番 | https://prd-space.ana.co.jp/aswbe-reservation/api/v1/plans/get-plans |  | ステージング | https://stg.test.space.ana.co.jp/aswbe-reservation/api/v1/plans/get-plans |  | 開発 | https://dev.test.space.ana.co.jp/dev1/aswbe-reservation/api/v1/plans/get-plans&lt;br&gt;https://dev.test.space.ana.co.jp/dev2/aswbe-reservation/api/v1/plans/get-plans&lt;br&gt;https://dev.test.space.ana.co.jp/dev3/aswbe-reservation/api/v1/plans/get-plans&lt;br&gt;https://dev.test.space.ana.co.jp/dev4/aswbe-reservation/api/v1/plans/get-plans&lt;br&gt;https://dev.test.space.ana.co.jp/dev5/aswbe-reservation/api/v1/plans/get-plans |  # 2. 処理内容                1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、エラーハンドリングAPI(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。 &lt;br&gt;        1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。有効でない場合、HTTPステータスコード 401(unauthorized)を返して、本処理を中止とする。 &lt;br&gt;        1. リクエストパラメータの一時会員番号が指定されている場合、以下の処理を行う。&lt;br&gt;   1. 一時会員番号を元に、ASWDB(Tx)よりプランリストを取得する。           1. 一時URLの有効期限が切れていないかを検査する。一時URLの有効期限が切れていた場合、HTTPステータスコード400(Bad Request)を返却し、処理を中断する。           1. プラン有効期限が切れていないかを検査する。プラン有効期限が切れていた場合、HTTPステータスコード400(Bad Request)を返却し、処理を中断する。           1. 一時会員番号の先頭が\&quot;DPL\&quot;(deeplinkを表す接頭辞)の場合、呼び出し元より渡されたアクセストークンを復号し、トークン内に含まれるuuidを基に以下の処理を行う。             1. トークン内のuuidに紐づくログイン情報をASWDB(Tx)より取得し、以下いずれかに合致する場合はHTTPステータスコード400(BadRequest)を返却し、処理を中断する。                1. ログイン情報が存在せず、会員が作成したプランのdeeplinkである                1. ログイン情報が存在し、ログイン中の会員番号とdeeplink作成会員番号が一致しない、またはdeeplink作成会員番号が存在しない             1. ログイン情報が存在する場合、AMC会員番号と、上記で取得したプランリスト(1件)のカートIDを基にプランリストを取得し、プランリストを上書きする。           ※ 会員の場合はdeeplink作成時のプラン情報ではなく、最新のプラン情報を返却するため再取得を行う。         1.  一時会員番号が指定されていない場合、以下の処理を行う。           1. 呼び出し元より渡されたアクセストークンを復号し、トークン内に含まれるuuidを基に、ASWDB(Tx)からログイン中の会員情報を取得する。会員情報を取得できなかった場合、HTTPステータスコード401(unauthorized)を返して、本処理を中止する。           1. 取得した会員番号から、ASWDB(Tx)よりプランリストを取得する。           1. 取得したプランリスト内の有効期限が現在時刻(GMT)を超過している場合は、該当プランを取得したプランリストから除外する。         1. 上記処理の完了したプランリストのうち、prebook有効期限切れのプランに対して、prebook済フラグをfalse、prebook有効期限を空に更新する。 また、プラン未保存の場合、該当プランをプランリストから除外する。         1. 上記処理の完了したプランリストを、HTTPステータスコード200(OK)と共に返却し、本処理を終了する。  # 3. データ更新項目 1. ASWDB(Tx) | 更新テーブル | 更新内容 | データ取得元 | 条件等 | | :------ | :------ | :------ | :------ | | プラン | prebook有効期限切れのプランの場合、prebook済フラグをfalse、prebook有効期限を空に設定 | - | - |
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public plansGetPlansPost(
    generated?: PlansGetPlansRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<PlansGetPlansResponse>;
  public plansGetPlansPost(
    generated?: PlansGetPlansRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<PlansGetPlansResponse>>;
  public plansGetPlansPost(
    generated?: PlansGetPlansRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<PlansGetPlansResponse>>;
  public plansGetPlansPost(
    generated?: PlansGetPlansRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/plans/get-plans`;
    return this.httpClient.request<PlansGetPlansResponse>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要   AMC会員のASWDB(Tx)に保存されているプランの名称の変更を行う。    # 2. 処理概要 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、エラーハンドリングAPI(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。   1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。有効でない場合、HTTPステータスコード401(unauthorized)を返して、本処理を中止とする。   1. 呼び出し元より渡されたアクセストークンを復号し、トークン内に含まれるuuidを基に、ASWDB(Tx)からログイン中の会員情報を取得する。取得できなかった場合、HTTPステータスコード401(unautorized)を返して、本処理を中止とする。   1. リクエストパラメータを基に、ASWDB(Tx)に保存されているプラン名称の変更を行う。但し、リクエストパラメータで指定したプランが見つからなかった場合、HTTPステータスコード400(Bad Request)を返却し、本処理を中止する。   1. 上記処理後、HTTPステータスコード200(OK)を返却し、処理を終了する。   # 3. データ更新項目 1. ASWDB(Tx)&lt;br&gt; | 更新テーブル | 更新内容 | データ取得元 | 条件等 | | :------ | :------ | :------ | :------ | | プランリスト | リクエストパラメータより取得したカートIDより、プラン名称とプラン更新日時を更新する | リクエストパラメータ | なし |
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public plansUpdatePlannamePatch(
    generated?: PlansUpdatePlannameRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<PlansUpdatePlannameResponse>;
  public plansUpdatePlannamePatch(
    generated?: PlansUpdatePlannameRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<PlansUpdatePlannameResponse>>;
  public plansUpdatePlannamePatch(
    generated?: PlansUpdatePlannameRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<PlansUpdatePlannameResponse>>;
  public plansUpdatePlannamePatch(
    generated?: PlansUpdatePlannameRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/plans/update-planname`;
    return this.httpClient.request<PlansUpdatePlannameResponse>(
      'patch',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: generated,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * # 1. 概要   ANA Bizログイン中の出張者が指定可能な承認者のリストを返却する。    # 2. 処理内容   1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。   有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。   1. 呼び出し元より渡されたアクセストークンを復号し、トークン内に含まれるuuidを基に、ASWDB(Tx)からパーソナライズ情報を取得する。    1. パーソナライズ情報のANA Biz企業情報について、企業情報が存在しない場合、ANA Biz未ログインとし、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。   1. パーソナライズ情報のANA Biz企業情報について、「発券要求機能使用」が「使用する」でない場合、権限チェックエラーとし、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。   1. ANA Biz APIの企業情報の取得(承認者一覧取得)処理を呼び出し、ANA Bizログインユーザ情報の企業の承認者リストを取得する。   1. HTTPステータス200(OK)を返して、処理を終了する。    # 3. データ更新内容   なし    # 4. 特記事項   なし

   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public ordersAnaBizGetApproversPost(
    generated?: object,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<OrdersAnaBizGetApproversResponse>;
  public ordersAnaBizGetApproversPost(
    generated?: object,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<OrdersAnaBizGetApproversResponse>>;
  public ordersAnaBizGetApproversPost(
    generated?: object,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<OrdersAnaBizGetApproversResponse>>;
  public ordersAnaBizGetApproversPost(
    generated?: object,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/orders/ana-biz/get-approvers`;
    return this.httpClient.request<OrdersAnaBizGetApproversResponse>(
      'post',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: generated,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
     * # 1. 概要   ANA Bizの発券要求機能における発券要求差戻を行う。差戻後は、PNRの代表者メールアドレス宛に、発券否認メールを送信する。   # 2. 処理内容   1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、エラーハンドリング(API)(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返却する。   ※ エラー情報には、エラーコードごとにエラー発生項目が含まれる。   1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。   有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。   1. 呼び出し元より渡されたアクセストークンを復号し、トークン内に含まれるuuidを基に、ASWDB(Tx)からパーソナライズ情報を取得する。   1. パーソナライズ情報のANA Biz企業情報について、企業情報が存在しない場合、ANA Biz未ログインとし、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。   1. ANA Biz APIの企業情報の取得(A票情報の取得)処理を呼び出し、最新の企業情報(A票)を取得する。取得した最新の企業情報(A票)の契約形態がパーチェシングサービス(\&quot;P\&quot;)の場合は企業情報の取得(C票情報の取得)処理を呼び出し、最新の企業情報(C票)を取得する。   1. 最新の企業情報(A票)の契約形態がパーチェシングサービス(\&quot;P\&quot;)の場合は最新の企業情報(C票)、それ以外の場合は最新の企業情報(A票)について、以下いずれかに合致する場合、ANA Biz利用停止とし、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。     1. 一時停止フラグが「JCB与信停止」または「発券停止」     1. 解約日≦操作日   1. 以下いずれかに合致する場合、ANA Biz権限チェックエラーとし、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。   1. ANA Bizログインユーザ情報の承認者権限フラグが「権限あり」でない(ログインユーザが承認者でない)     1. 発券状況区分が「発券要求中」の発券要求の承認者が、ANA Bizログインユーザ情報のユーザIDと一致しない、かつ以下いずれかの条件を満たす       1. ANA Bizログインユーザ情報の管理ユーザ情報の承認対象企業精算CD(組織)が値なし(全体承認権限を保持している)、かつ最新の企業情報(C票)の他組織閲覧制限が「制限する」である       1. ANA Bizログインユーザ情報の管理ユーザ情報の承認対象企業精算CDと、かつ最新の企業情報(C票)の企業精算CDが一致していない   1. ANA Bizのログインユーザ情報がシームレスログイン以外、かつ最新の企業情報(A票)のイントラネット接続限定フラグが「限定する」である   1.最新の企業情報の発券要求機能使用判定が「使用する」ではない。   1. 予約情報取得APIを呼び出す。   予約情報取得APIからPNRが取得できなかった場合ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。   1. 予約情報取得APIにて返却された購入可否が不可の場合、不可理由に応じて以下パターンごとにステータス400(Bad Request)でエラー情報を返して、本処理を中止する。     1. 発券期限エラー     1. それ以外   1. 処理区分に「発券要求情報1件取得」、ロールに「承認者」を指定してANA Biz APIの発券要求取得処理を呼び出し、同一予約に対する発券要求情報リストを取得する。   1. 同一予約に対する発券要求情報リストが1件以上存在し、発券状況区分が「発券要求中」のものが存在しない場合、発券要求の発券状況区分エラーとし、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。   1. ANA Biz APIの発券要求更新処理を呼び出し、発券要求中の発券要求の発券状況区分を「否認済」に更新する。   1. PNRの代表者メールアドレス宛に、発券否認メールの送信をCASへリクエストする。リクエストが失敗した場合、発券否認メールリクエスト失敗ワーニングとする。   1. ASWDB(Tx)に予約購入実績を登録する。登録が失敗した場合、予約購入実績登録失敗ワーニングとする。    1. HTTPステータス201(Created)を返して、処理を終了する。    # 3. データ更新内容   1. ASWDB(Tx)           | 更新テーブル  | 更新内容 | データ取得元 | 条件等 |   | ------------- | ------------- | ------------- | ------------- |   | 予約購入実績 | 実績内容  | 1. リクエストパラメータ&lt;br&gt;2. PNR&lt;br&gt;3. ユーザ共通情報 | - | 1. ANA Biz DB (ANA Biz API経由で登録)   | 更新テーブル  | 更新内容 | データ取得元 | 条件等 |   | ------------- | ------------- | ------------- | ------------- |   | 発券要求管理テーブル | 1. 処理区分&lt;br&gt;2. 企業情報(企業CD、企業精算CD)&lt;br&gt;3. 予約番号&lt;br&gt;4. 発券要求日時&lt;br&gt; 5. コメント&lt;br&gt;6. 承認者(承認者ID、承認者名)&lt;br&gt;7. 発券状況区分&lt;br&gt;8. 発券否認日時 | 1. 「発券要求の更新」&lt;br&gt;2. パーソナライズ情報のANA Biz企業情報&lt;br&gt;3. PNR&lt;br&gt;4. 更新対象の発券要求の発券要求日時&lt;br&gt;5. リクエストパラメータ&lt;br&gt;6. ANA Bizログインユーザ情報&lt;br&gt;7. 「否認済」&lt;br&gt;8. 操作日時(JST) | - |     # 4. 特記事項   なし
  
     * @param generated
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
  public ordersAnaBizSendBackTicketingRequestPost(
    generated?: OrdersAnaBizSendBackTicketingRequestRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<OrdersAnaBizSendBackTicketingRequestResponse>;
  public ordersAnaBizSendBackTicketingRequestPost(
    generated?: OrdersAnaBizSendBackTicketingRequestRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<OrdersAnaBizSendBackTicketingRequestResponse>>;
  public ordersAnaBizSendBackTicketingRequestPost(
    generated?: OrdersAnaBizSendBackTicketingRequestRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<OrdersAnaBizSendBackTicketingRequestResponse>>;
  public ordersAnaBizSendBackTicketingRequestPost(
    generated?: OrdersAnaBizSendBackTicketingRequestRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;
    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/orders/ana-biz/send-back-ticketing-request`;
    return this.httpClient.request<OrdersAnaBizSendBackTicketingRequestResponse>(
      'post',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: generated,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * # 1. 概要   ANA Bizの発券要求機能における発券要求を行う。   1. 当APIは、プランから作成したprebook PNRに対する発券要求と、予約のみ/空席待ち予約によって予約済みのPNRに対する発券要求の2つをサポートする。   prebook PNRの発券要求の際は、プランの削除を同時に行うため、呼び出し元より予約番号とカートIDの両方を指定してもらうものとし、DxAPIによるprebook PNRの予約確定後に以下も同時に行う。     1. プランに保存されている代表者、搭乗者、発着通知メールの登録 (prebook時に登録されてしまうとメールが送信されてしまうため、PNRが確定してから登録を行う)      1. プランの削除   1. DxAPIに対する発券要求は、prebook PNRに付与されているTKXLを削除し、ATLを利用してOPCを付与するだけとなる。予約のみ、および空席待ち予約から発券要求を行った場合は、OPCの再設定となる。   1. 発券要求完了後、発券要求メールを送信する。   1. 発券要求完了後、企業への予約情報連携URLが存在する場合、そのURLに対してHTTP通信にて予約情報を送信する。    # 2. 処理内容           1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、エラーハンドリング(API)(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返却する。   ※ エラー情報には、エラーコードごとにエラー発生項目が含まれる。   1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。   有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。   1. 呼び出し元より渡されたアクセストークンを復号し、トークン内に含まれるuuidを基に、ASWDB(Tx)からパーソナライズ情報を取得する。   1. パーソナライズ情報のANA Biz企業情報について、企業情報が存在しない場合、ANA Biz未ログインとし、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。   1. 以下いずれかに合致する場合、権限チェックエラーとし、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。     1. ANA Bizログインユーザ情報の管理ユーザ情報が存在する(出張者でない)     1. パーソナライズ情報のANA Biz企業情報について、「発券要求機能使用」が「使用する」でない   1. ANA Biz APIの企業情報の取得(A票情報の取得)処理を呼び出し、最新の企業情報(A票)を取得する。取得した最新の企業情報(A票)の契約形態がパーチェシングサービス(\&quot;P\&quot;)の場合は企業情報の取得(C票情報の取得)処理を呼び出し、最新の企業情報(C票)を取得する。   1. 最新の企業情報(A票)の契約形態がパーチェシングサービス(\&quot;P\&quot;)の場合は最新の企業情報(C票)、それ以外の場合は最新の企業情報(A票)について、以下いずれかに合致する場合、ANA Biz利用停止とし、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。     1. 一時停止フラグが「JCB与信停止」または「発券停止」     1. 解約日≦操作日   1. パーソナライズ情報のANA Biz企業情報の企業管理コード情報について、以下いずれかに合致する場合、不正企業用管理コードエラーとし、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。エラーにはエラーとなったリクエスト項目を含める。     1. 企業用管理テキストリストの1件目の利用区分が「利用する」でない、かつリクエストパラメータの搭乗者リストのうち、企業用管理コード1が存在する搭乗者が存在する     1. 企業用管理テキストリストの2件目の利用区分が「利用する」でない、かつリクエストパラメータの搭乗者リストのうち、企業用管理コード2が存在する搭乗者が存在する     1. 企業用管理テキストリストの3件目の利用区分が「利用する」でない、かつリクエストパラメータの搭乗者リストのうち、企業用管理コード3が存在する搭乗者が存在する     1. 企業用管理テキストリストの4件目の利用区分が「利用する」でない、かつリクエストパラメータの搭乗者リストのうち、企業用管理コード4が存在する搭乗者が存在する     1. リクエストパラメータの搭乗者リストのうち、企業用管理コード4が存在する搭乗者が存在し、その企業用管理コード4が企業用管理プルダウンリストの企業管理CD名称に含まれていない   1. 予約情報取得APIを呼び出す。   予約情報取得APIからPNRが取得できなかった場合ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。   1. 予約情報取得APIにて返却された購入可否が不可の場合、不可理由に応じて以下パターンごとにステータス400(Bad Request)でエラー情報を返して、本処理を中止する。     1. 発券期限エラー     1. それ以外   1. パーソナライズ情報のANA Biz企業情報について、「予約時1PAX限定フラグ」が「限定する」に設定されている、かつPNRの搭乗者数(同伴幼児除く)が2人以上の場合、予約時1PAX限定エラーとし、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。   1. パーソナライズ情報のANA Biz企業情報について、「AMC会員限定フラグ」が「限定する」に設定されている、かつ以下いずれかに合致する場合、AMC会員限定エラーとし、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。      1. AMC未ログイン     1. ログインユーザのAMC会員番号が、予約情報の搭乗者の会員番号(SSR FQTSまたはSSR FQTV)に含まれない   1. 処理区分に「発券要求情報1件取得」、ロールに「出張者」を指定してANA Biz APIの発券要求処理を呼び出し、同一予約に対する発券要求情報リストを取得する。   1. 同一予約に対する発券要求情報リストが1件以上存在し、発券状況区分が「否認済」以外のものが存在する場合、発券要求の発券状況区分エラーとし、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。   1. 同一予約に対する発券要求情報リストが存在しない場合、DxAPI(ticketing-arrangements/replacement)を呼び出し、以下の内容でATLによって発券要求期限を設定する。             1. リクエストにカートIDが存在する場合、actionに「none」を指定し、Prebookで付与されるTKXLを削除して、TKOKを付与する。             1. 上記以外の場合、xxxxする。   1. ANA Biz APIの発券要求更新処理を呼び出す。同一予約に対する発券要求情報リストが存在する場合でも、情報の追加登録を行う。処理が失敗した場合、発券要求更新処理失敗ワーニングとする。   1. リクエストにカートIDが存在する場合、DxAPI（special-keywords）を呼び出し、条件に応じた以下のSKを登録する。登録に失敗した場合、SK登録失敗ワーニングとする。     1. アイきっぷ運賃(設定ファイルに定義したFare basisの下2桁と合致する)を含み、以下のいずれかに合致する(アイきっぷ利用条件不足とする)場合、SK NNBP       1. AMC未ログイン       1. 会員番号(SSR FQTSまたはSSRS FQTV)にAMC番号が登録されていない搭乗者(同伴幼児は除く)が存在する       1. 離島カード番号が登録されていない搭乗者(同伴幼児は除く)が存在する       1. 離島カード番号の適用可能路線が、アイきっぷ運賃のセグメントの出発空港の都市、到着空港の都市と一致しない搭乗者(同伴幼児は除く)が存在する       1. 離島カード番号の有効期限が、アイきっぷ運賃のセグメントの出発日時点で有効期限内でない搭乗者(同伴幼児は除く)が存在する     1. 身体障がい者運賃(設定ファイルに定義したFare basisの下2桁と合致する)を含み、以下のいずれかに合致する(身体障がい者運賃利用条件不足とする)場合、SK NNBP       1. AMC未ログイン       1. 会員番号(SSR FQTSまたはSSRS FQTV)にAMC番号が登録されていない搭乗者(同伴幼児は除く)が存在する       1. 障がい者手帳の情報が登録されておらず、障がい者割引搭乗者種別が「障がい一種または二種」「精神障がい障がい者」の搭乗者(同伴幼児は除く)が存在する   1. パーソナライズ情報のANA Biz企業情報の契約形態がカードレス(\&quot;P\&quot;または\&quot;BPS\&quot;)の場合、SK BIZJ     1. パーソナライズ情報のANA Biz企業情報の契約形態が板カード(\&quot;P\&quot;、\&quot;BPS\&quot;でない)の場合、SK BIZC     1. 以下のSK MAIL(リクエストパラメータのカートIDに紐づくプラン情報のextensionsから以下のメールアドレスを取得して登録)       1. 代表者(extensionsのキー：contacts)       1. 搭乗者(extensionsのキー：travelars)   1. リクエストにカートIDが存在し、リクエストパラメータのカートIDに紐づくプラン情報のextensionsに発着通知メールアドレスが存在する場合、DxAPI（remarks）を呼び出し、発着通知メールアドレスを登録する。登録に失敗した場合、RM登録失敗ワーニングとする。    1. ANA Biz DBの管理ユーザテーブルに登録されている承認者のメールアドレス宛に、発券要求メールの送信をCASへリクエストする。リクエストが失敗した場合、発券要求メールリクエスト失敗ワーニングとする。   1. リクエストにカートIDが存在し、ANA Bizログインユーザ情報に企業への予約情報連携URLが存在する場合、そのURLに対してHTTPS通信にて予約情報を送信(※)する。送信する情報の形式はXMLとし、以下の内容を送信する。送信に失敗した場合、ANA Biz APIの未送信データ登録処理を呼び出し、送信失敗した情報をANA Biz DBへ登録する。登録時は、送信失敗したXMLをそのまま登録する。未送信データ登録も失敗した場合、ANA Biz未送信データ登録失敗ワーニングとする。   ※ xxx/IF定義書_予約情報データ連携参照。   1. リクエストにカートIDが存在する場合、以下の処理を行う。     1. リアルログイン済みAMC会員である場合、会員番号とリクエストのカートIDに指定したプランをASWDB(Tx)から削除する。     1. リクエストパラメータのカートIDに指定したカートのextensionsに論理削除フラグを登録する。    1. ASWDB(Tx)に予約購入実績を登録する。登録が失敗した場合、予約購入実績登録失敗ワーニングとする。   1. HTTPステータス201(Created)を返して、処理を終了する。    # 3. データ更新内容   1. PNR   | 更新フィールド  | 更新内容 | データ取得元 | 条件等 |   | ------------- | ------------- | ------------- | ------------- |   | SK | キーワード ＝ NNBP、&lt;br&gt;フリーテキスト ＝ 設定ファイルに定義した証憑運賃情報不足用フリーテキスト&lt;br&gt;※SEG、PAXリレートする | - | 同一予約に対する発券要求情報リストが存在せず、以下いずれかを満たす場合、登録&lt;br&gt;1.アイきっぷ運賃を含み、アイきっぷ利用条件不足&lt;br&gt;2.身体障がい者運賃を含み、身体障がい者運賃利用条件不足 |    | SK | キーワード ＝ BIJZ&lt;br&gt;※リレートなし | - | 同一予約に対する発券要求情報リストが存在せず、パーソナライズ情報のANA Biz企業情報の契約形態がカードレス(\&quot;P\&quot;または\&quot;BPS\&quot;)の場合、登録 |   | SK | キーワード ＝ BIZC&lt;br&gt;※リレートなし | - | 同一予約に対する発券要求情報リストが存在せず、以下いずれかを満たす&lt;br&gt;パーソナライズ情報のANA Biz企業情報の契約形態が板カード(\&quot;P\&quot;、\&quot;BPS\&quot;でない) の場合、登録 |    | SK | キーワード ＝ MAIL、&lt;br&gt;フリーテキスト ＝ “A” + 言語コード + “T” + メールアドレス | 1.カートのextensionsの代表者メールアドレス&lt;br&gt;※リレートなし&lt;br&gt;2.ユーザ共通情報の言語コード | 同一予約に対する発券要求情報リストが存在しない場合、登録 |   | SK | キーワード ＝ MAIL、&lt;br&gt;フリーテキスト ＝ “P” + 言語コード + “T” + メールアドレス&lt;br&gt;※PAXリレートする | 1.カートのextensionsの搭乗者メールアドレス&lt;br&gt;2.ユーザ共通情報の言語コード  | 同一予約に対する発券要求情報リストが存在しない場合、登録 |    | RM | フォーマットはフリーテキスト &#x3D; \&quot;//MAIL\&quot; + “D” + 言語コード + “T” + メールアドレス + “:”(コロン) + メール受取人名&lt;br&gt;※PAXリレートする&lt;br&gt;※フリーテキストに加えて、DxAPIのリクエスト項目としてcategoryに\&quot;L\&quot;を指定する。| 1.カートのextensions&lt;br&gt;1-1.発着通知メールアドレス&lt;br&gt;1-2.メール受信者名&lt;br&gt;2.ユーザ共通情報の言語コード  | リクエストにカートIDが存在し、発着通知メールが存在する搭乗者がいる場合、登録 |   | TKOK | - | - | リクエストにカートIDが存在する場合、登録 |   | TKXL | - | - | リクエストにカートIDが存在する場合、削除 | | OPC | 購入期限(TL)&lt;br&gt;| - | DxAPIにて自動で更新される |    2. ASWDB(Tx)   | 更新テーブル  | 更新内容 | データ取得元 | 条件等 |   | ------------- | ------------- | ------------- | ------------- |   | 予約購入実績 | 実績内容  | 1.リクエストパラメータ&lt;br&gt;2.PNR&lt;br&gt;3.ユーザ共通情報  | - |   | プラン | カートIDを基に、プランを削除 | - | prebook PNRの購入が完了した場合 |    3. ANA Biz DB (ANA Biz API経由で登録)   | 更新テーブル  | 更新内容 | データ取得元 | 条件等 |   | ------------- | ------------- | ------------- | ------------- |   | 発券要求管理テーブル | 1.処理区分&lt;br&gt;2.企業情報(企業CD、企業精算CD)&lt;br&gt;3.予約番号&lt;br&gt;4.発券要求日時&lt;br&gt;5.代表搭乗者氏名(姓・名)&lt;br&gt;6.搭乗者情報(姓名、敬称、生年月日)&lt;br&gt; 7.搭乗者数分の企業用管理コード1～4&lt;br&gt; 8.コメント&lt;br&gt;9.承認者(承認者ID、承認者名)&lt;br&gt; 10.1便目の情報(出発日、出発空港コード、到着空港コード、運航キャリアコード、販売キャリアコード、便名)&lt;br&gt; 11.発券状況区分&lt;br&gt;12.発券期限日 | 1.同一予約の発券要求が存在しない場合は「発券要求の登録」、そうでない場合は「発券要求の更新」&lt;br&gt;2.パーソナライズ情報のANA Biz企業情報&lt;br&gt;3.PNR&lt;br&gt;4.操作日時(JST)&lt;br&gt;5.PNRの1人目の搭乗者&lt;br&gt;6.PNRの搭乗者&lt;br&gt; 7.リクエストパラメータ&lt;br&gt; 8.リクエストパラメータ&lt;br&gt;9.リクエストパラメータおよびANA Biz APIレスポンス&lt;br&gt; 10.PNRの1便目の情報&lt;br&gt; 11.「発券要求中」&lt;br&gt;12.操作日時(JST)+設定ファイルに定義した時間数  | - |   | 未送信データ | 1.企業情報(BTM CD、企業CD、企業精算CD)&lt;br&gt;2.送信形式&lt;br&gt;3.PNR未送信データ | 1.パーソナライズ情報のANA Biz企業情報&lt;br&gt;2.「XML」&lt;br&gt;3.PNR未送信データのXML | 企業への予約情報連携URLへの予約情報の送信が失敗した場合 |     4. カート   | 更新フィールド | 更新内容 | データ取得元 | 条件等 |   | :-------- | :--------- | :-------- | :-------- |   | extensions | キー&#x3D;\&quot;deleted\&quot;(論理削除フラグ)、値&#x3D;\&quot;true\&quot; | - | リクエストにカートIDが存在する場合 |     # 4. 特記事項   1. ANA BizにおけるAncillaryの同時購入はないものとする。   1. ANA Bizにおけるビジネスきっぷ、プレミアムビジネスきっぷの予約はないものとする。
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public ordersAnaBizTicketingRequestPost(
    generated?: OrdersAnaBizTicketingRequestRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<OrdersAnaBizTicketingRequestResponse>;
  public ordersAnaBizTicketingRequestPost(
    generated?: OrdersAnaBizTicketingRequestRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<OrdersAnaBizTicketingRequestResponse>>;
  public ordersAnaBizTicketingRequestPost(
    generated?: OrdersAnaBizTicketingRequestRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<OrdersAnaBizTicketingRequestResponse>>;
  public ordersAnaBizTicketingRequestPost(
    generated?: OrdersAnaBizTicketingRequestRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/orders/ana-biz/ticketing-request`;
    return this.httpClient.request<OrdersAnaBizTicketingRequestResponse>(
      'post',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: generated,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }
}
