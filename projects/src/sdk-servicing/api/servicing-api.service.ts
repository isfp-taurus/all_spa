/**
 * servicing eapi
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import { Inject, Injectable, Optional } from '@angular/core';
import {
  HttpClient,
  HttpHeaders,
  HttpParams,
  HttpResponse,
  HttpEvent,
  HttpParameterCodec,
  HttpContext,
} from '@angular/common/http';
import { CustomHttpParameterCodec } from '../encoder';
import { empty, Observable, of, throwError } from 'rxjs';
import { CreateMycarValetRequest } from '../model/createMycarValetRequest';
import { CreateMycarValetResponse } from '../model/createMycarValetResponse';
import { CreateMycarValetResponseWarningsInner } from '../model/createMycarValetResponseWarningsInner';
import { CreateSkLkrlRequest } from '../model/createSkLkrlRequest';
import { CreateSkLkrlResponse } from '../model/createSkLkrlResponse';
import { EncryptDutyFreePreOrderRequest } from '../model/encryptDutyFreePreOrderRequest';
import { EncryptDutyFreePreOrderResponse } from '../model/encryptDutyFreePreOrderResponse';
import { EncryptYamatoBaggageRequest } from '../model/encryptYamatoBaggageRequest';
import { EncryptYamatoBaggageResponse } from '../model/encryptYamatoBaggageResponse';
import { FareConditionsRequest } from '../model/fareConditionsRequest';
import { FareConditionsResponse } from '../model/fareConditionsResponse';
import { GetDocumentListRequest } from '../model/getDocumentListRequest';
import { GetDocumentListResponse } from '../model/getDocumentListResponse';
import { GetETicketItineraryReceiptRequest } from '../model/getETicketItineraryReceiptRequest';
import { GetETicketItineraryReceiptResponse } from '../model/getETicketItineraryReceiptResponse';
import { GetEmdPassengerReceiptRequest } from '../model/getEmdPassengerReceiptRequest';
import { GetEmdPassengerReceiptResponse } from '../model/getEmdPassengerReceiptResponse';
import { GetListResponse } from '../model/getListResponse';
import { GetMealRequest } from '../model/getMealRequest';
import { GetMealResponse } from '../model/getMealResponse';
import { GetOrderListResponse } from '../model/getOrderListResponse';
import { GetOrderRequest } from '../model/getOrderRequest';
import { GetOrderResponse } from '../model/getOrderResponse';
import { GetReceiptRequest } from '../model/getReceiptRequest';
import { GetReceiptResponse } from '../model/getReceiptResponse';
import { GetSeatmapsRequest } from '../model/getSeatmapsRequest';
import { GetSeatmapsResponse } from '../model/getSeatmapsResponse';
import { JuniorPilotGetReceiptRequest } from '../model/juniorPilotGetReceiptRequest';
import { JuniorPilotGetReceiptResponse } from '../model/juniorPilotGetReceiptResponse';
import { JuniorPilotRequest } from '../model/juniorPilotRequest';
import { JuniorPilotResponse } from '../model/juniorPilotResponse';
import { PetRakunoriRequest } from '../model/petRakunoriRequest';
import { PetRakunoriResponse } from '../model/petRakunoriResponse';
import { SearchDecryptionRequest } from '../model/searchDecryptionRequest';
import { SearchDecryptionResponse } from '../model/searchDecryptionResponse';
import { SendConfirmationMailRequest } from '../model/sendConfirmationMailRequest';
import { SendConfirmationMailResponse } from '../model/sendConfirmationMailResponse';
import { Type } from '../model/type';
import { UpdateBasicInformationCardRequest } from '../model/updateBasicInformationCardRequest';
import { UpdateBasicInformationCardResponse } from '../model/updateBasicInformationCardResponse';
import { UpdateBasicInformationDisabilityRequest } from '../model/updateBasicInformationDisabilityRequest';
import { UpdateBasicInformationDisabilityResponse } from '../model/updateBasicInformationDisabilityResponse';
import { UpdateBasicInformationFlightRequest } from '../model/updateBasicInformationFlightRequest';
import { UpdateBasicInformationFlightResponse } from '../model/updateBasicInformationFlightResponse';
import { UpdateBasicInformationHotelRequest } from '../model/updateBasicInformationHotelRequest';
import { UpdateBasicInformationHotelResponse } from '../model/updateBasicInformationHotelResponse';
import { UpdateBasicInformationPassportRequest } from '../model/updateBasicInformationPassportRequest';
import { UpdateBasicInformationPassportResponse } from '../model/updateBasicInformationPassportResponse';
import { UpdateBasicInformationPaymentRequest } from '../model/updateBasicInformationPaymentRequest';
import { UpdateBasicInformationPaymentResponse } from '../model/updateBasicInformationPaymentResponse';
import { UpdateBasicInformationSupportRequest } from '../model/updateBasicInformationSupportRequest';
import { UpdateBasicInformationSupportResponse } from '../model/updateBasicInformationSupportResponse';
import { UpdateServicesRequest } from '../model/updateServicesRequest';
import { UpdateServicesResponse } from '../model/updateServicesResponse';
import { UpdateTravelersRequest } from '../model/updateTravelersRequest';
import { UpdateTravelersResponse } from '../model/updateTravelersResponse';
import { UpdateWifiRecordsRequest } from '../model/updateWifiRecordsRequest';
import { UsageDetailsRequest } from '../model/usageDetailsRequest';
import { UsageDetailsResponse } from '../model/usageDetailsResponse';
import { BASE_PATH, COLLECTION_FORMATS } from '../variables';
import { Configuration } from '../configuration';

@Injectable({
  providedIn: 'root',
})
export class ServicingApiService {
  protected basePath = 'http://localhost:8000';
  public defaultHeaders = new HttpHeaders();
  public configuration = new Configuration();
  public encoder: HttpParameterCodec;

  constructor(
    protected httpClient: HttpClient,
    @Optional() @Inject(BASE_PATH) basePath: string | string[],
    @Optional() configuration: Configuration
  ) {
    if (configuration) {
      this.configuration = configuration;
    }
    if (typeof this.configuration.basePath !== 'string') {
      if (Array.isArray(basePath) && basePath.length > 0) {
        basePath = basePath[0];
      }

      if (typeof basePath !== 'string') {
        basePath = this.basePath;
      }
      this.configuration.basePath = basePath;
    }
    this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
  }

  private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
    if (typeof value === 'object' && value instanceof Date === false) {
      httpParams = this.addToHttpParamsRecursive(httpParams, value);
    } else {
      httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
    }
    return httpParams;
  }

  private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
    if (value == null) {
      return httpParams;
    }

    if (typeof value === 'object') {
      if (Array.isArray(value)) {
        (value as any[]).forEach((elem) => (httpParams = this.addToHttpParamsRecursive(httpParams, elem, key)));
      } else if (value instanceof Date) {
        if (key != null) {
          httpParams = httpParams.append(key, (value as Date).toISOString().substr(0, 10));
        } else {
          throw Error('key may not be null if value is Date');
        }
      } else {
        Object.keys(value).forEach(
          (k) => (httpParams = this.addToHttpParamsRecursive(httpParams, value[k], key != null ? `${key}.${k}` : k))
        );
      }
    } else if (key != null) {
      httpParams = httpParams.append(key, value);
    } else {
      throw Error('key may not be null if value is not object or array');
    }
    return httpParams;
  }

  /**
   * # 1. 概要 リクエスト項目で送信されたクレジットカード情報を予約基本情報としてMindsに登録する。&lt;br/&gt;  # 2. 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、&lt;br/&gt;   エラーハンドリング(API)(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返却する。&lt;br/&gt; 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br/&gt;    有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. リクエストパラメータ内の各項目について以下のいずれかに該当する場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;   1. クレジットカード有効期限について、以下のいずれかに該当する(一般用、法人用ともに同じ条件とする)&lt;br/&gt;     1. 現在年の1月より前である(例：現在が2030年12月31日の場合、クレジットカード有効期限が2030年1月以降であればチェックOKとする)&lt;br/&gt;     1. 年部分が現在年より15年以上後でない(例：現在が2030年1月1日の場合、クレジットカード有効期限が2045年12月以前であればチェックOKとする)&lt;br/&gt;   1. 一般用クレジットカード情報内の各種情報(番号、名称、有効期限)のキーが存在し、かつ以下のいずれかに該当する&lt;br/&gt;     1. 現在のPOSがインドサイトである&lt;br/&gt;     1. 現在ログイン中の会員がANA Biz会員である&lt;br/&gt;   1. 法人用クレジットカード情報内の各種情報(番号、名称、有効期限)のキーが存在し、かつ以下のいずれかに該当する&lt;br/&gt;     1. 現在ログイン中の会員情報にて、JCBカードレス契約企業であるとされている&lt;br/&gt;     1. 現在ログイン中の会員がANA Biz会員でない&lt;br/&gt;   1. クレジットカード番号、クレジットカード名称、クレジットカード有効期限のいずれも存在しない(一般用、法人用ともに)&lt;br/&gt;     ※キー自体が存在しない場合をチェックNGとし、キーが存在して値が空である場合は削除相当であるとしてエラーにはしないものとする。&lt;br/&gt; 1. 会員データ（更新）APIを呼び出し、リクエストパラメータ内の各種クレジットカードをもとに会員情報の更新を行う。&lt;br/&gt;    会員データ（更新）APIよりエラーが返却された場合は、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. 正常終了の場合、HTTPステータスコード201を返却し、本処理を終了する。&lt;br/&gt;  # 3. データ更新内容&lt;br/&gt; ## 1.ASWDB(Tx)&lt;br/&gt; | 更新フィールド | 更新内容 | データ取得元 | 条件等 | | :------------- | :------------- | :------------- | :------------- | | S2パーソナライズ情報 | 更新に成功した予約基本情報と対応する項目 | リクエストパラメータ | 予約基本情報の更新が成功した場合|  ## 2.AMC会員情報&lt;br/&gt; | 更新フィールド | 更新内容 | データ取得元 | 条件等 | | :------------- | :------------- | :------------- | :------------- | | 予約基本情報 |  一般用クレジットカード番号１ | リクエストパラメータ  | いつもの情報の一般用クレジットカード番号１の更新が指定された(一般用クレジットカード情報リストの1番目で番号が指定された)場合 | | 予約基本情報 |  一般用クレジットカード名称１ | リクエストパラメータ  | いつもの情報の一般用クレジットカード名称１の更新が指定された(一般用クレジットカード情報リストの1番目で名称が指定された)場合 | | 予約基本情報 |  一般用クレジットカード有効期限１ | リクエストパラメータ  | いつもの情報の一般用クレジットカード有効期限１の更新が指定された(一般用クレジットカード情報リストの1番目で有効期限が指定された)場合 | | 予約基本情報 |  一般用クレジットカード番号２ | リクエストパラメータ  | いつもの情報の一般用クレジットカード番号２の更新が指定された(一般用クレジットカード情報リストの2番目で番号が指定された)場合 | | 予約基本情報 |  一般用クレジットカード名称２ | リクエストパラメータ  | いつもの情報の一般用クレジットカード名称２の更新が指定された(一般用クレジットカード情報リストの2番目で名称が指定された)場合 | | 予約基本情報 |  一般用クレジットカード有効期限２ | リクエストパラメータ  | いつもの情報の一般用クレジットカード有効期限２の更新が指定された(一般用クレジットカード情報リストの2番目で有効期限が指定された)場合 | | 予約基本情報 |  法人用クレジットカード番号１ | リクエストパラメータ  | いつもの情報の法人用クレジットカード番号１の更新が指定された(法人用クレジットカード情報リストの1番目で番号が指定された)場合 | | 予約基本情報 |  法人用クレジットカード名称１ | リクエストパラメータ  | いつもの情報の法人用クレジットカード名称１の更新が指定された(法人用クレジットカード情報リストの1番目で名称が指定された)場合 | | 予約基本情報 |  法人用クレジットカード有効期限１ | リクエストパラメータ  | いつもの情報の法人用クレジットカード有効期限１の更新が指定された(法人用クレジットカード情報リストの1番目で有効期限が指定された)場合 | | 予約基本情報 |  法人用クレジットカード番号２ | リクエストパラメータ  | いつもの情報の法人用クレジットカード番号２の更新が指定された(法人用クレジットカード情報リストの2番目で番号が指定された)場合 | | 予約基本情報 |  法人用クレジットカード名称２ | リクエストパラメータ  | いつもの情報の法人用クレジットカード名称２の更新が指定された(法人用クレジットカード情報リストの2番目で名称が指定された)場合 | | 予約基本情報 |  法人用クレジットカード有効期限２ | リクエストパラメータ  | いつもの情報の法人用クレジットカード有効期限２の更新が指定された(法人用クレジットカード情報リストの2番目で有効期限が指定された)場合 |  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public basicInformationCardPut(
    generated?: UpdateBasicInformationCardRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<UpdateBasicInformationCardResponse>;
  public basicInformationCardPut(
    generated?: UpdateBasicInformationCardRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<UpdateBasicInformationCardResponse>>;
  public basicInformationCardPut(
    generated?: UpdateBasicInformationCardRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<UpdateBasicInformationCardResponse>>;
  public basicInformationCardPut(
    generated?: UpdateBasicInformationCardRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/basic-information/card`;
    return this.httpClient.request<UpdateBasicInformationCardResponse>(
      'put',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: generated,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * # 1. 概要 リクエスト項目で送信された障がい種別を予約基本情報としてMindsに登録する。&lt;br/&gt; # 2. 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、&lt;br/&gt;    エラーハンドリング(API)(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返却する。&lt;br/&gt; 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br/&gt;    有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. リクエストパラメータ内の障がい種別に紐づく情報がASWDB(マスタ)に存在しない場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;    ※キー自体が存在しない場合をチェックNGとし、キーが存在して値が空である場合は削除相当であるとしてエラーにはしないものとする。&lt;br/&gt; 1. 会員データ（更新）APIを呼び出し、リクエストパラメータ内の障がい種別をもとに会員情報の更新を行う。&lt;br/&gt;    会員データ（更新）APIよりエラーが返却された場合は、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. 正常終了の場合、HTTPステータスコード201を返却し、本処理を終了する。&lt;br/&gt;  # 3. データ更新内容 1.ASWDB(Tx) | 更新テーブル  | 更新内容 | データ取得元 | 条件等 | | ---: | :--- | :--- | :--- | | S2パーソナライズ情報 | 更新に成功した予約基本情報と対応する項目 | リクエストパラメータ  | 予約基本情報の更新が成功した場合|  2.AMC会員情報 | 更新フィールド  | 更新内容 | データ取得元 | 条件等 | | ---: | :--- | :--- | :--- | | 予約基本情報 |  障がい種別 | リクエストパラメータ  | いつもの情報の障がい種別の更新が指定された場合 |  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public basicInformationDisabilityPut(
    generated?: UpdateBasicInformationDisabilityRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<UpdateBasicInformationDisabilityResponse>;
  public basicInformationDisabilityPut(
    generated?: UpdateBasicInformationDisabilityRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<UpdateBasicInformationDisabilityResponse>>;
  public basicInformationDisabilityPut(
    generated?: UpdateBasicInformationDisabilityRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<UpdateBasicInformationDisabilityResponse>>;
  public basicInformationDisabilityPut(
    generated?: UpdateBasicInformationDisabilityRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/basic-information/disability`;
    return this.httpClient.request<UpdateBasicInformationDisabilityResponse>(
      'put',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: generated,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * # 1. 概要 リクエスト項目で送信されたセグメント関連情報を予約基本情報としてMindsに登録する。&lt;br/&gt; # 2. 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、&lt;br/&gt;    エラーハンドリング(API)(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返却する。&lt;br/&gt; 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br/&gt;    有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. リクエストパラメータ内の各項目について以下のいずれかに該当する場合はステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;   1. 出発日付区分、出発空港、到着空港のいずれも存在しない&lt;br/&gt;      ※キー自体が存在しない場合をチェックNGとし、キーが存在して値が空である場合は削除相当であるとしてエラーにはしないものとする。&lt;br/&gt;   1. 出発空港、到着空港に紐づく空港情報がASWDB(マスタ)に存在しない、または空港情報にて予約基本情報の区間として選択可能ではないとされている&lt;br/&gt; 1. 会員データ（更新）APIを呼び出し、リクエストパラメータ内の出発日付区分、出発空港、到着空港をもとに会員情報の更新を行う。&lt;br/&gt;    会員データ（更新）APIよりエラーが返却された場合は、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。 &lt;br/&gt;  # 3. データ更新内容&lt;br/&gt; ## 1.ASWDB(Tx)&lt;br/&gt; | 更新フィールド | 更新内容 | データ取得元 | 条件等 | | :------------- | :------------- | :------------- | :------------- | | S2パーソナライズ情報 | 更新に成功した予約基本情報と対応する項目 | リクエストパラメータ | 予約基本情報の更新が成功した場合|  ## 2.AMC会員情報&lt;br/&gt; | 更新フィールド | 更新内容 | データ取得元 | 条件等 | | :------------- | :------------- | :------------- | :------------- | | 予約基本情報 | 出発空港コード | リクエストパラメータ | いつもの情報の出発空港コードの更新が指定された場合 | | 予約基本情報 | 到着空港コード | リクエストパラメータ | いつもの情報の到着空港コードの更新が指定された場合 | | 予約基本情報 | 予約日付区分 | リクエストパラメータ | いつもの情報の予約日付区分の更新が指定された場合 |  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public basicInformationFlightPut(
    generated?: UpdateBasicInformationFlightRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<UpdateBasicInformationFlightResponse>;
  public basicInformationFlightPut(
    generated?: UpdateBasicInformationFlightRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<UpdateBasicInformationFlightResponse>>;
  public basicInformationFlightPut(
    generated?: UpdateBasicInformationFlightRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<UpdateBasicInformationFlightResponse>>;
  public basicInformationFlightPut(
    generated?: UpdateBasicInformationFlightRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/basic-information/flight`;
    return this.httpClient.request<UpdateBasicInformationFlightResponse>(
      'put',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: generated,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * # 1. 概要 リクエスト項目で送信されたホテル情報を予約基本情報としてMindsに登録する。&lt;br/&gt; # 2. 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、&lt;br/&gt;    エラーハンドリング(API)(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返却する。&lt;br/&gt; 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br/&gt;    有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. リクエストパラメータ内の各項目について以下のいずれかに該当する場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;   1. ホテル方面コードに紐づく情報がASWDB(マスタ)に存在しない&lt;br/&gt;   1. ホテル地区コードに紐づく情報がASWDB(マスタ)に存在しない、またはホテル方面コードに紐づくリスト内にホテル地区コードが存在しない&lt;br/&gt;   1. ホテル地域コードに紐づく情報がASWDB(マスタ)に存在しない、またはホテル地区コードに紐づくリスト内にホテル地域コードが存在しない&lt;br/&gt;   1. ホテル方面コード、ホテル地区コード、ホテル地域コードがいずれも存在しない&lt;br/&gt;      ※キー自体が存在しない場合をチェックNGとし、キーが存在して値が空である場合は削除相当であるとしてエラーにはしないものとする。&lt;br/&gt; 1. 会員データ（更新）APIを呼び出し、リクエストパラメータ内の支払方法をもとに障がい種別の更新を行う。&lt;br/&gt;    会員データ（更新）APIよりエラーが返却された場合は、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. 正常終了の場合、HTTPステータスコード201を返却し、本処理を終了する。&lt;br/&gt;  # 3. データ更新内容&lt;br/&gt; ## 1.ASWDB(Tx)&lt;br/&gt; | 更新フィールド | 更新内容 | データ取得元 | 条件等 | | :------------- | :------------- | :------------- | :------------- | | S2パーソナライズ情報 | 更新に成功した予約基本情報と対応する項目 | リクエストパラメータ | 予約基本情報の更新が成功した場合|  ## 2.AMC会員情報&lt;br/&gt; | 更新フィールド | 更新内容 | データ取得元 | 条件等 | | :------------- | :------------- | :------------- | :------------- | | 予約基本情報 |  ホテル方面コード | リクエストパラメータ  | いつもの情報のホテル方面コードの更新が指定された場合 | | 予約基本情報 |  ホテル地区コード | リクエストパラメータ  | いつもの情報のホテル地区コードの更新が指定された場合 | | 予約基本情報 |  ホテル地域コード | リクエストパラメータ  | いつもの情報のホテル地域コードの更新が指定された場合 |  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public basicInformationHotelInformationPut(
    generated?: UpdateBasicInformationHotelRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<UpdateBasicInformationHotelResponse>;
  public basicInformationHotelInformationPut(
    generated?: UpdateBasicInformationHotelRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<UpdateBasicInformationHotelResponse>>;
  public basicInformationHotelInformationPut(
    generated?: UpdateBasicInformationHotelRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<UpdateBasicInformationHotelResponse>>;
  public basicInformationHotelInformationPut(
    generated?: UpdateBasicInformationHotelRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/basic-information/hotel-information`;
    return this.httpClient.request<UpdateBasicInformationHotelResponse>(
      'put',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: generated,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * # 1. 概要 リクエスト項目で送信されたパスポート情報を予約基本情報としてMindsに登録する。&lt;br/&gt; # 2. 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、&lt;br/&gt;    エラーハンドリング(API)(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返却する。&lt;br/&gt; 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br/&gt;    有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. リクエストパラメータ内の各項目について以下のいずれかに該当する場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;   1. パスポート国籍およびパスポート発行国について、紐づく国情報がASWDB(マスタ)に存在しない、またはAPIS登録対象/パスポート発行国として選択可能な国であるとされていない&lt;br/&gt;   1. パスポート生年月日の年部分が以下のいずれかに該当する&lt;br/&gt;     1. 現在年より150年以上前である(例：現在が2030年12月31日の場合、パスポート生年月日が1881年1月1日以降であればチェックOKとし、月日部分は考慮に入れない)&lt;br/&gt;     1. 現在年より後である(例：現在が2030年1月1日の場合、パスポート生年月日が2030年12月31日以前であればチェックOKとし、月日部分は考慮に入れない)&lt;br/&gt;   1. パスポート有効期限が以下のいずれかに該当する&lt;br/&gt;     1. 現在年の1月より前である(例：現在が2030年12月31日の場合、パスポート有効期限が2030年1月1日以降であればチェックOKとする)&lt;br/&gt;     1. 年部分が現在年より51年以上後である(例：現在が2030年1月1日の場合、パスポート有効期限が2080年12月31日以前であればチェックOKとする)&lt;br/&gt;   1. パスポート生年月日、パスポート有効期限がyyyyMMdd形式の日付でない&lt;br/&gt;   1. リクエストパラメータ内にパスポート名、パスポートミドルネーム、パスポート姓、パスポート生年月日、パスポート性別、パスポート国籍、パスポート番号、パスポート有効期限、パスポート発行国のいずれも存在しない&lt;br/&gt;      ※キー自体が存在しない場合をチェックNGとし、キーが存在して値が空である場合は削除相当であるとしてエラーにはしないものとする。&lt;br/&gt;   1. ログイン中の会員がANA Biz会員である&lt;br/&gt; 1. 会員データ（更新）APIを呼び出し、リクエストパラメータ内の各種パスポート情報をもとに会員情報の更新を行う。&lt;br/&gt;    会員データ（更新）APIよりエラーが返却された場合は、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. 正常終了の場合、HTTPステータスコード201を返却し、本処理を終了する。&lt;br/&gt;  # 3. データ更新内容&lt;br/&gt; ## 1.ASWDB(Tx)&lt;br/&gt; | 更新フィールド | 更新内容 | データ取得元 | 条件等 | | :------------- | :------------- | :------------- | :------------- | | S2パーソナライズ情報 | 更新に成功した予約基本情報と対応する項目 | リクエストパラメータ | 予約基本情報の更新が成功した場合|  ## 2.AMC会員情報&lt;br/&gt; | 更新フィールド | 更新内容 | データ取得元 | 条件等 | | :------------- | :------------- | :------------- | :------------- | | 予約基本情報 |  パスポート名 | リクエストパラメータ  | いつもの情報のパスポート名の更新が指定された場合 | | 予約基本情報 |  パスポートミドルネーム | リクエストパラメータ  | いつもの情報のパスポートミドルネームの更新が指定された場合 | | 予約基本情報 |  パスポート姓 | リクエストパラメータ  | いつもの情報のパスポート姓の更新が指定された場合 | | 予約基本情報 |  パスポート生年月日 | リクエストパラメータ  | いつもの情報のパスポート生年月日の更新が指定された場合 | | 予約基本情報 |  パスポート性別 | リクエストパラメータ  | いつもの情報のパスポート性別の更新が指定された場合 | | 予約基本情報 |  パスポート国籍 | リクエストパラメータ  | いつもの情報のパスポート国籍の更新が指定された場合 | | 予約基本情報 |  パスポート番号 | リクエストパラメータ  | いつもの情報のパスポート番号の更新が指定された場合 | | 予約基本情報 |  パスポート有効期限 | リクエストパラメータ  | いつもの情報のパスポート有効期限の更新が指定された場合 | | 予約基本情報 |  パスポート発行国 | リクエストパラメータ  | いつもの情報のパスポート発行国の更新が指定された場合 |  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public basicInformationPassportPut(
    generated?: UpdateBasicInformationPassportRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<UpdateBasicInformationPassportResponse>;
  public basicInformationPassportPut(
    generated?: UpdateBasicInformationPassportRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<UpdateBasicInformationPassportResponse>>;
  public basicInformationPassportPut(
    generated?: UpdateBasicInformationPassportRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<UpdateBasicInformationPassportResponse>>;
  public basicInformationPassportPut(
    generated?: UpdateBasicInformationPassportRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/basic-information/passport`;
    return this.httpClient.request<UpdateBasicInformationPassportResponse>(
      'put',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: generated,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * # 1. 概要 リクエスト項目で送信された支払方法を予約基本情報としてMindsに登録する。&lt;br/&gt; # 2. 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、&lt;br/&gt;    エラーハンドリング(API)(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返却する。&lt;br/&gt; 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br/&gt;    有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. リクエストパラメータ内の支払方法について、紐づく支払情報がASWDB(マスタ)に存在しない、または予約基本情報の支払方法として選択可能であるとされていない場合、&lt;br/&gt;    ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。 &lt;br/&gt; 1. 会員データ（更新）APIを呼び出し、リクエストパラメータ内の支払方法をもとに会員情報の更新を行う。&lt;br/&gt;    会員データ（更新）APIよりエラーが返却された場合は、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. 正常終了の場合、HTTPステータスコード201を返却し、本処理を終了する。&lt;br/&gt;  # 3. データ更新内容&lt;br/&gt; ## 1.ASWDB(Tx)&lt;br/&gt; | 更新フィールド | 更新内容 | データ取得元 | 条件等 | | :------------- | :------------- | :------------- | :------------- | | S2パーソナライズ情報 | 更新に成功した予約基本情報と対応する項目 | リクエストパラメータ | 予約基本情報の更新が成功した場合|  ## 2.AMC会員情報&lt;br/&gt; | 更新フィールド | 更新内容 | データ取得元 | 条件等 | | :------------- | :------------- | :------------- | :------------- | | 予約基本情報 |  決済手段区分 | リクエストパラメータ  | いつもの情報の決済手段区分の更新が指定された場合 |  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public basicInformationPaymentPut(
    generated?: UpdateBasicInformationPaymentRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<UpdateBasicInformationPaymentResponse>;
  public basicInformationPaymentPut(
    generated?: UpdateBasicInformationPaymentRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<UpdateBasicInformationPaymentResponse>>;
  public basicInformationPaymentPut(
    generated?: UpdateBasicInformationPaymentRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<UpdateBasicInformationPaymentResponse>>;
  public basicInformationPaymentPut(
    generated?: UpdateBasicInformationPaymentRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/basic-information/payment`;
    return this.httpClient.request<UpdateBasicInformationPaymentResponse>(
      'put',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: generated,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * # 1. 概要 リクエスト項目で送信されたサポート情報を予約基本情報としてMindsに登録する。&lt;br/&gt;  # 2. 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、&lt;br/&gt;    エラーハンドリング(API)(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返却する。&lt;br/&gt; 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br/&gt;    有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. リクエストパラメータ内の各項目について以下のいずれかに該当する場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;   1. 歩行の程度がキーとして指定されているが、車いす持ち込み有無が指定されていない&lt;br/&gt;   1. 車いす持ち込みが持ち込みありで、折りたたみ可否と車いす種類のいずれかが指定されていない&lt;br/&gt;   1. 車いす種類が電動で、バッテリータイプが指定されていない&lt;br/&gt;   1. 車いす折りたたみ可否がfalseで、かつ車いすサイズ(奥行)、車いすサイズ(横幅)、車いすサイズ(高さ)、車いすサイズ(重さ)のいずれかが指定されていない&lt;br/&gt;   1. 歩行の程度、車いす有無、車いす種類、バッテリータイプ、車いす折りたたみ可否、車いすサイズ(奥行)、車いすサイズ(横幅)、車いすサイズ(高さ)、車いすサイズ(重さ)、のいずれも存在しない&lt;br/&gt;      視覚障がい有無、聴覚障がい有無のいずれも存在しない&lt;br/&gt;      ※キー自体が存在しない場合をチェックNGとし、キーが存在して値が空である場合は削除相当であるとしてエラーにはしないものとする。&lt;br/&gt; 1. ログイン中の会員情報に含まれるパスワードをもとに予約基本情報取得APIを呼び出し、医療用酸素ボンベの情報を取得する。&lt;br/&gt; 1. 会員データ（更新）APIを呼び出し、リクエストパラメータ内の情報、および医療用酸素ボンベの情報をもとに会員情報の更新を行う。&lt;br/&gt;    会員データ（更新）APIよりエラーが返却された場合は、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;    ※医療用酸素ボンベの情報についてはWEB申込を不可としているが、情報の削除が意図せず行われないようにするために元の情報をそのまま送信する。&lt;br/&gt; 1. 正常終了の場合、HTTPステータスコード201を返却し、本処理を終了する。  # 3. データ更新内容&lt;br/&gt; ## 1.ASWDB(Tx)&lt;br/&gt; | 更新フィールド | 更新内容 | データ取得元 | 条件等 | | :------------- | :------------- | :------------- | :------------- | | S2パーソナライズ情報 | 更新に成功した予約基本情報と対応する項目 | リクエストパラメータ | 予約基本情報の更新が成功した場合|  ## 2.AMC会員情報&lt;br/&gt; | 更新フィールド | 更新内容 | データ取得元 | 条件等 | | :------------- | :------------- | :------------- | :------------- | | 予約基本情報 |  歩行の程度 | リクエストパラメータ  | いつもの情報の歩行の程度の更新が指定された場合 | | 予約基本情報 |  車いす有無 | リクエストパラメータ  | いつもの情報の車いす有無の更新が指定された場合 | | 予約基本情報 |  車いす種類 | リクエストパラメータ  | いつもの情報の車いす種類の更新が指定された場合 | | 予約基本情報 |  バッテリータイプ | リクエストパラメータ  | いつもの情報のバッテリータイプの更新が指定された場合 | | 予約基本情報 |  車いす折りたたみ可否 | リクエストパラメータ  | いつもの情報の車いす折りたたみ可否の更新が指定された場合 | | 予約基本情報 |  車いすサイズ(奥行) | リクエストパラメータ  | いつもの情報の車いすサイズ(奥行)の更新が指定された場合 | | 予約基本情報 |  車いすサイズ(横幅) | リクエストパラメータ  | いつもの情報の車いすサイズ(横幅)の更新が指定された場合 | | 予約基本情報 |  車いすサイズ(高さ) | リクエストパラメータ  | いつもの情報の車いすサイズ(高さ)の更新が指定された場合 | | 予約基本情報 |  車いすサイズ(重さ) | リクエストパラメータ  | いつもの情報の車いすサイズ(重さ)の更新が指定された場合 | | 予約基本情報 |  視覚障がい有無 | リクエストパラメータ  | いつもの情報の視覚障がい有無の更新が指定された場合 | | 予約基本情報 |  聴覚障がい有無 | リクエストパラメータ  | いつもの情報の聴覚障がい有無の更新が指定された場合 | | 予約基本情報 |  医療用酸素ボンベ | 予約基本情報取得APIレスポンス  |  |  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public basicInformationSupportPut(
    generated?: UpdateBasicInformationSupportRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<UpdateBasicInformationSupportResponse>;
  public basicInformationSupportPut(
    generated?: UpdateBasicInformationSupportRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<UpdateBasicInformationSupportResponse>>;
  public basicInformationSupportPut(
    generated?: UpdateBasicInformationSupportRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<UpdateBasicInformationSupportResponse>>;
  public basicInformationSupportPut(
    generated?: UpdateBasicInformationSupportRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/basic-information/support`;
    return this.httpClient.request<UpdateBasicInformationSupportResponse>(
      'put',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: generated,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * # 1. &lt;概要&gt; リクエスト項目で送信された各キー項目に紐づく運賃ルール情報と手荷物情報を返却する。 # 2. 処理概要 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、エラーハンドリングAPI(G01-010)を利用してMulesoftが生成したエラー情報を解析し、&lt;br/&gt;   ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br/&gt;   有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. 以下のいずれかに一致する場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;   1.1 リクエストパラメータのカートID、予約番号がいずれもない&lt;br/&gt;   1.1 リクエストパラメータのカートID、予約番号が両方ある&lt;br/&gt;   1.1 リクエストパラメータの予約番号があるが、搭乗者姓、搭乗者名のいずれかがない&lt;br/&gt; 1. リクエストパラメータの予約番号がある場合、PNR情報取得APIを利用し予約を取得する。&lt;br/&gt;   予約が見つからない旨のエラーが返却された場合はステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. リクエストパラメータの予約変更の空席照会結果にて選択したAir Bound IDリストが存在する場合、&lt;br/&gt;   そのIDリストを基にDxAPIへ予約変更リソースの作成(POST /purchase/orders/{orderId}/order-changes)を行い、order change IDと呼ばれるID(変更後予約の確定前一時データを一意に識別するためのID)を取得する。&lt;br/&gt;   DxAPIより予約が見つからない旨のエラーが返却された、または予約変更リソースの作成に失敗した場合はステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. DxAPIからカートID、予約番号、order change IDのいずれか(order change IDを取得した場合は予約番号は利用しない)、および操作中の言語(DxAPI用の言語コードをASWDB(マスタ)より取得)を基に運賃ルール情報を取得する。&lt;br/&gt;   DxAPIよりカートまたは予約が見つからない旨のエラーが返却された場合はステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. DxAPIからカートID、予約番号、order change IDのいずれか(order change IDを取得した場合は予約番号も併せて利用する)を基に手荷物ルール情報を取得する。&lt;br/&gt;   DxAPIよりカートまたは予約が見つからない旨のエラーが返却された場合はステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. 取得した情報をもとにレスポンスボディを作成し、ステータスコード200(OK)で呼び出し元に返却する。   # 3. データ更新内容 なし  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public fareConditionsPost(
    generated?: FareConditionsRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<FareConditionsResponse>;
  public fareConditionsPost(
    generated?: FareConditionsRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<FareConditionsResponse>>;
  public fareConditionsPost(
    generated?: FareConditionsRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<FareConditionsResponse>>;
  public fareConditionsPost(
    generated?: FareConditionsRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/fare-conditions`;
    return this.httpClient.request<FareConditionsResponse>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. &lt;概要&gt; リクエスト項目で送信されたorderId、またはcartIdに紐づく機内食情報を返却する。 # 2. 処理内容 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br/&gt;   有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。 1. リクエストパラメータ内にorderId、またはcartIdの内いずれも存在しない場合、または双方とも指定されている場合は、&lt;br/&gt;   ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。 1. リクエストパラメータ内にorderIdが存在している場合、以下の処理を行う。   1. リクエストパラメータ内に予約番号、搭乗者姓、搭乗者名のいずれかが存在しない場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。              1. リクエストパラメータ内にorderIdが指定されている場合、予約番号と搭乗者姓、搭乗者名をもとにPNR情報取得APIを呼び出す。&lt;br/&gt;       PNR情報の取得に失敗した場合は、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。 1. リクエストパラメータ内にcartIdが存在している場合、cartIdを元にカート取得APIを呼び出す。&lt;br/&gt;   カート情報の取得に失敗した場合は、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。  1. 条件に応じて、以下の内容でDxAPIからサービスカタログ情報を取得する。   1. リクエストパラメータ内にcartIdが存在している場合は、cartIdをもとに取得する。   1. リクエストパラメータ内にorderIdが存在している場合は、orderIdをもとに取得する。 1. 取得した情報をもとにレスポンスボディを作成し、ステータスコード200(OK)で呼び出し元に返却する。  # 3. データ更新内容 なし  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getMealPost(
    generated?: GetMealRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<GetMealResponse>;
  public getMealPost(
    generated?: GetMealRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<GetMealResponse>>;
  public getMealPost(
    generated?: GetMealRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<GetMealResponse>>;
  public getMealPost(
    generated?: GetMealRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/get-meal`;
    return this.httpClient.request<GetMealResponse>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. &lt;概要&gt; ANA Bizログインユーザに紐づく発券申請PNRのリストを返却する。&lt;br/&gt;  # 2. 処理概要 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br/&gt;   有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. 呼び出し元より渡されたアクセストークンを復号し、トークン内に含まれるuuidを基に、ASWDB(Tx)からログイン中のANA Biz会員情報を取得する。&lt;br/&gt;   ANA Biz会員情報を取得できなかった場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. ANA Biz会員情報内の企業CD、企業精算CD、管理者ユーザID、契約形態、全体承認者であるかをもとに、発券要求取得APIから発券要求一覧を取得する。&lt;br/&gt;   一部のPNR情報が取得できなかった旨のワーニングが返却された場合は、取得できた情報で後続の処理を行い、一部の情報が取得できなかった旨の警告情報を含めて返却する。&lt;br/&gt;   全情報の取得に失敗した場合は、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. 取得した情報をもとにレスポンスボディを作成し、ステータスコード200(OK)で呼び出し元に返却する。  # 3. データ更新内容 なし  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public ordersBusinessTripGetListGet(
    generated?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<GetListResponse>;
  public ordersBusinessTripGetListGet(
    generated?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<GetListResponse>>;
  public ordersBusinessTripGetListGet(
    generated?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<GetListResponse>>;
  public ordersBusinessTripGetListGet(
    generated?: string,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/orders/business-trip/get-list`;
    return this.httpClient.request<GetListResponse>('get', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. &lt;概要&gt; リクエスト項目で送信された出張管理番号に紐づく実績管理情報を返却する。&lt;br/&gt;  # 2. 処理概要 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、&lt;br/&gt;   エラーハンドリング(API)(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返却する。&lt;br/&gt; 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br/&gt;   有効でない場合、ステータスコード403でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. リクエストパラメータ内に出張管理番号が1件も存在しない場合は、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。 &lt;br/&gt; 1. リクエストパラメータ内の出張管理番号をもとに、実績管理データ取得APIから実績管理情報を取得する。&lt;br/&gt;   出張管理番号を複数指定した際に一部の番号の情報が取得できなかった場合は、取得できた情報で後続の処理を行い、一部の情報が取得できなかった旨の警告情報を含めて返却する。&lt;br/&gt;   全情報の取得に失敗した場合は、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。 &lt;br/&gt; 1. 取得した情報をもとにレスポンスボディを作成し、ステータスコード200(OK)で呼び出し元に返却する。  # 3. データ更新内容 なし  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public ordersBusinessTripUsageDetailsGet(
    generated?: UsageDetailsRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<UsageDetailsResponse>;
  public ordersBusinessTripUsageDetailsGet(
    generated?: UsageDetailsRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<UsageDetailsResponse>>;
  public ordersBusinessTripUsageDetailsGet(
    generated?: UsageDetailsRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<UsageDetailsResponse>>;
  public ordersBusinessTripUsageDetailsGet(
    generated?: UsageDetailsRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/orders/business-trip/usage-details`;
    return this.httpClient.request<UsageDetailsResponse>('get', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要 マイカーバレー申込を行うため、CAS経由でマイカーバレーサービス受付完了メール(STAFF宛)、マイカーバレーサービス受付完了メールを送信する。&lt;br/&gt; # 2. 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、&lt;br/&gt;   エラーハンドリングAPI(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返却する。&lt;br/&gt; 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br/&gt;   有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。  &lt;br/&gt; 1. リクエストパラメータの予約番号とcredential情報に基づき、PNR情報取得APIからPNR情報を取得する。&lt;br/&gt; 1. PNR情報取得APIで取得したPNRに含まれる、マイカーバレー利用可否判定が利用不可の場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;   PNR情報が取得できなかった場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. リクエストパラメータのログインユーザ判定がtrue、または、リクエストパラメータのAMC会員番号が設定されている場合、以下の内容でAMC会員番号の検証を行う。&lt;br/&gt;   検証がNGの場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;   1. 呼び出し元より渡されたアクセストークンを復号し、トークン内に含まれるuuidを基に、ASWDB(Tx)からログイン中の会員情報を取得する。取得できない場合、検証NGとする。&lt;br/&gt;   1. リクエストパラメータのログインユーザ判定がfalseかつ、リクエストパラメータのAMC会員番号がログイン中の会員情報のAMC会員番号と異なる場合、以下の検証を行う。&lt;br/&gt;     1. リクエストパラメータのAMC会員番号の上9桁の数字を7で割った余りに1を足した値が、下1桁と一致すること。&lt;br/&gt;     1. リクエストパラメータのAMC会員番号を基にMindsから会員情報を取得できること。&lt;br/&gt; 1. リクエストパラメータの代表者メールアドレスについて、メールアドレスのフォーマットが不正の（共通部品、G03-501を使用）場合、&lt;br/&gt;   ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. リクエストパラメータの代表者電話番号について、日本国内の電話番号であることを確認するため、“-“(ハイフン)を除外した代表者電話番号に対して、&lt;br/&gt;   マイカーバレー固有の電話番号チェック（0始まり、かつ10～11桁の全桁半角数字であること）を行う。&lt;br/&gt;   チェック結果がNGの場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. マイカーバレー対象便判定を行う。&lt;br/&gt;   以下の条件を一つでも満たさないものが一つでもある場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;   1. 設定ファイルより取得したマイカーバレーサービス対象空港発の第一国際線、及び出発空港と同一空港着の国際線が存在する。&lt;br/&gt;   1. 設定ファイルより取得したマイカーバレーサービス対象空港発の第一国際線、及び出発空港と同一空港着の国際線について、&lt;br/&gt;     いずれもNHグループ便名、かつNHグループ運航のフライトである(以降、マイカーバレー対象フライトとする)。   1. マイカーバレー対象フライトがマイカーバレーサービス対象空港リストに存在している。&lt;br/&gt;   1. マイカーバレー対象フライトが出発済みではない。&lt;br/&gt;   1. マイカーバレー対象フライトがオープン便ではない。&lt;br/&gt;   1. 対象空港発国際線の出発日の2カ月前から、受付終了日時までのリクエストである。&lt;br/&gt;     ※受付終了日時は、「受付終了の年月日を、出発日の何日前にするか」「その年月日における終了時刻」の2つを設定ファイルに定義し、出発日から計算して求める。&lt;br/&gt; 1. リクエストパラメータを基に、CASへマイカーバレーサービス受付完了メール(STAFF宛)の送信リクエストを行う。&lt;br/&gt;   CASからエラーが返ってきた場合、ステータスコード400でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. リクエストパラメータを基に、CASへマイカーバレーサービス受付完了メールの送信リクエストを行う。&lt;br/&gt;   CASからエラーが返ってきた場合、ステータスコード200でワーニング情報を返却し、処理を終了する。&lt;br/&gt; 1. 正常終了の場合、HTTPステータス200を返却し、処理を終了する。  # 3. データ更新内容 なし  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public ordersCreateMycarValetPost(
    generated?: CreateMycarValetRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<CreateMycarValetResponse>;
  public ordersCreateMycarValetPost(
    generated?: CreateMycarValetRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<CreateMycarValetResponse>>;
  public ordersCreateMycarValetPost(
    generated?: CreateMycarValetRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<CreateMycarValetResponse>>;
  public ordersCreateMycarValetPost(
    generated?: CreateMycarValetRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/orders/create-mycar-valet`;
    return this.httpClient.request<CreateMycarValetResponse>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要 リクエストパラメータをもとにSK LKRLの登録を行う。&lt;br/&gt; # 2. 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、&lt;br/&gt;   エラーハンドリングAPI(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返却する。&lt;br/&gt; 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br/&gt;   有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。  &lt;br/&gt; 1. リクエストパラメータに紐付け先のPNRの予約番号と航空券番号のどちらも存在しない、または両方存在する場合はステータスコード400でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. リクエストパラメータの紐付け先のPNRの予約番号、または航空券番号、搭乗者名(姓)、搭乗者名(名)をもとにPNR情報取得APIよりPNR情報を取得する。&lt;br/&gt;   PNR情報が取得できなかった場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。  &lt;br/&gt; 1. 紐付け元のPNRと紐付け先のPNRの両方のSKエレメントに対し、SK LKRL（関連する予約番号）を登録する。&lt;br/&gt;   登録に失敗した場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. 正常終了の場合、HTTPステータスコード201を返却し、処理を終了する。&lt;br/&gt;  # 3. データ更新内容 1. 紐付け元のPNR | 更新フィールド | 更新内容 | データ取得元 | 条件等 | | ---: | :--- | :--- | :--- | | SK |紐付け先のPNRのSK LKRLの登録&lt;br&gt;以下のフォーマットで登録する。&lt;br&gt;「[予約番号]/[搭乗者姓]/[搭乗者名]」&lt;br&gt;（例：SK LKRL NH AAAAAA/SORANO/TARO）&lt;br&gt;リクエストパラメータで航空券番号が指定された場合はPNR情報取得APIで取得したPNR情報の予約番号を設定する | リクエストパラメータの紐付け先のPNR | なし |  1. 紐付け先のPNR | 更新フィールド | 更新内容 | データ取得元 | 条件等 | | ---: | :--- | :--- | :--- | | SK |紐付け元のPNRのSK LKRLの登録&lt;br&gt;以下のフォーマットで登録する。&lt;br&gt;「[予約番号]/[搭乗者姓]/[搭乗者名]」&lt;br&gt;（例：SK LKRL NH AAAAAA/SORANO/TARO）| リクエストパラメータの紐付け元のPNR | なし |  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public ordersCreateSkLkrlPost(
    generated?: CreateSkLkrlRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<CreateSkLkrlResponse>;
  public ordersCreateSkLkrlPost(
    generated?: CreateSkLkrlRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<CreateSkLkrlResponse>>;
  public ordersCreateSkLkrlPost(
    generated?: CreateSkLkrlRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<CreateSkLkrlResponse>>;
  public ordersCreateSkLkrlPost(
    generated?: CreateSkLkrlRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/orders/create-sk-lkrl`;
    return this.httpClient.request<CreateSkLkrlResponse>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要 PNR情報から暗号対象データを取得して暗号化済みデータを生成し、返却を行う。&lt;br&gt; 暗号化方式をAESとして暗号化し、Base64でエンコードする。&lt;br&gt; 固定鍵、初期ベクトルは設定ファイルへ定義する。&lt;br&gt; # 2. 処理概要 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、&lt;br/&gt;   エラーハンドリングAPI(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返却する。&lt;br/&gt; 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br/&gt;   有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. リクエストパラメータをもとに、PNR情報取得APIからPNR情報を取得する。&lt;br/&gt;   PNR情報が取得できなかった場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。 1. 暗号化対象の搭乗者情報を判定する。&lt;br/&gt;   以下の順で比較を行い、最初に合致した搭乗者情報を比較用搭乗者情報とする。&lt;br/&gt;   1. DynamoDBからログイン者情報を取得する。 &lt;br/&gt;   1. ログイン者情報を取得できた場合、ログイン者情報の搭乗者名(姓)、(名)を比較用搭乗者情報とする。 &lt;br/&gt;   1. ログイン者情報を取得できない場合、credential情報の搭乗者名(姓)、(名)を比較用搭乗者情報とする。 &lt;br/&gt; 1. 比較用搭乗者情報をもとに、暗号化対象の搭乗者情報を判定する。&lt;br/&gt;   搭乗者情報が一致するまでPNR情報の搭乗者数分判定処理を繰り返す。&lt;br/&gt;   1. 比較用搭乗者情報の搭乗者名(姓)がPNR情報の搭乗者名(姓)と一致する場合、搭乗者名(名)の判定を行う。 &lt;br/&gt;   1. 比較用搭乗者名(名)とPNR情報の搭乗者名(名)より“ ”(半角スペース)を全て削除して比較を行い、一致した場合、暗号化対象搭乗者情報とする。 &lt;br/&gt;   1. 一致する搭乗者情報が存在しない場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。 &lt;br/&gt; 1. 判定を行った搭乗者情報を暗号化対象とし、以下の項目を設定する。&lt;br/&gt;   1. 性別 &lt;br/&gt;     暗号化対象搭乗者情報の性別が存在する場合：暗号化対象搭乗者情報の性別&lt;br/&gt;     上記以外の場合：“”(空欄)&lt;br/&gt;   1. 搭乗者名(英字名) &lt;br/&gt;   1. 搭乗者姓(英字姓) &lt;br/&gt;   1. 生年月日(yyyyMMdd) &lt;br/&gt;   1. eメールアドレス &lt;br/&gt;     暗号化対象搭乗者情報のメールアドレスが存在する場合：暗号化対象搭乗者情報のメールアドレス&lt;br/&gt;     上記以外の場合：“”(空欄)&lt;br/&gt; 1. 暗号化を実施する際に必要なパラメータは以下とし、暗号化対象項目とともに暗号化処理呼び出し時に設定する。&lt;br/&gt;   1. 暗号化のアルゴリズム &lt;br/&gt;     \&quot;AES\&quot;（固定値）を指定する &lt;br/&gt;   1. 暗号利用モード &lt;br/&gt;     \&quot;CBC\&quot;(固定値)を指定する &lt;br/&gt;   1. 変換モード &lt;br/&gt;     \&quot;ENCRYPT\&quot;(固定値)を指定する&lt;br/&gt;   1. 文字セット &lt;br/&gt;     \&quot;UTF-8\&quot;（固定値）を指定する&lt;br/&gt;   1. パディング方式 &lt;br/&gt;     \&quot;PKCS5Padding\&quot;（固定値）を指定する&lt;br/&gt;   1. 秘密鍵の鍵データ &lt;br/&gt;     設定ファイルより取得&lt;br/&gt;   1. 初期化ベクトル &lt;br/&gt;     設定ファイルより取得&lt;br/&gt; 1. リクエストパラメータを元に共通部品（G03-514）を呼び出し暗号化を行う。&lt;br/&gt;   共通部品よりエラーが返却された場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. 正常終了の場合、暗号化データ、HTTPステータスコード200を返却し、本処理を終了する。&lt;br/&gt;  # 3. データ更新内容 なし  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public ordersEncryptDutyFreePreOrderPost(
    generated?: EncryptDutyFreePreOrderRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<EncryptDutyFreePreOrderResponse>;
  public ordersEncryptDutyFreePreOrderPost(
    generated?: EncryptDutyFreePreOrderRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<EncryptDutyFreePreOrderResponse>>;
  public ordersEncryptDutyFreePreOrderPost(
    generated?: EncryptDutyFreePreOrderRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<EncryptDutyFreePreOrderResponse>>;
  public ordersEncryptDutyFreePreOrderPost(
    generated?: EncryptDutyFreePreOrderRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/orders/encrypt-dutyFreePreOrder`;
    return this.httpClient.request<EncryptDutyFreePreOrderResponse>(
      'post',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: generated,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * # 1. 概要 PNR情報から暗号対象データを取得して暗号化済みデータを生成し、返却を行う。&lt;br&gt; 暗号化方式をBlowfishとして暗号化し、Base64でエンコードする。&lt;br&gt; 固定鍵、初期ベクトルは設定ファイルへ定義する。&lt;br&gt; # 2. 処理概要 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、&lt;br/&gt;   エラーハンドリングAPI(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返却する。&lt;br/&gt; 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br/&gt;   有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. リクエストパラメータをもとに、PNR情報取得APIからPNR情報を取得する。&lt;br/&gt;   PNR情報が取得できなかった場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。 1. PNR情報より、暗号化対象のデータを取得する。&lt;br/&gt;   セグメントが複数ある場合、出発日が一番早いセグメントを対象とする。&lt;br/&gt;   セグメントに含まれるすべての搭乗者分、暗号化を行う。&lt;br/&gt;   暗号化対象の項目は以下の通り&lt;br/&gt;   1. 出発地 &lt;br/&gt;   1. 出発日 &lt;br/&gt;     yyyyMMdd形式&lt;br/&gt;   1. 出発時刻 &lt;br/&gt;     HHmm形式&lt;br/&gt;   1. 便名 &lt;br/&gt;     便名キャリア＋便番号(3桁未満の場合は前0埋めし3桁にする。3桁以上の便番号はそのままとする。)    1. 予約番号 &lt;br/&gt;   1. 搭乗者名(姓) &lt;br/&gt;     搭乗者名(姓)と搭乗者名(名)の合計文字数が46文字以上の場合、以下の方法で合計文字数が45文字以内になるように削除を行った搭乗者名を設定する。&lt;br/&gt;     搭乗者名(姓)と搭乗者名(名)の合計文字数が45文字以内になるか搭乗者名(名)が1文字になるまで、搭乗者名(名)の末尾から文字列削除を行う。&lt;br/&gt;     搭乗者名(名)が1文字かつ搭乗者名(姓)と搭乗者名(名)の合計文字数が46文字以上の場合、&lt;br/&gt;     搭乗者名(姓)と搭乗者名(名)の合計文字数が45文字以内になるまで搭乗者名(姓)の末尾から文字列削除を行う。&lt;br/&gt;   1. 搭乗者名(名) &lt;br/&gt;     搭乗者名(姓)の処理を参照&lt;br/&gt;   1. クーポン使用 &lt;br/&gt;     “0”（未使用）を設定&lt;br/&gt;   1. 北米識別 &lt;br/&gt;     到着地から国コードを取得し、国コードより、以下の条件で設定（ASWDBの汎用マスターデータ(リスト)テーブルに定義）&lt;br/&gt;     ASWDBに登録された北米と見做す国コードの場合、“1” それ以外の場合、“0”&lt;br/&gt;   1. AMC会員番号 &lt;br/&gt;     AMC会員の場合、以下の条件に従いFFP番号を取得し設定する&lt;br/&gt;     有償PNRの場合：マイル積算用FFP番号(FQTV)&lt;br/&gt;     特典PNRの場合：マイル減算用FFP番号(FQTR)&lt;br/&gt;     ※複数のFFP番号が登録されている場合、AMC会員のFFP番号の1件目を設定対象とする。&lt;br/&gt;     ※AMC会員でない場合、“”(空欄)&lt;br/&gt;   1. データ連携日時 &lt;br/&gt;     システム日付を（yyyyMMddHHmmss）フォーマットで設定&lt;br/&gt; 1. 暗号化を実施する際に必要なパラメータは以下とし、暗号化対象項目とともに暗号化処理呼び出し時に設定する。&lt;br/&gt;   1. 暗号化のアルゴリズム &lt;br/&gt;     \&quot;Blowfish\&quot;(固定値)を指定する &lt;br/&gt;   1. 暗号利用モード &lt;br/&gt;     \&quot;CBC\&quot;(固定値)を指定する &lt;br/&gt;   1. 変換モード &lt;br/&gt;     \&quot;ENCRYPT\&quot;(固定値)を指定する&lt;br/&gt;   1. 文字セット &lt;br/&gt;     指定しない（デフォルト値を使用）&lt;br/&gt;   1. パディング方式 &lt;br/&gt;     \&quot;PKCS5Padding\&quot;（固定値）を指定する&lt;br/&gt;   1. 秘密鍵の鍵データ &lt;br/&gt;     設定ファイルより取得&lt;br/&gt;   1. 初期化ベクトル &lt;br/&gt;     設定ファイルより取得&lt;br/&gt; 1. 暗号化対象項目を「,」で連結し、共通部品（G03-514）を呼び出し暗号化を行う。&lt;br/&gt;   共通部品よりエラーが返却された場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. 暗号化対象項目を「,」で連結し、固定文字列を前後に付与した後にMD5ハッシュ値を計算しBase64エンコードしたものを連携データハッシュ値とする。&lt;br/&gt;   固定文字列は設定ファイルに定義する。 1. 正常終了の場合、暗号化データ、ハッシュ値、HTTPステータスコード200を返却し、本処理を終了する。&lt;br/&gt;  # 3. データ更新内容 なし  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public ordersEncryptYamatoBaggagePost(
    generated?: EncryptYamatoBaggageRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<EncryptYamatoBaggageResponse>;
  public ordersEncryptYamatoBaggagePost(
    generated?: EncryptYamatoBaggageRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<EncryptYamatoBaggageResponse>>;
  public ordersEncryptYamatoBaggagePost(
    generated?: EncryptYamatoBaggageRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<EncryptYamatoBaggageResponse>>;
  public ordersEncryptYamatoBaggagePost(
    generated?: EncryptYamatoBaggageRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/orders/encrypt-yamatoBaggage`;
    return this.httpClient.request<EncryptYamatoBaggageResponse>(
      'post',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: generated,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * # 1. &lt;概要&gt; リクエストパラメータをもとに航空券およびEMDリストを取得する。&lt;br/&gt; 検索種別に応じて検索条件と検索対象を選択し取得処理を行う。&lt;br/&gt; # 2. 処理概要 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、&lt;br/&gt;   エラーハンドリングAPI(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返却する。&lt;br/&gt; 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br/&gt;   有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。  &lt;br/&gt; 1. 検索種別に応じて、入力した条件に合致する航空券またはEMDを取得する。&lt;br/&gt;   検索種別に応じたリクエストパラメータの必須項目が不足していた場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;   EMDについては、表示対象とするEMDのサービス種別をASWDBの有料サービス情報テーブルに定義し、そのサービスとKeep My FareのEMDのみを表示する。 1. 検索種別がemdByAmcNumber、eTicketByPurchaseDate、eTicketByDepartureDateのいずれかの場合、Altea Web Serviceを利用して入力した条件に合致する航空券もしくはEMDのリストを取得する。&lt;br/&gt;   EMDのリストを取得する際、Altea Web Serviceから以下のエラーが返ってきた場合、ステータスコード400でエラー情報を返して、本処理を中止とする。   1. 該当するEMDが存在しない&lt;br/&gt;   1. 該当するEMDが99件を超えている&lt;br/&gt; 1. 検索種別がeTicketAndEmdByPnrForReceiptおよびeTicketAndEmdByPnrForETicketEmdの場合、PNR情報取得APIを呼び出してPNRを取得し、航空券/EMDリストを返却する。&lt;br/&gt;   PNRが取得できなかった場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;   PNRのFA/FHE/FHDエレメントに航空券番号およびEMD番号が保持されているが、それらのクーポン情報についてはAltea Web Serviceを使って別途取得する必要があるため、&lt;br/&gt;   FA/FHE/FHDエレメントごとに1件ずつAltea Web Serviceを利用して航空券/EMD情報を取得する。&lt;br/&gt;   検索種別がeTicketAndEmdByPnrForReceiptの場合で以下のいずれかに該当するPNRは航空券の領収書表示を不可とし、EMDのみ表示とする。   1. 航空券の支払手段がコンビニエンスストア&lt;br/&gt;   1. 支払総額が表示不可&lt;br/&gt;     支払総額の表示可否条件はPNR情報取得APIを通じて判定済みの表示可否を取得する。ただし、原券と違う支払手段で交換発行した場合は領収書表示可とする。 1. 検索種別がemdByAmcNumberの場合、取得したEMDリストについて、以下のいずれかの条件に該当するEMDをリストから削除する。&lt;br/&gt;   リストが0件となる場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;   1. サービスが表示対象の有料サービス、Keep My Fare以外&lt;br/&gt;   1. NH・NDC発券でない　※NH・NDC発券のEMD番号は設定ファイルに定義する。 1. 検索種別がemdByAmcNumber、eTicketByPurchaseDate、eTicketByDepartureDateのいずれかの場合、&lt;br/&gt;   Altea Web Serviceから取得した航空券およびEMDリストをもとに、Altea Web Serviceから詳細のリストを取得する。&lt;br/&gt;   以下のいずれかの場合、ステータスコード400でエラー情報を返して、本処理を中止とする。　&lt;br/&gt;   1. Altea Web Serviceから詳細のEMDリストが取得できなかった場合&lt;br/&gt;   1. Altea Web Serviceから詳細の航空券リストが取得できなかった場合&lt;br/&gt;   1. Altea Web Serviceに一時的にアクセスできない場合 1. 検索種別がemdByAmcNumberの場合、クーポンステータスが無効のEMDを詳細のEMDリストから削除する。　※無効のクーポンステータスは設定ファイルに定義する。&lt;br/&gt;   詳細のEMDリストが0件となる場合、ステータスコード400でエラー情報を返して、本処理を中止とする。 1. 検索種別がeTicketAndEmdByPnrForReceipt及びeTicketAndEmdByPnrForETicketEmdの場合、搭乗者・セグメントごとに、以下の順で最初に合致する航空券を表示とする。   1. FAエレメントに航空券番号が1つでも存在する場合：FAエレメント&lt;br/&gt;   1. FAエレメントに航空券番号が存在せず、FHEエレメントに航空券番号が1つのみ存在する場合：FHEエレメント&lt;br/&gt;     FAエレメント及びFHEエレメントに航空券番号が存在しない、またはFAエレメントに航空券番号が存在せずFHEエレメントに航空券番号が複数存在する場合は対象航空券なしとする。&lt;br/&gt;   1. 以下のいずれかに該当する場合、対象航空券なしとする。&lt;br/&gt;     1. 合致した航空券に有効なクーポンがない　※無効のクーポンステータスは設定ファイルに定義する。&lt;br/&gt;     1. 航空券の支払総額が0&lt;br/&gt;     1. NH・NDC発券でない　※NH・NDC発券の航空券番号は設定ファイルに定義する。&lt;br/&gt;     1. マーチャントがANA以外のNDC PNRで、NDC発券　※NDC発券の航空券番号は設定ファイルに定義する。&lt;br/&gt;     ※取得したPNRのANA BizPNR区分がtrueの場合、すべての航空券をリストから削除し、表示対象としない。 1. 検索種別がeTicketAndEmdByPnrForReceiptの場合、搭乗者・セグメントごとに、以下を満たすEMDを表示とする。   1. FAエレメント、FHDエレメントのEMD&lt;br/&gt;   1. EMD番号の始まりがNH発券の番号、またはNDC発券の番号。&lt;br/&gt;     ただし、NDC発券のEMDは、マーチャントがANAのNDC PNRを除くGDS PNRの場合、表示対象としない。&lt;br/&gt;     ※NH発券、NDC発券の番号は設定ファイルに定義する。&lt;br/&gt;   1. 有効なクーポンを1つでも含む。&lt;br/&gt;     ※無効なクーポンは設定ファイルに定義する。&lt;br/&gt;   1. サービスが表示対象の有料サービス、Keep My Fare   ※取得したPNRのANA BizPNR区分がtrueの場合、キャッシュアップグレードのEMD以外のすべてのEMDを詳細のEMDリストから削除し、表示対象としない。&lt;br/&gt;     詳細のEMDリストが0件となる場合、ステータスコード400でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. 検索種別がeTicketAndEmdByPnrForETicketEmdの場合、搭乗者・セグメントごとに、以下に合致するEMDを非表示とする。&lt;br/&gt;   1. 航空券が発券後の場合、Keep My FareのEMD&lt;br/&gt;   1. EMDが紐づくSSRがない&lt;br/&gt;   1. EMDが紐づくSSRのステータスがHK/KK以外のEMD&lt;br/&gt;     現在のセグメントに対し各サービスの利用が可能なものを表示とする。また、アップグレードを行うとSSRのステータスがUCになるため、ステータスがHK、またはKKであることも判定する。 1. 正常終了の場合、HTTPステータスコード200を返却し、本処理を終了する。  # 3. データ更新内容 なし  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public ordersGetDocumentListPost(
    generated?: GetDocumentListRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<GetDocumentListResponse>;
  public ordersGetDocumentListPost(
    generated?: GetDocumentListRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<GetDocumentListResponse>>;
  public ordersGetDocumentListPost(
    generated?: GetDocumentListRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<GetDocumentListResponse>>;
  public ordersGetDocumentListPost(
    generated?: GetDocumentListRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/orders/get-documentList`;
    return this.httpClient.request<GetDocumentListResponse>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要 リクエストパラメータをもとにPDF生成用パラメータをCASに渡し、eチケットお客様控え(PDF)を生成する。&lt;br&gt; 生成したeチケットお客様控え(PDF)をレスポンスとして受け取る。 # 2. 処理概要 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、&lt;br/&gt;   エラーハンドリングAPI(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返却する。&lt;br/&gt; 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br/&gt;   有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。  &lt;br/&gt; 1. 予約番号または航空券番号、および姓名をもとにPNR情報取得APIを呼び出す。PNR情報を取得できなかった場合は&lt;br/&gt;   ステータスコード400でエラー情報を返して、本処理を中止とする。ただし、予約番号が存在する場合は予約番号を使用し、存在しない場合は航空券番号を使用する。 1. リクエストパラメータをもとに、CASにPDF生成用パラメータを渡し、eチケットお客様控え(PDF)を生成する。&lt;br/&gt;   生成用パラメータとして言語指定を設定する。設定値は“0”（日英併記）とする。&lt;br/&gt;   リクエストパラメータの航空券番号が存在しない場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。 1. CASから以下のエラーが返ってきた場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;   1. 指定航空券情報なしエラー&lt;br/&gt;   1. 取扱不可クーポンステータスエラー&lt;br/&gt; 1. 正常終了の場合、生成したeチケットお客様控え(PDF)とHTTPステータスコード200を返却し、本処理を終了する。  # 3. データ更新内容 なし  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public ordersGetETicketItineraryReceiptPost(
    generated?: GetETicketItineraryReceiptRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<GetETicketItineraryReceiptResponse>;
  public ordersGetETicketItineraryReceiptPost(
    generated?: GetETicketItineraryReceiptRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<GetETicketItineraryReceiptResponse>>;
  public ordersGetETicketItineraryReceiptPost(
    generated?: GetETicketItineraryReceiptRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<GetETicketItineraryReceiptResponse>>;
  public ordersGetETicketItineraryReceiptPost(
    generated?: GetETicketItineraryReceiptRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/orders/get-eTicketItineraryReceipt`;
    return this.httpClient.request<GetETicketItineraryReceiptResponse>(
      'post',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: generated,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * # 1. 概要 リクエストパラメータをもとにPDF生成用パラメータをCASに渡し、EMDお客様控え(PDF)を生成する。&lt;br&gt; 生成したEMDお客様控え(PDF)をレスポンスとして受け取る。&lt;br&gt; # 2. 処理概要 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、&lt;br/&gt;   エラーハンドリングAPI(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返却する。&lt;br/&gt; 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br/&gt;   有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。  &lt;br/&gt; 1. EMDのお客様控え表示可否をASWにて判定する。Altea Web ServiceにてEMD検索を行い、EMDを取得する。  &lt;br/&gt;   Altea Web ServiceからEMDが取得できなかった場合、ステータスコード400でエラー情報を返して、本処理を中止とする。  &lt;br/&gt;   取得したEMDが以下を全て満たす場合、EMDお客様控えを表示可能とする。  &lt;br/&gt;   表示不可能の場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。　   1. EMDが表示対象のサービス（ASWDBの有料サービス情報テーブルに定義）またはKeep My Fare &lt;br/&gt;   1. クーポンステータスが有効 &lt;br/&gt;     ※無効なクーポンは設定ファイルに定義する。 &lt;br/&gt;   1. EMDから取得した搭乗者名（名）と搭乗者名（姓）とcredential情報の搭乗者名（名）と搭乗者名（姓）がフルネームで一致 &lt;br/&gt;     credential情報の搭乗者名（名）にミドルネームを含める場合があり、この際credential情報の搭乗者名（名）とミドルネームの間にスペースを入れて検索する場合が多いため、 &lt;br/&gt;     EMDの搭乗者名(名)とcredential情報の搭乗者名(名)からそれぞれスペースを除いてチェックを行う。&lt;br/&gt;     EMDから取得した搭乗者名（名）にタイトルが含まれてしまうケースがあるため、&lt;br/&gt;     EMDから取得した搭乗者名（名）から設定ファイルに定義したタイトルを除いたものと、credential情報の搭乗者名（名）で比較を行う。&lt;br/&gt; 1. リクエストパラメータをもとに、CASにPDF生成用パラメータを渡し、EMDお客様控え(PDF)を生成する。&lt;br/&gt;     生成用パラメータとして言語指定を設定する。設定値は“0”（日英併記）とする。 1. CASから以下のエラーが返ってきた場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;   1. 指定EMD情報なしエラー&lt;br/&gt;   1. 取扱不可クーポンステータスエラー&lt;br/&gt; 1. 正常終了の場合、生成したEMDお客様控え(PDF)とHTTPステータスコード200を返却し、処理を終了する。  # 3. データ更新内容 なし  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public ordersGetEmdPassengerReceiptPost(
    generated?: GetEmdPassengerReceiptRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<GetEmdPassengerReceiptResponse>;
  public ordersGetEmdPassengerReceiptPost(
    generated?: GetEmdPassengerReceiptRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<GetEmdPassengerReceiptResponse>>;
  public ordersGetEmdPassengerReceiptPost(
    generated?: GetEmdPassengerReceiptRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<GetEmdPassengerReceiptResponse>>;
  public ordersGetEmdPassengerReceiptPost(
    generated?: GetEmdPassengerReceiptRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/orders/get-emdPassengerReceipt`;
    return this.httpClient.request<GetEmdPassengerReceiptResponse>(
      'post',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: generated,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * # 1. &lt;概要&gt; 予約一覧情報をDxAPIから取得・返却する&lt;br/&gt;  ### 【アクセス情報】&lt;br&gt; 外部からの呼び出しは、以下のURLとする。   | 環境 | URL |  | :--- | :--- |  | 本番 | https://space.ana.co.jp/aswbe-servicing/api/v1/order-list |  | ステージング |https://stg.test.space.ana.co.jp/aswbe-servicing/api/v1/order-list |  | 開発 | https://dev.test.space.ana.co.jp/dev1/aswbe-servicing/api/v1/order-list&lt;br&gt;https://dev.test.space.ana.co.jp/dev2/aswbe-servicing/api/v1/order-list&lt;br&gt;https://dev.test.space.ana.co.jp/dev3/aswbe-servicing/api/v1/order-list&lt;br&gt;https://dev.test.space.ana.co.jp/dev4/aswbe-servicing/api/v1/order-list&lt;br&gt;https://dev.test.space.ana.co.jp/dev5/aswbe-servicing/api/v1/order-list |  # 2. 処理概要 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br/&gt;   有効でない場合、ステータスコード403でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. 呼び出し元より渡されたアクセストークンを復号し、トークン内に含まれるuuidを基に、ASWDB(Tx)からログイン中の会員情報を取得する。&lt;br/&gt;   AMC会員番号を取得できなかった場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;   ※COMMON-005共通部品利用予定※詳細処理は確認中&lt;br/&gt; 1. AMC会員番号をもとにDxAPIから予約一覧情報を取得する。&lt;br/&gt; 1. 取得した予約情報リストから、以下を除外したものを返却する。&lt;br/&gt;  ・各予約内に含まれる、パッシブセグメントとゴーストセグメント&lt;br/&gt;  ・パッシブセグメントとゴーストセグメントを除外した結果、セグメントの件数が0件になる予約&lt;br/&gt;  ※会員が保持している予約が0件だった場合はステータスコード200で空のレスポンスを返却し、エラー扱いとはしない。  # 3. データ更新内容 なし  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public ordersGetOrderListGet(
    generated?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<GetOrderListResponse>;
  public ordersGetOrderListGet(
    generated?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<GetOrderListResponse>>;
  public ordersGetOrderListGet(
    generated?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<GetOrderListResponse>>;
  public ordersGetOrderListGet(
    generated?: string,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/orders/get-order-list`;
    return this.httpClient.request<GetOrderListResponse>('get', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要 予約詳細情報をDxAPIから取得・返却する&lt;br/&gt; Prebook状態の予約については原則検索エラーとするが、新規フローの場合でカート情報が残っている場合はPrebook状態のPNRを返却する。&lt;br/&gt;&lt;br/&gt;  ### 【アクセス情報】&lt;br&gt; 外部からの呼び出しは、以下のURLとする。   | 環境 | URL |  | :--- | :--- |  | 本番 | https://space.ana.co.jp/aswbe-servicing/api/v1/orders/get-order |  | ステージング |https://stg.test.space.ana.co.jp/aswbe-servicing/api/v1/orders/get-order |  | 開発 | https://dev.test.space.ana.co.jp/dev1/aswbe-servicing/api/v1/orders/get-order&lt;br&gt;https://dev.test.space.ana.co.jp/dev2/aswbe-servicing/api/v1/orders/get-order&lt;br&gt;https://dev.test.space.ana.co.jp/dev3/aswbe-servicing/api/v1/orders/get-order&lt;br&gt;https://dev.test.space.ana.co.jp/dev4/aswbe-servicing/api/v1/orders/get-order&lt;br&gt;https://dev.test.space.ana.co.jp/dev5/aswbe-servicing/api/v1/orders/get-order |  # 2. 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、&lt;br/&gt;    エラーハンドリング(API)(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返却する。&lt;br/&gt; 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br/&gt;   有効でない場合、ステータスコード401でエラー情報を返して、本処理を中止とする。  1. リクエストパラメータに予約番号、航空券番号、カートIDのいずれも存在しない、またはそれらの内、予約番号とカートID以外の組み合わせにて2つ以上の指定がある場合、ステータスコード400(Bad request)でエラー情報を返却する。&lt;br/&gt; 1. リクエストパラメータにカートIDが指定されている場合、カートIDをもとにDxAPIよりカート情報を取得する。&lt;br/&gt;   カート情報が取得できない場合、ステータスコード400(Bad request)でエラー情報を返却する。&lt;br/&gt; 1. 予約番号、または航空券番号と姓名をもとにDxAPIから予約詳細情報を取得する。&lt;br/&gt;   予約番号をもとに取得する際は、カート情報が存在する場合はカート情報に含まれる予約番号を使用する。存在しない場合はリクエストパラメータに指定されている予約番号を使用する。&lt;br/&gt;   DxAPIからPNR情報を取得できなかった場合はステータスコード400でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. 以下のいずれかに該当する場合、ステータスコード400でエラー情報を返して、本処理を中止とする。エラーコードは合致した条件毎に異なるエラーコードとする。&lt;br/&gt;   1. 検索時に指定した姓名と一致する搭乗者が存在しない&lt;br/&gt;   1. 複数のPNRが返却された 1. PNRが以下いずれかに合致する場合はASW取り扱い不可とし、ステータスコード400でエラー情報を返して、本処理を中止とする。&lt;br/&gt;    エラーコードは合致した条件毎に異なるエラーコードとする。   1. 有償未発券のオンラインPNRで、支払総額が0のPNRとして、以下の条件を全て満たす     1. PNRオーナーオフィスIDの4-6桁目がNH0である     1. 発券済みの航空券情報が存在しない     1. SSR FQTRが存在しない     1. 支払総額が0   1. チャーター認識(フリーテキストが\&quot;CHTR\&quot;で始まるOSIエレメント)が存在するPNR   1. リクエストパラメータにカートIDが存在しない、かつPrebook予約のPNRとして、以下の条件を全て満たす     1. PNRオーナーオフィスIDの4-6桁目がNH0である     1. コードがTIMEであるSSR(Keep My FareのSSR)が存在しない     1. 特典の減算およびAncillary以外のFPエレメントについて、以下を全て満たすものが存在しない        1. FPエレメントのFOPコード(DxAPIからはidとして返却されるコード)がWBCASHまたはWCCASHである        1. 払込期限(※)が存在し、現在時刻を過ぎていない&lt;br/&gt;        ※FPのフリーテキストの内容をDxAPIが文字列解析したものが返却され、解析されたパラメータの4番目に払込期限がyyyyMMddHHmmss形式で返却される。     1. DxAPIから有効期限、支払期限、発券期限の3つ全てが返却されている   1. 旅程が存在しない、またはセグメントステータスがゴーストセグメント(設定ファイルに定義)のセグメントのみ   1. コールセンター払戻受付認識(フリーテキストが\&quot;IRRF\&quot;で始まるRMエレメント)が存在する   1. 支払方法がコンビニ支払だが、決済番号が存在しない&lt;br/&gt;      ※FPエレメントのFOPコード(DxAPIからはidとして返却されるコード)がWCCASHである場合、支払方法がコンビニ支払であるとする。&lt;br/&gt;      ※FPのフリーテキストの内容をDxAPIが文字列解析したものが返却され、解析されたパラメータの3番目に決済番号が返却される。   1. リクエストパラメータに予約番号が存在し、DxAPIよりグループPNR識別が返却されている&lt;br/&gt;   1. SSR FQTRが存在し、かつPNRオーナーオフィスIDの4-5桁目がNHで、現在時刻がお預かり期限を過ぎている&lt;br/&gt;     ※DxAPIから返却されたOPCと、以下の処理にて算出された日時の内、早い方をお預かり期限とする。&lt;br/&gt;     1. 旅程内の最初のセグメントの出発日時を、同セグメントの出発空港コードを基にGMTに変換する。     1. 変換した出発日時 - 特典空席待ちお預かり期間の時間(設定ファイルに定義)を計算し、補正日時とする。     1. 補正日時を操作オフィスのタイムゾーンに変換し、変換後の補正日時の分以下を切り上げる。     ※現行でハンドリングしている運賃再計算エラーについては、変更管理にて対応とする。 1. 予約番号、姓名をもとにDxAPIからサービスカタログ情報を取得する。ただし、以下のいずれかに該当する場合は取得しない。   1. 旅程にセグメントステータスがコールセンター要確認、スケジュールチェンジ発生のセグメントを含む ※要確認ステータス、スケジュールチェンジ発生はそれぞれ設定ファイルに定義    1. フリーテキストに\&quot;WEB//@IGNORE\&quot;を含むRMエレメントが存在する     1. ASWで定めるPNR更新不可旅客種別(設定ファイルに定義)のみのPNR    1. 旅程内に、便名、出発日が重複し、セグメントステータスが両方とも確定済み(設定ファイルに定義)となるセグメントが存在する    1. コードがCBBG/EXSTであるSSRエレメントが存在する    1. acknowledge、self reaccommodationのいずれかが案内要である　※詳細は案内・利用可否のイレギュラー振替を参照    1. リクエストパラメータのサービスカタログ取得要否がfalse 1. 予約番号、姓名をもとにDxAPIから滞在資格証明ドキュメント情報登録要否情報を取得する。 1. リクエストパラメータに搭乗者リストが指定されている場合、指定された搭乗者以外の搭乗者の情報を削除する。以下に該当する場合は本処理を中止し、400エラーを返却する。   1. 搭乗者リストの搭乗者が、DxAPIから返却された搭乗者情報に存在しない   1. 搭乗者リストの搭乗者が、DxAPIから返却された搭乗者情報に複数存在する 1. 出発まで48時間以内であるセグメントが存在する場合、そのセグメントを指定して発着APIを呼び出し発着情報を取得する。 1. クーポンステータスがチェックイン済みの航空券がリレートしているセグメントが存在する場合、予約番号を基にDxAPIよりCPR情報を取得する。 1. 取得した予約詳細情報をもとにレスポンスボディの内容でPNR情報をステータスコード200(OK)で返却する。  # 3. データ更新内容 なし  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public ordersGetOrderPost(
    generated?: GetOrderRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<GetOrderResponse>;
  public ordersGetOrderPost(
    generated?: GetOrderRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<GetOrderResponse>>;
  public ordersGetOrderPost(
    generated?: GetOrderRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<GetOrderResponse>>;
  public ordersGetOrderPost(
    generated?: GetOrderRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/orders/get-order`;
    return this.httpClient.request<GetOrderResponse>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要 リクエストパラメータをもとにPDF生成用パラメータをCASに渡し、領収書（PDF）を生成する。&lt;br&gt; 生成した領収書(PDF)をレスポンスとして受け取る。&lt;br&gt; # 2. 処理概要 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、&lt;br/&gt;   エラーハンドリングAPI(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返却する。&lt;br/&gt; 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br/&gt;   有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。  &lt;br/&gt; 1. 以下のいずれかに一致する場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;   1. リクエストパラメータの航空券番号、EMD番号がいずれもない&lt;br/&gt;   1. リクエストパラメータの航空券番号、EMD番号が両方ある&lt;br/&gt;    1. リクエストパラメータの航空券番号があるが、credential情報がない&lt;br/&gt;              1. リクエストパラメータのEMD番号があるが、credential情報がない&lt;br/&gt; 1. Altea Web Serviceにて航空券/EMD検索を行い、航空券/EMDを取得する。&lt;br/&gt;   Altea Web Serviceから航空券/EMDが取得できなかった場合、ステータスコード400でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. 取得した航空券/EMDの搭乗者名（名）と搭乗者名（姓）とcredential情報の搭乗者名（名）と搭乗者名（姓）がフルネームで一致する場合、領収書を表示可能とする。&lt;br/&gt;   領収書が表示不可の場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;   credential情報の搭乗者名（名）にミドルネームを含める場合があり、このcredential情報の搭乗者名（名）とミドルネームの間にスペースを入れて検索する場合が多いため、&lt;br/&gt;   航空券/EMDの搭乗者名（名）とcredential情報の搭乗者名（名）からそれぞれスペースを除いてチェックを行う。&lt;br/&gt;   航空券/EMDの搭乗者名（名）にタイトルが含まれてしまうケースがあるため、&lt;br/&gt;   航空券/EMDから取得した搭乗者名（名）から設定ファイルに定義したタイトルを除いたものと、credential情報の搭乗者名（名）で比較を行う。&lt;br/&gt; 1. EMDの場合、搭乗者名の条件に加え以下の条件に一致する場合、領収書を表示可能とする。表示不可の場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;   1. EMDが表示対象のサービス（ASWDBの有料サービス情報テーブルに定義）またはKeep My Fare &lt;br/&gt;   1. クーポンステータスが有効（無効なクーポンは設定ファイルに定義）&lt;br/&gt; 1. 入力された情報をもとに、CASにPDF生成用パラメータを渡し、領収書(PDF)を生成する。&lt;br/&gt;   PDF生成用パラメータ作成時、以下考慮を行う。&lt;br/&gt;   1. 宛名には” ”(半角スペース)＋”様”を付加する。&lt;br/&gt;   1. EMDの処理を行う場合、領収書の搭乗者を非表示、そうでない場合は搭乗者を表示とする。&lt;br/&gt;   1. 航空券の処理を行う場合かつリクエストパラメータの予約番号が存在する場合、領収書の旅程を表示、そうでない場合は旅程を非表示とする。&lt;br/&gt;   1. 生成用パラメータとして言語指定を設定する。設定値は“0”（日英併記）とする。 1. CASから以下のエラーが返ってきた場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;   1. 指定航空券/EMD情報なしエラー&lt;br/&gt;   1. 搭乗者名不一致エラー&lt;br/&gt;   1. 取扱不可支払手段エラー&lt;br/&gt;   1. 支払金額ゼロエラー&lt;br/&gt;   1. 取扱不可クーポンステータスエラー&lt;br/&gt;   1. 収納年月日エラー&lt;br/&gt;   1. 搭乗者名チェック不可エラー&lt;br/&gt;   1. 通貨不一致エラー&lt;br/&gt; 1. 正常終了の場合、生成した領収書(PDF)とHTTPステータスコード200を返却し、本処理を終了する。          # 3. データ更新内容 なし  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public ordersGetReceiptPost(
    generated?: GetReceiptRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<GetReceiptResponse>;
  public ordersGetReceiptPost(
    generated?: GetReceiptRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<GetReceiptResponse>>;
  public ordersGetReceiptPost(
    generated?: GetReceiptRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<GetReceiptResponse>>;
  public ordersGetReceiptPost(
    generated?: GetReceiptRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/orders/get-receipt`;
    return this.httpClient.request<GetReceiptResponse>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要 リクエストパラメータをもとにシートマップ情報を取得する。&lt;br/&gt; 呼び出し元より渡されたリクエストパラメータにより、座席指定用シートマップ情報及び参照用シートマップ情報（以降、informartiveと表記）のいずれかを返却する。&lt;br/&gt; ※呼び出し元より渡されたリクエストパラメータに便名キャリアが含まれている場合、informartiveとする。&lt;br/&gt; # 2. 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、&lt;br/&gt;   エラーハンドリング(API)(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返却する。&lt;br/&gt; 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br/&gt;   有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。  &lt;br/&gt; 1. 以下のいずれかに一致する場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;   1. リクエストパラメータの予約番号、便名キャリアがいずれもない。&lt;br/&gt;   1. リクエストパラメータの予約番号があるが、搭乗者姓、搭乗者名のいずれかがない。&lt;br/&gt;   1. リクエストパラメータの便名キャリアがあるが、便番号、出発空港、到着空港、ブッキングクラス、出発日のいずれかがない。&lt;br/&gt;   1. リクエストパラメータの便名キャリアがあるが、搭乗者数（大人）、搭乗者数（ヤングアダルト）、搭乗者数（小児）、搭乗者数（幼児）すべて0の場合。&lt;br/&gt; 1. PNR情報取得APIよりPNR情報を取得する。※リクエストパラメータの予約番号が存在する場合に実施する。&lt;br/&gt;   prebookPNRを取得する必要がある場合、リクエストパラメータとしてカートIDも指定する。&lt;br/&gt;   PNR情報が取得できなかった、またはリクエストパラメータで指定されたセグメントのシートマップ利用可否が不可の場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. 以下の全ての条件を満たす搭乗者に対し、カウチ用のSK（SK COUC)を登録する。&lt;br/&gt;   また、SK COUC管理用にASWDB(Tx)のバッチ処理タスクにSK COUC削除用タイマータスクを登録する。※informativeでは実施しない。&lt;br/&gt;   既にSK COUC削除用タイマータスクが登録済みの場合、SK COUC削除用タイマータスクの更新日時を操作日時で更新する。&lt;br/&gt;   既にカウチ用のSKが全搭乗者登録済みで、SKの登録を行わない場合であっても、SK COUC削除用タイマータスクの登録は行う。&lt;br/&gt;   ただし、SK COUCの登録に1人でも失敗した場合は、カウチ席を選択できない状態でシートマップを表示する。また、後述の座席指定の制限によりカウチ席が利用不可となった場合は、SK COUCは登録しない。&lt;br/&gt;   1. 当該セグメントに対して、PNR情報取得APIより取得したPNR情報のすべての搭乗者に対して、代理店買取座席登録有無がfalseである。&lt;br/&gt;   1. 当該セグメントに対して、PNR情報取得APIより取得したPNR情報のすべての搭乗者に対して、代理店買取カウチ登録有無がfalseである。&lt;br/&gt;   1. 当該セグメントについて、以下の条件を満たす航空券を保持している搭乗者のみである（本処理を航空券の有効性判定処理とする）。&lt;br/&gt;     ※PNR情報取得APIにて取得した予約詳細情報がPrebookPNRではない場合のみ検査する。&lt;br/&gt;     1. 搭乗者ごとに以下の順で最初に合致する航空券を「搭乗者ごとの航空券」とし、その航空券が存在する。&lt;br/&gt;         1. 当該セグメントにリレートしているFAエレメントの航空券。&lt;br/&gt;         1. 当該セグメントにリレートしているFHEエレメントの航空券。&lt;br/&gt;         1. セグメントにリレートしていないFHEの航空券(当該FHEの航空券が複数存在する場合は、その航空券全てを対象とする)。&lt;br/&gt;     1. その航空券のチケットステータスおよびクーポンステータスが有効(有効でないチケットステータス、クーポンステータスそれぞれについて設定ファイルに定義)。&lt;br/&gt;     1. その航空券の番号の上3桁がNH発券として設定ファイルに定義されたものである。&lt;br/&gt;   1. 設定ファイルより取得したカウチ利用可否が利用可である。&lt;br/&gt;   1. Ancillary用カタログ情報に、カウチ席が利用可能な搭乗者が存在する。&lt;br/&gt;   1. 以下のいずれかの条件に該当する場合、カウチ席の申し込みを不可とし、カウチ用SKの登録を行わない。&lt;br/&gt;     1. 海外ツアー予約(PNRオーナーオフィスコードの4～6桁が1F3の場合)。&lt;br/&gt;     1. PNR情報取得APIでAncillaryが不可。&lt;br/&gt;     1. PNR情報取得APIで取得したグループPNR区分がtrue、かつ、ASWDB(マスタ)の有料サービス情報にてカウチに対するグループPNR申込可否が不可。&lt;br/&gt;     1. PNR情報取得APIで取得した社員用PNR区分がtrue、かつ、ASWDB(マスタ)の有料サービス情報にてカウチに対する社員用PNR申込可否が不可。&lt;br/&gt;     1. NHグループ便名NHグループ運航でない。&lt;br/&gt;     1. アップグレード空席待ち。&lt;br/&gt;     1. 2倍ポイントアップグレードリクエスト済み。&lt;br/&gt; 1. Tierレベルがダイヤモンド、プラチナである搭乗者が存在し、以下の全ての条件を満たす場合、全搭乗者に対して有料ASR席免除用SK(Tier関連による免除)（SK STEB)を登録する。※informativeでは実施しない。&lt;br/&gt;   1. 表示対象セグメントが有料ASR席が存在する事前座席指定可能なセグメントであり、有料ASR席免除用SKが登録されていない。&lt;br/&gt;     1. 以下の全ての条件を満たす場合、有料ASR席が存在するセグメントとする。&lt;br/&gt;       1. 有償PNR。&lt;br/&gt;       1. NH便名NHグループ運航の国際線。&lt;br/&gt;       1. ブッキングクラスを基にASWDB(マスタ)より取得したASR有料区分が“1”（一部有料）。&lt;br/&gt; 1. リクエストパラメータをもとにDxAPIを呼び出して以下の内容で座席指定用シートマップ情報及びinformartiveを取得する。&lt;br/&gt;   1. informartiveでない場合、予約番号、セグメントID、credential情報を指定してリクエストを行う。&lt;br/&gt;   1. informartiveである場合、便番号、出発空港、到着空港、ブッキングクラス、出発日を必須として指定してリクエストを行う。&lt;br/&gt;         リクエストパラメータとして予約番号が指定された場合は、PNR情報取得APIより取得したPNR情報の搭乗者情報もDxAPIに指定する。&lt;br/&gt;         リクエストパラメータとして予約番号が指定されない場合はGETリクエストとし、それ以外の場合はPOSTリクエストとする。&lt;br/&gt; 1. 以下に合致する場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;   1. リクエストパラメータの便名キャリア、便番号よりNHグループ運航NHグループ便名でなかった場合。　※informartiveの場合のみ実施する&lt;br/&gt;   1. DxAPIより取得したシートマップが無効または、PSS側でロックがかかっている旨のエラーが返却された場合。&lt;br/&gt;   1. 取得したシートマップが空。&lt;br/&gt;   1. AMC会員番号が無効のためシートマップの取得ができない。&lt;br/&gt; 1. DxAPIより取得したセグメント情報のACVがカウチ対象の場合、カウチ席の金額情報をAltea Web Serviceから取得する。※informartiveの場合のみ実施する。&lt;br/&gt; 1. 取得したシートマップ情報をもとにレスポンスボディの内容で座席指定用シートマップ情報またはinformartiveをHTTPステータス200で返却し、処理を終了する。&lt;br/&gt;  # 3. データ更新内容 なし  # 4. 特記事項 座席指定用シートマップを表示する際、AmadeusカートおよびPNRに登録されているFFP情報のTierを反映したシートマップがDxAPIより返却されるため、シートマップリクエスト時にFFP情報を個別に指定するような考慮は不要とする。&lt;br/&gt;
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getSeatmapsPost(
    generated?: GetSeatmapsRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<GetSeatmapsResponse>;
  public getSeatmapsPost(
    generated?: GetSeatmapsRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<GetSeatmapsResponse>>;
  public getSeatmapsPost(
    generated?: GetSeatmapsRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<GetSeatmapsResponse>>;
  public getSeatmapsPost(
    generated?: GetSeatmapsRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/get-seatmaps`;
    return this.httpClient.request<GetSeatmapsResponse>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要 リクエスト項目で送信された予約番号に紐づくジュニアパイロット申込書控えのPDFを返却する。&lt;br/&gt; # 2. 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、&lt;br/&gt;   エラーハンドリング(API)(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返却する。&lt;br/&gt; 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br/&gt;   有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. リクエストパラメータ内に予約番号、搭乗者姓名が存在しない場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。 &lt;br/&gt; 1. リクエストパラメータ内の予約番号と搭乗者姓名をもとにPNR情報取得APIを呼び出し、PNR情報を取得する。&lt;br/&gt;   PNR情報が取得できなかった、または取得したPNR情報に\&quot;UMN\&quot;で始まるOSIエレメント(ジュニアパイロット用OSI)が存在しない場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. 取得したPNR情報をもとに、共通部品「PDF生成サービス接続」(G03-511)を用いてジュニアパイロット申込書PDFを生成する。生成できない場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;   各帳票出力項目のタイトル及び重要なお知らせは、静的文言より取得する。&lt;br/&gt;   ※PDFのフォーマットは【外部設計書】S02-P014_ジュニアパイロット申込書 1.2画面項目説明 1.2.1.1画面イメージを参照&lt;br/&gt; 1. 正常終了の場合、HTTPステータスコード200(OK)を返却し、本処理を終了する。&lt;br/&gt;
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public ordersJuniorPilotGetReceiptPost(
    generated?: JuniorPilotGetReceiptRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<JuniorPilotGetReceiptResponse>;
  public ordersJuniorPilotGetReceiptPost(
    generated?: JuniorPilotGetReceiptRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<JuniorPilotGetReceiptResponse>>;
  public ordersJuniorPilotGetReceiptPost(
    generated?: JuniorPilotGetReceiptRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<JuniorPilotGetReceiptResponse>>;
  public ordersJuniorPilotGetReceiptPost(
    generated?: JuniorPilotGetReceiptRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/orders/junior-pilot/get-receipt`;
    return this.httpClient.request<JuniorPilotGetReceiptResponse>(
      'post',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: generated,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * # 1. 概要 ジュニアパイロットの申込を行う。&lt;br/&gt; # 2. 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、&lt;br/&gt;   エラーハンドリング(API)(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返却する。&lt;br/&gt; 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br/&gt;   有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。  &lt;br/&gt; 1. リクエストパラメータの予約番号とcredential情報に基づき、PNR情報取得APIからPNR情報を取得する。&lt;br/&gt; 1. PNR情報が取得できなかった、またはPNR情報に含まれるジュニアパイロット利用可否判定が利用不可の場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. 以下のいずれかに該当する場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;   返却するエラーコードは該当した条件に応じて異なるものとする。&lt;br/&gt;   1. ASWDB(マスタ)からジュニアパイロット申込期限を取得し、現在時刻が申込期限を過ぎている&lt;br/&gt;   1. 以下のいずれかに該当するセグメントが旅程内に含まれる&lt;br/&gt;     1. NH便名でない、またはASWDB(マスタ)に定義される特定の国内提携会社運航でない&lt;br/&gt;     1. 出発地または到着地が日本国内でない(&#x3D;国際線である)&lt;br/&gt;   1. 以下のいずれかに該当する(パラメータチェックNG)&lt;br/&gt;     1. 申込種別が申込で、小児情報、見送り人情報、出迎え人情報のいずれかが存在しない(各情報の内容が一部欠けている場合も含む)&lt;br/&gt;     1. 電話番号の形式チェックNG(国番号が日本である場合は9~11桁、日本以外の場合は16桁以内を正とする)&lt;br/&gt;     1. 以下のいずれかが、ASWDB(マスタ)に定義されたリストと一致しない&lt;br/&gt;         1. 見送り人情報、出迎え人情報それぞれの電話番号国、続柄&lt;br/&gt;         1. 小児が話す言語&lt;br/&gt;     1. 小児情報、見送り人情報、出迎え人情報配下の各項目に、アルファベット・数字以外が含まれる&lt;br/&gt;     1. 指定されたバウンドIDに紐づくバウンド情報が取得したPNR情報内に存在しない&lt;br/&gt;   1. ジュニアパイロットサービス、またはケア不要の旨が登録されていないバウンドに対する取消申込が含まれる&lt;br/&gt; 1. 指定されたバウンドごとに、申込種別に応じた登録/削除処理を行う。&lt;br/&gt;   1. 申込種別がジュニアパイロットサービスの登録である場合、以下の処理を行う。&lt;br/&gt;     1. 当該バウンドに含まれる全セグメントに、以下の内容を含むOSIエレメントを3つ登録する。&lt;br/&gt;         1. 当該セグメントの便名・出発空港、”ESCORTED BY”(固定値)、リクエストパラメータにて指定された見送り人氏名・続柄・国番号・電話番号&lt;br/&gt;         1. 当該セグメントの便名・到着空港、”MET BY”(固定値)、リクエストパラメータにて出迎え人氏名・続柄・国番号・電話番号&lt;br/&gt;         1. 当該セグメントの便名、リクエストパラメータにて指定された小児が話す言語&lt;br/&gt;             ※登録する3つのOSIエレメントは搭乗者1名分の情報とし、複数の搭乗者が存在する場合はOSIエレメント3つを全員分登録する(3名の場合は3×3&#x3D;9つのOSIエレメントを登録する)。&lt;br/&gt;             ※各OSIの具体的なフォーマットは内部設計にて記載。&lt;br/&gt;     1. コード&#x3D;\&quot;UMNR\&quot;であるSSRエレメントのフリーテキスト部に\&quot;NOCARE\&quot;が存在する場合、フリーテキスト部を削除する。&lt;br/&gt;     1. キーワード&#x3D;\&quot;OKBP\&quot;、フリーテキスト部&#x3D;\&quot;MINOR NOCARE\&quot;であるSKエレメントが存在する場合、それを削除する。&lt;br/&gt;   1. 申込種別がケア不要の旨の登録である場合、以下の処理を行う。&lt;br/&gt;     1. コード&#x3D;\&quot;UMNR\&quot;であるSSRエレメントのフリーテキスト部に\&quot;NOCARE\&quot;を追加する。&lt;br/&gt;     1. キーワード&#x3D;\&quot;OKBP\&quot;、フリーテキスト部&#x3D;\&quot;MINOR NOCARE\&quot;のSKエレメントを登録する。&lt;br/&gt;     1. 先頭が”UMN”であるOSIエレメントが存在する場合は、それを全て削除する。&lt;br/&gt;   1. 申込種別が取消の場合、対象のバウンドに含まれるセグメントに登録されている情報に応じて以下の処理を行う。&lt;br/&gt;     1. ジュニアパイロットサービス取り消し時は先頭が”UMN”であるOSIエレメントを削除する。&lt;br/&gt;     1. ケア不要取り消し時は以下の処理を行う。&lt;br/&gt;         1. コード&#x3D;\&quot;UMNR\&quot;であるSSRエレメントのフリーテキスト部から、\&quot;NOCARE\&quot;を削除する。&lt;br/&gt;         1. キーワード&#x3D;\&quot;OKBP\&quot;、フリーテキスト部&#x3D;\&quot;MINOR NOCARE\&quot;であるSKエレメントを削除する。&lt;br/&gt; 1. ステータスコード200(OK)で呼び出し元に返却する。&lt;br/&gt;  # 3. データ更新内容 | 更新フィールド | 更新内容 | データ取得元 | 条件等 | | ---: | :--- | :--- | :--- | | OSI | \&quot;\&quot;OSI NH /UMN/\&quot;\&quot; + 便名キャリアコード + 便番号 + \&quot;\&quot;/\&quot;\&quot; + 当該セグメントの出発空港コード + \&quot;\&quot;ESCORTED BY \&quot;\&quot; + 見送り人姓 + \&quot;\&quot;/\&quot;\&quot; + 見送り人名 + \&quot;\&quot;/\&quot;\&quot; + 見送り人の続柄 + 見送り人の電話国番号 + \&quot;\&quot; TEL \&quot;\&quot; + 見送り人の電話番号 + \&quot;\&quot;/P\&quot;\&quot; + 当該搭乗者ID |1.リクエストパラメータ&lt;br&gt;1-1.バウンドID&lt;br&gt;1-2.見送り人の名前&lt;br&gt;1-3.見送り人の電話国番号&lt;br&gt;1-4.見送り人の電話番号&lt;br&gt;1-5.見送り人の続柄&lt;br&gt;2.PNR情報&lt;br&gt;2-1.バウンド情報リスト&lt;br&gt;2-1-1.セグメント情報リスト&lt;br&gt;2-2.搭乗者情報リスト&lt;br&gt;2-2-1.搭乗者ID  |ジュニアパイロットサービスの登録を行う場合  | | OSI | \&quot;\&quot;OSI NH /UMN/\&quot;\&quot; + 便名キャリアコード + 便番号 + \&quot;\&quot;/\&quot;\&quot; + 当該セグメントの到着空港コード + \&quot;\&quot;MET BY \&quot;\&quot; + 出迎え人姓 + \&quot;\&quot;/\&quot;\&quot; + 出迎え人名 + \&quot;\&quot;/\&quot;\&quot; + 出迎え人の続柄 + 出迎え人の電話国番号 + \&quot;\&quot; TEL \&quot;\&quot; + 出迎え人の電話番号 + \&quot;\&quot;/P\&quot;\&quot; + 当該搭乗者ID |1.リクエストパラメータ&lt;br&gt;1-1.バウンドID&lt;br&gt;1-2.出迎え人の名前&lt;br&gt;1-3.出迎え人の電話国番号&lt;br&gt;1-4.出迎え人の電話番号&lt;br&gt;1-5.出迎え人の続柄&lt;br&gt;2.PNR情報&lt;br&gt;2-1.バウンド情報リスト&lt;br&gt;2-1-1.セグメント情報リスト&lt;br&gt;2-2.搭乗者情報リスト&lt;br&gt;2-2-1.搭乗者ID  |ジュニアパイロットサービスの登録を行う場合  | | OSI | \&quot;\&quot;OSI NH /UMN/\&quot;\&quot; + 便名キャリアコード + 便番号 + \&quot;\&quot;/\&quot;\&quot; + 小児が話す言語 + 当該搭乗者ID |1.リクエストパラメータ&lt;br&gt;1-1.バウンドID&lt;br&gt;1-2.小児が話す言語&lt;br&gt;2.PNR情報&lt;br&gt;2-1.バウンド情報リスト&lt;br&gt;2-1-1.セグメント情報リスト&lt;br&gt;2-2.搭乗者情報リスト&lt;br&gt;2-2-1.搭乗者ID  |ジュニアパイロットサービスの登録を行う場合  | | SSR | コード&#x3D;\&quot;UMNR\&quot;のSSRエレメントのフリーテキスト部に\&quot;NOCARE\&quot;を追加 |  | ケア不要の旨の登録を行う場合  | | SK | キーワード&#x3D;\&quot;OKBP\&quot;、フリーテキスト部&#x3D;\&quot;MINOR NOCARE\&quot; |  | ケア不要の旨の登録を行う場合  | | OSI | 先頭が\&quot;UMN\&quot;のものを削除 |  | ジュニアパイロットサービスの取消を行う場合  | | SSR | コード&#x3D;\&quot;UMNR\&quot;のSSRエレメントのフリーテキスト部から\&quot;NOCARE\&quot;を削除 |  | ケア不要の旨の取消を行う場合  | | SK | キーワード&#x3D;\&quot;OKBP\&quot;、フリーテキスト部&#x3D;\&quot;MINOR NOCARE\&quot;であるSKエレメントを削除 |  | ケア不要の旨の取消を行う場合  |
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public ordersJuniorPilotPost(
    generated?: JuniorPilotRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<JuniorPilotResponse>;
  public ordersJuniorPilotPost(
    generated?: JuniorPilotRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<JuniorPilotResponse>>;
  public ordersJuniorPilotPost(
    generated?: JuniorPilotRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<JuniorPilotResponse>>;
  public ordersJuniorPilotPost(
    generated?: JuniorPilotRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/orders/junior-pilot`;
    return this.httpClient.request<JuniorPilotResponse>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要 ペットらくのりの申込を行う。&lt;br/&gt; # 2. 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、&lt;br/&gt;   エラーハンドリング(API)(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返却する。&lt;br/&gt; 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br/&gt;   有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。  &lt;br/&gt; 1. リクエストパラメータの予約番号とcredential情報に基づき、PNR情報取得APIからPNR情報を取得する。&lt;br/&gt; 1. PNR情報が取得できなかった、またはPNR情報に含まれるペットらくのり利用可否判定が利用不可の場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. 以下のいずれかに該当する場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;    返却するエラーコードは該当した条件に応じて異なるものとする。&lt;br/&gt;   1. 取得したPNR情報にて、一部のセグメントについてペットらくのりのサービスカタログ情報が存在しないとされている&lt;br/&gt;   1. 取得したPNR情報にて、一部搭乗済みとされている&lt;br/&gt;   1. 取得したPNR情報の搭乗者情報サマリにて、大人人数/ヤングアダルト人数がともに0&lt;br/&gt;   1. 取得したPNR情報にて、ペットらくのりのEMDが発券済み&lt;br/&gt;   1. 旅程内の最初のセグメントの出発時刻とサーバ時刻を比較して、24時間を切っている&lt;br/&gt;       ※時刻比較の際はタイムゾーンを考慮するものとする。&lt;br/&gt; 1. リクエストパラメータに対するチェックを行う。&lt;br/&gt;   リクエストパラメータについて、以下いずれかに合致する場合、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。エラー情報には、エラー発生項目を含めるようにする。&lt;br/&gt;   1. リクエストパラメータの代表者IDと搭乗者IDが一致する搭乗者が存在しない&lt;br/&gt;   1. リクエストパラメータの代表者IDと搭乗者IDが一致する搭乗者の種別が\&quot;CHD\&quot;、\&quot;INF\&quot;、\&quot;INS\&quot;のいずれかである&lt;br/&gt;   1. リクエストパラメータのペット情報について、識別子に紐づくSSRエレメントとSKエレメントがPNR情報に存在せず(&#x3D;新規登録)、かつ以下のいずれかに該当する&lt;br/&gt;     1. ペット種類、ケージ区分について、以下のいずれかに該当する&lt;br/&gt;         1. 存在しないまたは空欄&lt;br/&gt;         1. ASWDB(マスタ)にそれぞれについて定義されたリストと一致しない&lt;br/&gt;     1. ケージ区分が持ち込みで、かつ奥行、幅、高さが存在しないか空欄、または合計値が設定ファイルに定義されたサイズ制限より大きい&lt;br/&gt;     1. ケージ区分が貸し出しで、かつ以下のいずれかに該当する&lt;br/&gt;         1. 貸し出しケージの種類が存在しないまたは空欄&lt;br/&gt;         1. 貸し出しケージの種類が、ASWDB(マスタ)に定義されたリストと一致しない&lt;br/&gt;         1. 旅程内の最初のセグメントの出発時刻とサーバ時刻を比較して、48時間を切っている&lt;br/&gt;             ※時刻比較の際はタイムゾーンを考慮するものとする。&lt;br/&gt;     1. 重量が存在しないか空欄、または設定ファイルに定義された総重量制限より大きい&lt;br/&gt;     1. 削除であるかがtrue&lt;br/&gt;   1. リクエストパラメータのペット情報について、識別子に紐づくSSR情報とSK情報がPNR情報に存在し、かつ削除であるかがfalse(&#x3D;内容変更)で、新規登録の場合のいずれかの条件に該当する&lt;br/&gt;   1. (PNR情報に登録されているペットらくのりの申込件数 + 識別子に紐づくSSRエレメントとSKエレメントがPNR情報に存在しないペット情報の件数 - 削除であるかがtrueであるペット情報の件数)が9より大きい&lt;br/&gt; 1. ペット情報の件数分、内容に応じた登録/更新/削除処理を行う。   1. 識別子に紐づくSSRエレメントとSKエレメントがPNR情報に存在しない場合、新規登録として以下の処理を行う。&lt;br/&gt;    1. 全セグメントに、ケージ区分に応じて以下の内容のSKエレメントを登録する。&lt;br/&gt;         1. 当該ペット情報のケージ区分が持ち込みの場合、キーワード&#x3D;\&quot;APCP\&quot;、フリーテキスト＝ケージサイズ(奥行+幅+高さの合計値)＋重量(※1)+識別子(※2)&lt;br/&gt;         1. 当該ペット情報のケージ区分が貸し出しの場合、キーワード&#x3D;\&quot;APCx\&quot;(xは貸し出しケージの種類に応じて、S/M/L)、フリーテキスト＝重量(※1)+識別子(※2)&lt;br/&gt;    1. 全セグメントに、コード&#x3D;\&quot;AVIH\&quot;、フリーテキスト&#x3D;識別子(※)のSSRエレメントを登録する。&lt;br/&gt;   1. 削除であるかがtrueの場合は当該ペット情報の削除を行う。キーワード&#x3D;\&quot;APCP\&quot;、\&quot;APCx\&quot;(xはS/M/Lのいずれか)であるSKエレメント、またはコード&#x3D;\&quot;AVIH\&quot;であるSSRエレメントの内、フリーテキストに識別子(※)が含まれるものを削除する。&lt;br/&gt;   1. 識別子に紐づくSSRエレメントとSKエレメントがPNR情報に存在する場合、内容変更として、削除であるかがtrueの場合の処理を行った後、新規登録である場合の処理を行う。&lt;br/&gt;       ※1 ケージ区分が持ち込みの場合はケージとペットの総重量、貸し出しの場合はペットのみの重量&lt;br/&gt;       ※2「CAGE1」のような、固定文字＋数字の組み合わせ&lt;br/&gt; 1. ステータスコード200(OK)で呼び出し元に返却する。&lt;br/&gt;  # 3. データ更新内容 | 更新フィールド | 更新内容 | データ取得元 | 条件等 | | ---: | :--- | :--- | :--- | | SK | キーワード&#x3D;\&quot;APCP\&quot;、フリーテキスト部&#x3D;\&quot;ケージサイズ+重量+識別子\&quot; |  | ケージ持ち込みで登録を行う場合  | | SK | キーワード&#x3D;\&quot;APCS\&quot;、フリーテキスト部&#x3D;\&quot;ケージサイズ+重量+識別子\&quot; |  | Sサイズのケージ貸し出しで登録を行う場合  | | SK | キーワード&#x3D;\&quot;APCM\&quot;、フリーテキスト部&#x3D;\&quot;ケージサイズ+重量+識別子\&quot; |  | Mサイズのケージ貸し出しで登録を行う場合  | | SK | キーワード&#x3D;\&quot;APCL\&quot;、フリーテキスト部&#x3D;\&quot;ケージサイズ+重量+識別子\&quot; |  | Lサイズのケージ貸し出しで登録を行う場合  | | SSR | コード&#x3D;\&quot;AVIH\&quot;、フリーテキスト部&#x3D;識別子 |  | 登録を行う場合  | | SK | キーワード&#x3D;\&quot;APCP\&quot;、\&quot;APCS\&quot;、\&quot;APCM\&quot;、\&quot;APCL\&quot;のいずれかで、フリーテキストに識別子が含まれるものを削除 |  | 申込済みのペット情報の削除、または内容変更を行う場合  | | SSR | コード&#x3D;\&quot;AVIH\&quot;で、フリーテキストに識別子が含まれるものを削除 |  | 申込済みのペット情報の削除、または内容変更を行う場合  |
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public ordersPetRakunoriPost(
    generated?: PetRakunoriRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<PetRakunoriResponse>;
  public ordersPetRakunoriPost(
    generated?: PetRakunoriRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<PetRakunoriResponse>>;
  public ordersPetRakunoriPost(
    generated?: PetRakunoriRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<PetRakunoriResponse>>;
  public ordersPetRakunoriPost(
    generated?: PetRakunoriRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/orders/pet-rakunori`;
    return this.httpClient.request<PetRakunoriResponse>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要 暗号化された予約検索パラメータの復号、パラメータの検証を行い、詳細パラメータの分割をして項目を返却する。&lt;br/&gt;&lt;br/&gt; # 2. 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、エラーハンドリング(API)(G01-010)を利用して&lt;br/&gt;   Mulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返却する。&lt;br/&gt;   ※ エラー情報には、エラーコードごとにエラー発生項目が含まれる。 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br/&gt;   有効でない場合、ステータスコード401でエラー情報を返して、本処理を中止とする。  1. リクエストで受け取ったパラメータを基に、以下の項目検証を行う。&lt;br/&gt;   検証がNGの場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。   1. 処理区分がシームレス連携の場合、TTYPNR連携キーの項目が指定されていること    1. 処理区分がINFINI・Galileo連携の場合、サイトID、暗号化方式、INFINI、Galileo専用キー項目の暗号化連携データ、連携データハッシュ値の項目が全て指定されていること、&lt;br/&gt;      かつ、国コードが”JPN”、言語コードが”ja” または”en”であること   1. 処理区分が国内ASW連携の場合、国内ASW連携専用キー項目の暗号化連携データが指定されていること 1. 処理区分がシームレス連携の場合、以下の内容で復号を行う。   1. TTYPNR連携キーを16進表記の文字列からバイナリに変換し、さらにBlowFish方式で復号する。復号に必要な情報は設定ファイルより取得する。&lt;br/&gt;      変換、復号に失敗または復号した文字列の文字数が62文字以外の場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。   1. 復号した文字列を6/25/25/6桁の4つに分割し、順に予約番号、旅客名(姓)、旅客名(名)、企業IDとする。&lt;br/&gt;      企業IDが設定ファイルにシームレス連携サイト企業IDに含まれない場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。 1. 処理区分がINFINI・Galileo連携の場合、以下の内容で復号を行う。   1. INFINI、Galileo専用キー項目の暗号化連携データを16進表記の文字列からバイナリに変換し、さらに暗号化方式で指定された方式（AES）で復号する。&lt;br/&gt;      復号に必要な情報は設定ファイルより取得する。&lt;br/&gt;      連携データハッシュ値は16進数でエンコードされているため、デコードを実施する。サイトID、暗号化方式、復号後のINFINI、Galileo専用キー項目の暗号化連携データ、&lt;br/&gt;      国コード、言語コードを連結しMD5でハッシュ値を算出する。&lt;br/&gt;      変換、復号に失敗または復号した文字列を用いて算出したハッシュ値とデコードした連携データハッシュ値が一致しないの場合、ステータスコード400(Bad Request)で&lt;br/&gt;      エラー情報を返して、本処理を中止とする。   1. 復号した文字列をカンマ区切りで分割し、順に予約番号、旅客名(姓)、旅客名(名)、航空券番号、便名、搭乗月、搭乗日、AMC会員番号、URL生成日付とする。&lt;br/&gt;      分割した項目が９つ以外、またはURL生成日付が規定時間内（設定ファイルより取得）でない場合、ステータスコード400(Bad Request)でエラー情報を返して、&lt;br/&gt;      本処理を中止とする。 1. 処理区分が国内ASW連携の場合、以下の内容で復号を行う。   1. 国内ASW連携専用キー項目の暗号化連携データを16進表記の文字列からバイナリに変換し、さらにBlowFish方式で復号する。復号に必要な情報は設定ファイルより取得する。&lt;br/&gt;      変換、復号に失敗した場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。   1. 復号した文字列をアンパサンド（＆）区切りで分割し、順に予約番号、航空券番号、旅客名(姓)、旅客名(名)とする。&lt;br/&gt;      分割した項目が４つでない場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止する。 1. ステータスコード200を返却する。  # 3. データ更新内容 なし  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public ordersSearchDecryptionPost(
    generated?: SearchDecryptionRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<SearchDecryptionResponse>;
  public ordersSearchDecryptionPost(
    generated?: SearchDecryptionRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<SearchDecryptionResponse>>;
  public ordersSearchDecryptionPost(
    generated?: SearchDecryptionRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<SearchDecryptionResponse>>;
  public ordersSearchDecryptionPost(
    generated?: SearchDecryptionRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/orders/search-decryption`;
    return this.httpClient.request<SearchDecryptionResponse>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要 CAS経由で予約確認メールを送信する。 # 2. 処理概要 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、&lt;br/&gt;   エラーハンドリングAPI(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返却する。&lt;br/&gt; 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br/&gt;   有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。  &lt;br/&gt; 1. 予約確認メール送信先アドレスについて、フォーマットが不正（共通部品、G03-501を使用）の場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。        &lt;br/&gt; 1. リクエストパラメータの予約番号とcredential情報をもとに、PNR情報取得APIからPNR情報を取得する。        &lt;br/&gt;   PNR情報が取得できなかった場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. リクエストパラメータ及びPNR情報をもとに、CASへ予約確認メールの送信リクエストを行う。&lt;br/&gt;   CASからエラーが返ってきた場合、ステータスコード400でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. 正常終了の場合、HTTPステータスコード200を返却し、処理を終了する。&lt;br/&gt;  # 3. データ更新内容 なし  # 4. 特記事項 なし
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public ordersSendConfirmationMailPost(
    generated?: SendConfirmationMailRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<SendConfirmationMailResponse>;
  public ordersSendConfirmationMailPost(
    generated?: SendConfirmationMailRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<SendConfirmationMailResponse>>;
  public ordersSendConfirmationMailPost(
    generated?: SendConfirmationMailRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<SendConfirmationMailResponse>>;
  public ordersSendConfirmationMailPost(
    generated?: SendConfirmationMailRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/orders/send-confirmation-mail`;
    return this.httpClient.request<SendConfirmationMailResponse>(
      'post',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: generated,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * # 1.概要&lt;br/&gt; DxAPIを呼び出して指定した事前座席指定含むサービスの申込および、有料サービスの場合はAncillaryサービスの購入/発券処理を行う。&lt;br/&gt; 当APIは予約番号を基にした処理、カートIDを基にした処理の2つをサポートし、カートIDを基にする場合は、サービスの購入/発券は航空券の発券と合わせて購入発券APIにて&lt;br/&gt; 行うため、本APIでは事前座席指定についての処理のみを行う。また、予約番号を基にした処理で、未発券の場合は、無料の座席指定およびサービスのみ申し込みを可とする。&lt;br/&gt; DxAPIにおいては、座席指定、サービス申込、購入・発券が別々のリクエストに分かれており、APIの内部リクエストでそれぞれのリクエストを必要に応じて順次実施する。 &lt;br/&gt; 1. 座席指定が指定されている場合、以下の処理となる。&lt;br/&gt; 座席属性指定、カウチ席のSSR登録、チャイルドシートのSK登録については、本処理ではなくサービス申込として処理する。     1. PNRのSSR登録状況とリクエストパラメータの内容が同一かどうかの確認を行う。すべての項目が同一の場合はSSR登録後、購入を中断した後の再試行とみなし、座席&lt;br/&gt;     指定処理を行わない。     1. リクエストパラメータに指定されている便に対し、すでに座席が登録済みの場合は、SSR登録済み座席の削除を行う。また、削除する席がカウチ席の場合、カウチSSR(SSR COxx)の削除も&lt;br/&gt;     サービス申込のリクエストを利用して行う。&lt;br/&gt;     ※ 登録済みの場合は、座席の取消または変更が該当する。DxAPIが変更操作をサポートしていないため、変更の場合も一度削除をして新しい座席を登録する。     1. 同一セグメントで登録済みの座席属性があった場合、座席属性の削除をサービス申込のリクエストを利用して行う。     1. リクエストパラメータに指定されている座席情報をもとに、座席の登録を行う。 &lt;br/&gt; 1. サービス申込が指定されている場合、以下の処理となる。&lt;br/&gt; 座席属性指定、カウチ席のSSR登録、チャイルドシートのSK登録はこの処理で実施する。     1. PNRのSSR登録状況とリクエストパラメータの内容が同一かどうかの確認を行う。すべての項目が同一の場合はサービス申込を行わない。     1. リクエストパラメータに指定されている便に対し、すでに機内食が指定されており、登録済みの場合または更新区分：削除の場合は、登録済み機内食の削除を行う。     1. リクエストパラメータに指定されている便に対し、すでにチャイルドシートが指定されており、登録済みの場合または更新区分：削除の場合は、PNRに紐づく全セグメントに対してチャイルドシートの&lt;br/&gt;     削除を行う。     1. リクエストパラメータに座席属性が指定されている場合、同一セグメントのSSR登録済み座席の削除を行う。また、削除する席がカウチ席の場合、カウチSSR(SSR COxx)&lt;br/&gt;     の削除もサービス申込のリクエストを利用して行う。また、登録済みの座席属性があれば削除を行う。     1. リクエストパラメータに指定されているサービス申込情報、座席情報をもとに登録を実施する。 &lt;br/&gt; 1. 支払リクエスト情報が指定されている場合、以下の購入・発券処理を実施する。&lt;br/&gt; 支払方法に応じたDxAPIの購入/発券処理は以下の流れとなる。     1. クレジットカード決済の場合、3Dセキュア(以下、3DSとする)による認証要否に応じて以下の処理となる。         1. Cardinalを利用した決済になる場合             1. 当APIの処理を一度中断し、呼び出し元にてCardinalを利用して端末情報を収集し、収集した情報にて再度購入/発券処理を行う。&lt;br/&gt;             中断時、呼び出し元にて実施する処理に必要な情報を返却する。             1. リクエストされたクレジットカード情報に対して3DSv2チャレンジフローまたは3DSv1が適用される場合、再度当APIの処理を中断し、&lt;br/&gt;             呼び出し元にて認証を行い、その認証結果にて再度購入/発券処理を行う。中断時、呼び出し元にて実施する処理に必要な情報を返却する。         1. Cardinalを利用した決済にならず、リクエストされたカード情報に対して3DSv1が適用される場合&lt;br/&gt;         当APIの処理を一度中断し、呼び出し元にて認証を行う。その認証結果にて再度購入/発券処理を行う。&lt;br/&gt;         中断時、呼び出し元にて実施する処理に必要な情報を返却する。         1. 3DSが適用されない場合、リクエストされたクレジットカード情報により購入/発券処理を行う。     1. AMOP(銀聯、Alipay、Paypal)による決済の場合、当APIの処理を一度中断し、呼び出し元にて外部決済サイトへリダイレクトして認証を行う。&lt;br/&gt;     その認証結果にて再度購入/発券処理を行う。&lt;br/&gt;     中断時、呼び出し元にて実施する処理に必要な情報を返却する。 &lt;br/&gt; 1. 購入・発券処理が完了した際、以下の処理を行う。     1. カウチ関連の後処理として以下の処理を行う。         1. SK COUCが登録されているセグメント・搭乗者について、実際には座席を選択しなかった場合、SK COUCを削除         1. 申込したサービスの中にカウチ席が含まれている場合、RMエレメント(RM SKYLINK)の登録、SSR BSCTがあった場合削除、利用人数が座席数より少ない場合、&lt;br/&gt;         カウチ用NCP作成のためにキューイング         1. SK COUC削除用タイマータスクが存在する場合、タスクを削除     1. SK STEBが登録されているPNRについて、実際には座席を選択しなかった場合、SK STEBを削除する。     1. 事前手荷物について、空席待ちアップグレード済みのセグメントが存在する、かつ、SSR FQTUがリレートされたセグメント/搭乗者が存在する場合、RMエレメントを&lt;br/&gt;     登録する。     1. 申込したそれぞれのAncillaryサービスに対してPNRをキューイングする。     1. リクエストパラメータに、搭乗者メールアドレスおよび電話番号が存在する場合、PNRへ登録する。     1. Ancillaryサービスの購入を行った場合、有料サービス申込完了メールを送信する。その際、メールには以下のファイルが添付される。         1. EMD控え         1. クレジットカードによる支払額が存在する場合、CCCF         1. 操作オフィスのPOSが日本である場合、領収書     1. リクエストパラメータに予約基本情報更新内容が存在する場合、予約基本情報の更新を行う。  # 2.処理内容&lt;br/&gt;  1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、エラーハンドリング(API)(G01-010)を利用してMulesoftが生成した&lt;br/&gt; エラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返却する。&lt;br/&gt; ※ エラー情報には、エラーコードごとにエラー発生項目が含まれる。 &lt;br/&gt;  1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br/&gt; 有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。 &lt;br/&gt; 1. リクエストパラメータの整合性確認を行う。以下のいずれかに一致する場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。     1. リクエストパラメータのカートID、予約番号がいずれもない     1. リクエストパラメータのカートID、予約番号が両方ある     1. リクエストパラメータの予約番号があるが、搭乗者姓、搭乗者名のいずれかがない     1. リクエストパラメータの事前座席指定において、同一セグメントで座席指定と座席属性の両方に指定がある     1. カートIDが指定されていて、かつ、カウチ席以外のサービスが含まれている     1. カートIDが指定されていて、かつ、搭乗者連絡先情報が指定されている &lt;br/&gt; 1. 会員情報の取得処理を行う。以下のいずれかに合致する場合、呼び出し元より渡されたアクセストークンを復号し、トークン内に含まれるuuidを基に、ASWDB(Tx)から&lt;br/&gt; ログイン中の会員情報を取得する。&lt;br/&gt; AMC会員番号を取得できなかった、かつリクエストパラメータが以下のいずれかに合致する場合はステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止&lt;br/&gt; とする。&lt;br/&gt; ※COMMON-005共通部品利用予定※詳細処理は確認中     1. クレジットカード情報が存在する、かつ予約基本情報利用カード種別が存在する。     1. 予約基本情報更新内容が存在する。 &lt;br/&gt; 1. PNR情報取得APIを呼び出す。&lt;br/&gt; 予約番号が指定されている場合は予約番号を、カートIDが指定されている場合はカートIDをリクエストへ設定し、PNR情報取得APIを呼び出す。PNRが取得できなかった場合、&lt;br/&gt; ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。 &lt;br/&gt; 1. 予約番号および支払リクエスト情報がリクエストパラメータに設定されている場合、以下を実施する。&lt;br/&gt; リクエストパラメータについて、以下いずれかに合致する場合、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。エラー情報には、エラー&lt;br/&gt; 発生項目を含めるようにする。     1. 以下のいずれも存在しない。         1. クレジットカード情報         1. AMOP情報     1. クレジットカード情報、AMOP情報の両方が同時に存在する。     1. 操作デバイスが、支払方法ごとに定義した利用可能デバイス(PC/SP/TAB)ではない。&lt;br/&gt;     支払方法ごとの利用可能デバイスはASWDB(マスタ)から取得する。     1. クレジットカード情報が存在する、かつ以下のいずれかに合致する。         1. 予約基本情報更新内容のクレジットカード登録名称が存在するかつ、クレジットカード情報のクレジットカード番号が存在しない。         1. 予約基本情報利用カード種別とクレジットカード番号が両方存在しない。         1. 予約基本情報利用カード種別とクレジットカード番号が両方存在する。         1. セキュリティコードが存在しないかつ、以下の全てに合致する。             1. 認証パラメータ(3DSv1支払認証パラメータまたは3DSv2支払認証パラメータ)が存在しない。v             1. UATPカードであるかがUATPカードではない。         1. UATPカードであるかがUATPカードである場合、操作オフィスのPOSがUATPカード利用可能POSではない。&lt;br/&gt;         UATPカード利用可能POSはASWDB(マスタ)から取得する。         1. クレジットカード有効期限の年が現在の年から14年後の範囲ではない。         1. 認証パラメータ(3DSv1支払認証パラメータまたは3DSv2支払認証パラメータ)が存在しないかつ、支払者識別情報が存在しない。         1. 支払者識別情報が存在する、かつ以下のいずれかに合致する。             1. メールアドレスのフォーマットが不正(共通部品、G03-501を使用)である。             1. 電話番号の国コードが日本である、かつ電話番号が9～11桁ではない。     1. AMOP情報が存在する場合、かつ以下のいずれかに合致する。         1. AMOP情報の支払方法が銀聯またはAlipayである、かつ操作オフィスのPOSが中国ではない。         1. AMOP情報の支払方法がPaypalである、かつ利用可能POSではない。&lt;br/&gt;         操作オフィスごとのPayPalの利用可否はASWDB(マスタ)から取得する。         1. 支払認証用HTTPリクエスト情報のHTTPメソッドの値が\&quot;POST\&quot;である、かつリクエストパラメータ情報リストが存在しない。 &lt;br/&gt; 1. リクエストパラメータに座席指定がある場合、シートマップ情報を取得するためにシートマップ取得APIを呼び出し、&lt;br/&gt; シートマップ情報が取得できなかった場合はステータスコード400（Bad request）でエラー情報を返却して、本処理を中止とする。&lt;br/&gt; なお、チャイルドシートが指定されている場合、全セグメント分を取得することとする。 &lt;br/&gt; 1. リクエストパラメータに設定されている座席の内容と取得したシートマップ情報を照合し、以下の内容を処理する。     1. 以下のいずれかに合致する場合、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。エラー情報には、エラー発生項目を含めるよう&lt;br/&gt;     にする。         1. 事前座席指定が指定されている場合で、かつ、以下のいずれかに合致する。             1. セグメントID、座席番号がシートマップ情報上に存在しない。             1. 予約番号が指定されていて、座席が有料ASR席またはカウチ席であり、かつ、支払リクエストの指定がない。         1. チャイルドシートが指定されている場合で、リクエストパラメータに指定されている搭乗者IDをもとに、全セグメント分のシートマップ情報を確認し、&lt;br/&gt;         以下のいずれかに合致する。             1. チャイルドシート申込に指定されている搭乗者がリクエストしている座席番号とシートマップ情報を照合し、該当の座席がチャイルドシート装着可能席&lt;br/&gt;             ではない。             1. チャイルドシートが申込済みと未申込のセグメントが混在している。     1. 以下のいずれかに合致する場合、ワーニング情報を設定し、事前座席指定の登録処理の対象からも除外する。ワーニング情報には、ワーニング発生項目を含める&lt;br/&gt;     ようにする。         1. 事前座席指定が指定されている場合で、かつ、以下のいずれかに合致する。             1. 座席番号に対する当該搭乗者の座席選択可否がavailableではない。             1. 事前座席指定可能時間を過ぎている。（※現在日付は、出発空港コードに紐づく空港のタイムゾーンを考慮した時刻換算を行って比較を行う。）&lt;br/&gt;             空港ごとの時差はASWDB(マスタ)から取得する。  &lt;br/&gt; 1. リクエストパラメータにサービス申込が指定されている場合、カタログ情報を取得するためにDxAPIを呼び出す。&lt;br/&gt; カタログ情報が取得できなかった場合はステータスコード400（Bad request）でエラー情報を返却して、本処理を中止とする。 &lt;br/&gt; 1. リクエストパラメータにサービス申込が指定されている場合、機内食情報取得APIを呼び出す。&lt;br/&gt; 機内食情報が取得できなかった場合はステータスコード400（Bad request）でエラー情報を返却して、本処理を中止とする。 &lt;br/&gt; 1. リクエストパラメータにサービス申込が指定されていて、各サービスが以下のいずれかに合致する場合、&lt;br/&gt; ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。エラー情報には、エラー発生項目を含めるようにする。     1. リクエストパラメータのバウンドID、セグメントID、搭乗者ID、SSRコードのデータが取得したカタログ情報上に存在しない。     1. リクエストパラメータのSSRコードがASWDB(マスタ)にてAncillaryサービスとして定義されていて、ASWDB(マスタ)の有料サービス情報が以下のいずれかに合致する。         1. セグメントの出発日時が、サービス受付可能出発前時間を過ぎている。         1. グループPNR申込可否に対象外が設定されていて、かつ、PNR情報取得APIで取得したグループPNR区分がtrue。         1. 社員用PNR申込可否に対象外が設定されていて、かつ、PNR情報取得APIで取得した社員用PNR区分がtrue。         1. 削除区分に削除不可が設定されていて、かつ、リクエストパラメータの更新区分が削除が指定されている。         1. 支払リクエストの指定がない。     1. リクエストパラメータのSSRコードが機内食情報取得APIから取得した機内食情報に特別機内食、事前ミールオーダーのいずれかとして定義されていて、以下の&lt;br/&gt;     いずれかに合致する。         1. 機内食取得APIより取得した申込期限識別子が申込期限を過ぎている。         1. 指定されている機内食の在庫がない。         1. 同一搭乗者IDに機内食が2つ指定されていて、片方が幼児用のミールではない。     1. リクエストパラメータのSSRコードがASWDB(マスタ)にて有料ミール(Ancillary情報を使って判定)、特別機内食、事前ミールオーダーのいずれかとして定義され&lt;br/&gt;     ていて、当該搭乗者が既に有料ミールのSSRをSSRステータス＝HKまたはKKで申込済みで、リクエストパラメータの更新区分が登録（登録済みの有料ミールを別の&lt;br/&gt;     機内食に変更しようとした場合）     1. リクエストパラメータのバウンドID、セグメントID、搭乗者ID、SSRコードのデータで取得したカタログ情報上の在庫がない。     1. ラウンジが指定されている場合で、以下のいずれかに合致する。         1. セグメントIDと搭乗者IDをもとにPNR情報取得APIで取得したサービス情報を確認し、申込不要でラウンジを利用できる搭乗者である。         1. すでにチェックイン済みである。     1. 事前手荷物が指定されている場合で、以下のいずれかに合致する。         1. 米国発着のセグメント、またはカナダ発着のセグメントが存在する。         1. 日本国内区間で不可として設定された運航キャリアのセグメントを含むバウンドである。※運航キャリアについては設定ファイルにて管理する。 &lt;br/&gt; 1. 以下の処理にて、DxAPIを呼び出して事前座席指定に関する処理を実施する。処理途中にエラーが発生しても後続の処理を継続し、失敗した処理の内容をサービス&lt;br/&gt; 申込処理終了まで保持し、サービス申込処理に発生したエラーと合わせて返却する。ただし、PNRのSSRの登録状況がリクエストパラメータの内容と同じ状態の場合は、&lt;br/&gt; 登録は行わない。     1. DxAPIを呼び出し、リクエストパラメータに指定されているセグメントID、搭乗者IDで座席が登録済みの場合、登録済み座席の削除を行う。     1. リクエストパラメータに座席が指定されている場合、セグメントIDを基に座席属性の登録有無を確認し、DxAPIを呼び出して登録されている座席属性の削除を&lt;br/&gt;     行う。※座席属性については、設定ファイルにて定義されたものを取得する。     1. カウチ席が指定されている場合、DxAPIを呼び出し登録済みのサービスの削除を行う。ただし当該カウチ席に属する座席の削除を1席でも失敗していた場合、&lt;br/&gt;     削除は行わない。     1. リクエストパラメータに指定されている座席情報を設定、DxAPIを呼び出し、座席の登録を行う。ただし座席・カウチ種別の削除に失敗したセグメント・搭乗者&lt;br/&gt;     の座席は登録しない。また、カウチ席の登録に失敗した場合は、失敗したカウチ席と同一ブロックの登録済みの座席の削除を行う。     1. DxAPIの呼び出し時に、以下のエラーが返却された場合、エラー情報を保持する。&lt;br/&gt;     失敗した座席がカウチ席の場合は、失敗したカウチ席と同一ブロックの登録済みの座席の削除を行う。         1. 座席指定失敗 &lt;br/&gt; 1. DxAPIを呼び出してサービス申込に関する処理を実施する。処理途中にエラーが発生しても後続の処理を継続し、失敗した処理の内容を事前座席指定処理から引き継がれた&lt;br/&gt; エラー情報に追加し、サービス申込処理終了まで保持し、サービス申込処理で発生したエラーと合わせて返却する。     1. PNR情報取得APIで取得した登録済みサービス情報を確認し、リクエストパラメータに指定されているすべてが以下の内容で一致しているかを確認する。&lt;br/&gt;     PNRのSSRの登録状況がリクエストパラメータの内容と同じ状態場合は、登録は行わない。         1. サービス申込のSSRコード：”FBAG”の場合、予約情報の登録済みサービス情報の手荷物情報と一致する。         1. サービス申込のSSRコード：”LOUG”の場合、予約情報の登録済みサービス情報のラウンジ情報と一致する。         1. サービス申込のSSRコード：上記以外の場合、予約情報の登録済みサービス情報の機内食情報と更新区分：登録のときは一致し、更新区分：削除の時は一致しない。         1. 座席属性に指定がある場合、予約情報の座席指定の座席属性と一致する。         1. チャイルドシートに指定がある場合、予約情報の座席指定のチャイルドシート申込有無がtrueのときに更新区分：登録、falseのときに更新区分：削除。     1. リクエストパラメータに機内食が指定されている場合、以下を実施する。         1. PNR情報取得APIで取得した機内食情報を確認し、リクエストパラメータに指定されている搭乗者IDの機内食が申込済みかどうかを確認する。         1. 申込済みの機内食がある場合、DxAPIを呼び出し、変更する前の既に取得されている機内食、または、リクエストパラメータの更新区分：削除に指定されている&lt;br/&gt;         機内食の削除を行う。     1. リクエストパラメータにチャイルドシートが指定されている場合、以下を実施する。         1. PNR情報取得APIで取得した予約情報の座席指定のチャイルドシート申込有無を確認し、&lt;br/&gt;         リクエストパラメータに指定されている搭乗者IDのチャイルドシートが申込済みかどうかを全セグメント分、確認する。         1. 申込済みのチャイルドシートがあり、更新区分：削除が指定されている場合、DxAPIを呼び出し、全セグメントに対してチャイルドシートの削除を行う。     1. リクエストパラメータに座席属性が指定されている場合、セグメントIDを基に以下の処理を行う。         1. DxAPIを呼び出し登録済み座席の削除を行う。         1. 削除する座席にカウチ席が含まれている場合は、DxAPIを呼び出しカウチSSRも削除を行う。         1. DxAPIを呼び出し登録済みの座席属性の削除を行う。     1. リクエストパラメータに指定されているサービス申込情報、座席属性、チャイルドシート申込をもとにカタログ情報から各サービスのサービスIDを取得したうえで&lt;br/&gt;     DxAPIを呼び出し、サービスの登録を行う。ただし、機内食の削除に失敗した、または事前座席指定処理でカウチ席の登録に失敗したセグメント・搭乗者の登録はしない。     1. サービスの登録の呼び出し時に、エラーが返却された場合、事前座席指定のエラーとまとめて処理を行うため、エラー情報を保持する。&lt;br/&gt;     失敗したサービスにカウチSSRが含まれている場合は、失敗したカウチ席を構成しているすべての座席指定SSRの削除を行う。 &lt;br/&gt; 1. サービス申込処理終了時、事前座席指定処理、サービス申込処理から引き継がれたエラー情報の中を確認し、申込された有料サービスすべてについてワーニングの場合は&lt;br/&gt; ステータスコード400（Bad request）でエラー情報を返却、一部のみワーニングの場合はステータスコード201(Created)でワーニング情報を返却する。有料サービスがワーニング&lt;br/&gt; に含まれていない場合は、支払い・発券以降の処理終了後にステータスコード201(Created)でワーニング情報として返却する。 &lt;br/&gt; 1. 支払リクエスト情報が指定されていない場合、ステータスコード201(Created)で返却する。 &lt;br/&gt; 1. DxAPIを呼び出して支払・発券に関する処理を実施する。     1. 支払リクエスト情報がリクエストパラメータに設定されている場合、以下を実施する。         1. 以下のいずれかに合致する場合、PNRに登録済みかつ支払認証の行われていないFPエレメントを削除する。&lt;br/&gt;         ※PNRに登録済みかつ支払認証の行われていないFPエレメントが存在しない場合は処理を行わない。             1. リクエストにクレジットカード情報が存在する、かつ支払認証パラメータ(3DSv1支払認証パラメータまたは3DSv2支払認証パラメータ)が存在しない。             1. リクエストにAMOP情報が存在する、かつ支払認証用HTTPリクエスト情報が存在しない。         1. 支払方法に応じて以下の処理を行う。             1. リクエストにクレジットカード情報が存在する場合、以下の処理を行う。                 1. リクエストに予約基本情報利用カード種別が存在する場合、ユーザ共通情報の一般用クレジットカード番号を取得する。                 1. リクエストにCardinalから返却されるセッションID、支払認証パラメータ(3DSv1支払認証パラメータまたは3DSv2支払認証パラメータ)がいずれも存在&lt;br/&gt;                 しない場合、DxAPIへクレジットカード情報を送信してDxAPIの3DS初期化処理のリクエストを行い、jwtトークンを取得する。&lt;br/&gt;                 jwtトークンを取得できた場合、セキュアプロバイダがCardinalであるとしてステータスコード201(Created)でjwtトークンを返却して、本処理を中止とする。&lt;br/&gt;                 ※取得できなかった場合はセキュアプロバイダがAmadeusであるとし、以降の処理を継続する。         1. 以下のいずれかが存在する場合、その内容をDxAPIへ送信する情報として設定してDxAPIの購入/発券処理(外部サイトでの認証後用)を行う。             1. クレジットカード情報、支払認証パラメータ(3DSv1支払認証パラメータまたは3DSv2支払認証パラメータ)             1. AMOP情報、支払認証用HTTPリクエスト情報         1. 上記にて購入・発券処理(外部サイトでの認証後用)を実施しなかった場合、DxAPIの購入/発券処理を実施する。支払方法に応じてDxAPIへ送信する情報として、&lt;br/&gt;         以下の内容を設定する。             1. リクエストにクレジットカード情報が存在する場合、クレジットカード情報を設定する。&lt;br/&gt;             ※送信するクレジットカード情報のうち、カードブランドについては、UATPカード以外はブランドを指定せずにカード番号のみを指定する。&lt;br/&gt;             DxAPIから3DS認証が必要である旨の回答がされた場合、ステータスコード201(Created)で支払認証パラメータ(3DSv1支払認証パラメータまたは3DSv2支払認証&lt;br/&gt;             パラメータ)を返却して、本処理を中止とする。&lt;br/&gt;             ※3DS認証が必要である旨の回答がされなかった場合、以降の処理を継続する。             1. リクエストにAMOP情報が存在する、かつ支払認証用HTTPリクエスト情報が存在しない場合、&lt;br/&gt;             AMOP情報の支払方法に応じて、\&quot;paymentMethod\&quot;の\&quot;id\&quot;に設定ファイルにて定義した値を設定する。&lt;br/&gt;             DxAPIから取得した外部サイト用支払認証用HTTPリクエスト情報をステータスコード201(Created)で返却して、本処理を中止とする。     1. DxAPIの呼び出し時に、以下いずれかのエラーが返却された場合、ステータスコード400(Bad request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;     EMDの発券失敗時、EMD発券失敗のキューイングを行う。キューイング先(キューBOX/オフィスコード/カテゴリ)は設定ファイルにて定義する。         1. 決済エラー         1. クレジットカード不正利用検知エラー         1. 発券期限切れエラー&lt;br/&gt;         ※支払総額変更エラーについては、DxAPIから返却されないため、エラーハンドリングしない。 &lt;br/&gt; 1. 購入/申込に成功した場合、以下の処理を行う。     1. 以下のサービスについて、対象が1つでもある場合、サービスの削除を行う。         1. SK STEBが登録されているPNRについて、実際には座席を選択しなかった場合、SK STEB         1. SK COUCが登録されているPNRについて、実際には座席を選択しなかった場合、SK COUC         1. 申込したサービスの中にカウチ席が含まれていて、SSR BSCTが存在する場合、SSR BSCT     1. 以下の条件に合致する場合、合致した条件に応じたRMの登録をそれぞれ行う。         1. 事前追加手荷物について、空席待ちアップグレード済みのセグメントが存在する、かつ、SSR FQTUがリレートされたセグメント/搭乗者が存在する         1. 申込したサービスの中にカウチ席が含まれている     1. 申込したカウチ席のうち、利用人数が座席数より少なくなるカウチ席が存在する場合、カウチ用NCP作成のためにPNRをキューイングする。&lt;br/&gt;     キューイング先は設定ファイルから取得する。     1. 以下の各条件に合致する場合、それぞれのAncillaryサービスに対してPNRをキューイングする。         1. カウチ席について、以下のすべての条件を満たす             1. 直営外PNRである             1. 搭乗者にリレートしている、かつセグメントにリレートしていないカウチ席のEMDが存在する         1. 事前追加手荷物について、以下のすべての条件を満たす             1. 直営外PNRである             1. 搭乗者にリレートしている、かついずれのフライトにもリレートしていないか、リレートしているセグメント数とクーポン数が一致しない事前追加手荷物&lt;br/&gt;             のEMDが存在する         1. ASWDBに設定されている有料サービスのうち、取消EMD運用区分が再利用である有料サービスについて、搭乗者にリレートしているがセグメントにリレートして&lt;br/&gt;         いないEMDが存在する     1. ASWDBのバッチ処理タスクへ登録したSK COUC削除用タイマータスクが存在すれば削除する(ASWDB（Tx）からリクエストパラメータのPNRをキーに未処理タスクを&lt;br/&gt;     削除する)。ただし、PNRのカウチ用SKエレメントの削除に失敗した場合は、SK COUC削除用タイマータスクの削除は行わない。     1. 以下のいずれかの条件を満たしていた有料ASR席の削除を行った場合、PNRをキューイングする。指定するキューイング先は有料ASR取消処理用キューイング種別に&lt;br/&gt;     紐づく設定ファイルから取得する。         1. 有料ASRのSSRとEMDが紐づいている。         1. どの有料ASRのSSRとも紐づかないEMDが存在する。     1. カウチ席の削除を行った場合、PNRをキューイングする。指定するキューイング先はカウチ取消処理用キューイング種別に紐づく設定ファイルから取得する。     1. 有料ミールの取消を行った場合、PNRをキューイングする。指定するキューイング先は有料ミール取消処理用キューイング種別に紐づく設定ファイルから取得する。 &lt;br/&gt; 1. リクエストパラメータに搭乗者メールアドレス、電話番号情報が存在する場合、以下の処理を行う。     1. リクエストパラメータに指定されている搭乗者IDのメールアドレスが登録済みの場合は、登録されているSKを削除したのち、あらたにSKを登録する。未登録の場合&lt;br/&gt;     は、そのままSKを登録する。     1. 搭乗者メールアドレスはSSR CTCE、電話番号はSSR CTCMとしてPNRへ登録し、搭乗者IDの電話番号が登録済みの場合は更新し、未登録の場合は登録する。メール&lt;br/&gt;     アドレスについては登録済みのCTCEの更新、削除はせずに新規に登録する。 &lt;br/&gt; 1. ASWDB(Tx)に予約購入実績を登録する。 &lt;br/&gt; 1. 購入・申込に成功したAncillaryサービスが正常に完了した場合、以下の処理を行う。     1. 直営PNRまたはNDC PNRの場合は、PNRに登録されている代表者メールアドレスへ有料サービス申込完了メールを送信する。     1. リクエストパラメータにメールアドレスが指定されている場合は、指定された宛先へ有料サービス申込完了メールを送信し、メールアドレスをRMエレメントへ登録する。 &lt;br/&gt;     1. リクエストパラメータの予約基本情報の支払方法更新要否に支払方法の更新が指定された、かつ、リクエストパラメータにクレジットカード情報が存在する場合、利用した&lt;br/&gt; 支払方法を「予約基本情報」としてMindsへ登録する。 &lt;br/&gt; 1. リクエストパラメータに予約基本情報更新内容が存在する場合、決済時の情報を基にMindsへ「予約基本情報」の登録、更新を行う。&lt;br/&gt; 「予約基本情報」の登録、更新対象項目は、リクエストパラメータの予約基本情報更新対象が\&quot;paymentCard1\&quot;である場合はいつもの情報クレジットカード1とし、&lt;br/&gt; \&quot;paymentCard2\&quot;である場合はいつもの情報クレジットカード2とする。&lt;br/&gt;     1. リクエストパラメータのクレジットカード登録名称が存在しない場合、リクエストパラメータのクレジットカード有効期限の値で、予約基本情報のクレジットカード&lt;br/&gt;     有効期限を更新する。     1. リクエストパラメータのクレジットカード登録名称が存在する場合、リクエストパラメータのクレジットカード情報を登録する。     1. 「予約基本情報」の登録、更新が成功した場合、登録、更新した内容と同じ内容でASWDB(Tx)のパーソナライズ情報の更新を行う。  # 3.データ更新内容&lt;br/&gt; ## 1.PNR&lt;br/&gt; | 更新フィールド  | 更新内容 | データ取得元 | 条件等 | | :------------- | :------------- | :------------- | :------------- | | FP | クレジット支払情報、クレジット関連情報&lt;br/&gt;(DxAPIの仕様に従う)  |&lt;ol&gt;&lt;li&gt;リクエストパラメータ&lt;ol&gt;&lt;li&gt;クレジットカード番号&lt;/li&gt;&lt;li&gt;クレジットカード有効期限&lt;/li&gt;&lt;li&gt;クレジットカード名義&lt;/li&gt;&lt;li&gt;セキュリティコード&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;br/&gt;※FPのエレメント長を超える値を登録しようとするとエラーになるため、設定ファイルに定義した有料サービス申込用の長さを超える長さの値の場合は、先頭からその長さ分の文字のみを登録するようにする。|有料サービスの申込があり、クレジットカードによって支払う場合 | | FP | “PAX” + “ (半角スペース)” ”UPAMP” + 銀聯カード決済番号 + “/” + “A”  &lt;br/&gt;※フォーマットはDxAPIにて自動で登録される。  |  |銀聯によって全額支払う場合  | | FP | “PAX” + “ (半角スペース)” ”APAMP” + Alipay決済番号 + “/” + “A” &lt;br/&gt;※フォーマットはDxAPIにて自動で登録される。  |  |Alipayによって全額支払う場合  | | FP | “PAX” + “ (半角スペース)” ”PPAMP” + PayPal決済番号 + “/” + “A”&lt;br/&gt;※フォーマットはDxAPIにて自動で登録される。  |  |PayPalによって全額支払う場合  | | SSR | SSRコード＝\&quot;RQST\&quot;（SEG、PAXリレートする） | リクエストパラメータの座席情報 | 座席が未登録の場合、座席のSSRを登録&lt;br/&gt;座席が登録されている場合、登録済みSSRを削除し新しい座席のSSRを登録&lt;br/&gt;リクエストが座席の削除の場合、登録済みSSRを削除&lt;br&gt;カウチ席の登録失敗時に登録した座席情報を削除 | | SSR | SSRコード＝”NSST”、フリーテキスト＝”A”（SEG、PAXリレートする）| リクエストパラメータの座席属性の種類 | 属性指定で通路側を指定した場合 | | SSR | SSRコード＝”NSST”、フリーテキスト＝”W” （SEG、PAXリレートする） | リクエストパラメータの座席属性の種類 | 属性指定で窓側を指定した場合 | | SK | キーワード＝\&quot;CHST\&quot;、フリーテキスト＝チャイルドシート種類をキーにASWDB(マスタ)から取得した項目名 | リクエストパラメータのチャイルドシート申込 | PNRに紐づく全セグメントにおいて、CHSTが登録されていないセグメントへ登録する&lt;br/&gt;更新区分：削除が指定されている場合は、全セグメントにおいてCHSTを削除する | | SSR | SSRコード＝\&quot;CO\&quot; + \&quot;A\&quot;(3席カウチの場合) または\&quot;B\&quot;(4席カウチの場合) + \&quot;A\&quot;(1名利用)または\&quot;B\&quot;(2名利用)または\&quot;C\&quot;(3名利用)または\&quot;D\&quot;(4名利用)（SEG、PAXリレートする） | リクエストパラメータの座席情報 | カウチ席を指定した場合、登録&lt;br&gt;決済失敗時にカウチ席が含まれていた場合、カウチ種別情報を削除する | | SSR | SSRコード&#x3D;\&quot;LOUG\&quot;（SEG、PAXリレートする） | リクエストパラメータのサービス申込のSSRコード | ラウンジを指定した場合 | | SSR | SSRコード＝\&quot;FBAG\&quot;（SEG、PAXリレートする） | リクエストパラメータのサービス申込のSSRコード | ファーストバゲージを指定した場合 | | SSR | SSRコード＝ASWDB(マスタ)で管理されている有料機内食のSSRコード（SEG、PAXリレートする） | リクエストパラメータのサービス申込のSSRコード | 未登録の場合、SSRを登録&lt;br/&gt;SSRが登録済みの場合、登録済みのSSRを削除し新しいSSRを登録 | | SSR | SSRコード＝ASWDB(マスタ)で管理されている特別機内食のSSRコード（SEG、PAXリレートする） | リクエストパラメータのサービス申込のSSRコード | 未登録の場合、SSRを登録&lt;br/&gt;SSRが登録済みの場合、登録済みのSSRを削除し新しいSSRを登録 | | SSR | SSRコード＝ASWDB(マスタ)で管理されている事前ミールのSSRコード（SEG、PAXリレートする） | リクエストパラメータのサービス申込のSSRコード | 未登録の場合、SSRを登録&lt;br/&gt;SSRが登録済みの場合、登録済みのSSRを削除し新しいSSRを登録 | | SSR | SSRコード＝”BSCT”（SEG、PAXリレートあり） | リクエストパラメータの座席情報 | バシネットが紐づくフライトと搭乗者について、カウチ席の登録に成功した場合、そのバシネットを削除する | | SK | キーワード＝”COUC”（SEG、PAXリレートあり） | PNR | カウチ用SKエレメントが登録されている場合、カウチ席を利用しない搭乗者について削除する&lt;br/&gt;※今回の操作では座席の変更を行わないが、既に登録済みの座席について、その座席の属性にカウチ席である旨が含まれる場合、カウチ席を利用しているとみなし、削除は行わない。 | | SK | キーワード＝”STEB”（SEG、PAXリレートあり）| PNR | リトリーブ時点でSKエレメントが登録されていないPNRである、かつ、有料座席が存在するすべてのフライトに対して座席指定が行われない場合に、すべて削除する | | RM | フリーテキスト &#x3D; “ANCILLARY SSR UPGR” （SEG、PAXリレートは行わない）|  | ファーストバゲージを選択中のバウンドに、空席待ちアップグレード済のセグメントが存在する かつ SSR FQTUがリレートされたセグメント/搭乗者が存在する場合 | | RM |“SKYLINK” + ”/” + ”P” + ”/” + 予約番号 + “/” + カウチ種別(カウチ登録時のSSRコード) + “/” + 座席番号(※1) + “/” + カウチ用NCP作成要否(※2) + “//” + NCP座席番号(※3)（SEG、PAXリレートする）|リクエストの座席情報|カウチ席利用時のみ登録する。※ リレートする搭乗者は、カウチ席を利用する代表者、同席者となる全ての搭乗者とする。&lt;br/&gt;※1 1カウチに対する利用人数分の座席番号を設定する。複数座席存在する場合は、代表者の座席から順に列挙し、”,”区切りとする。&lt;br/&gt;※2 カウチ用NCPの作成要否に応じて値を設定する。1カウチ席の座席数 ＞ 当該カウチ席利用人数の場合は”B”(カウチ用NCP作成前)を設定、”B”ではない場合、”N”(カウチ用NCP作成不要)を設定する。&lt;br/&gt;※3 カウチ用NCP作成要の場合のみ設定する。1カウチ席内に属する座席について、搭乗者が割り当てられていない座席番号を”,”区切りで列挙する。| | SK | 搭乗者メールアドレス&lt;br/&gt;フォーマットはキーワード ＝ MAIL、&lt;br/&gt;フリーテキスト ＝ “P” + 言語コード + “T” + メールアドレス（PAXリレートする） | &lt;ol&gt;&lt;li&gt;リクエストの搭乗者メールアドレス&lt;/li&gt;&lt;li&gt;ユーザ共通情報(仮)の言語コード &lt;/li&gt;&lt;/ol&gt; | 未登録の場合はSKを登録&lt;br/&gt;SKが登録済みの場合は登録済みのSKを削除し新しいSKを登録 | | SSR | SSRコード＝”CTCM”(DxAPIでのキー項目：category&#x3D;personal, contactType&#x3D;Phone,purpose&#x3D;notification)、キャリアコード＝”NH”、フリーテキスト＝国番号と電話番号（PAXリレートあり） | リクエストパラメータの搭乗者連絡先情報の電話番号 | 未登録の場合はSSRを登録&lt;br/&gt;SSRが登録済みの場合は、登録済みのSSRを削除し新しいSSRを登録 | | SSR | コード＝\&quot;CTCE\&quot;、&lt;br/&gt;フリーテキスト&#x3D;搭乗者メールアドレス、&lt;br/&gt;キャリアコード＝便名キャリアコード(PAXリレートする。)&lt;br/&gt;※旅程の全便名キャリア分登録する | リクエストパラメータの搭乗者連絡先情報のメールアドレス | 登録済みのCTCEは削除せず、新規に登録する | | RM |フリーテキスト＝“/L-***NH0***-W////ANCILLARY MAIL/”＋サービス種別＋“//”＋申込メールアドレス＋“/”＋言語コード＋サービスに紐づくフライト(※)(PAXリレートする)&lt;br/&gt;※サービスに紐づくフライトは以下の形式で、フライト数分繰り返して出力する。&lt;br/&gt;“/”＋サービスに紐づくフライトの便名キャリア＋便番号4桁(4桁未満は0埋め)＋“-”＋ブッキングクラス＋“-”＋出発日(ddMMMで英語のフォーマット)&lt;br/&gt;※申込対象の有料サービスごとに、サービスの対象となる以下の単位の件数分、登録を行う。&lt;br/&gt;1.有料ASRサービス、カウチサービス、事前ラウンジサービス、または有料ミールサービス⇒セグメント&lt;br/&gt;2.ファーストバゲージサービス⇒バウンド&lt;br/&gt;※サービスの変更や取り消しがある場合でも、RMの削除は行わない。&lt;br/&gt;※サービス種別は、サービスに応じた値をASWDB(マスタ)より取得|サービス種別、申込メールアドレス、画面上表示している言語のメール言語コード、申込対象有料サービスに紐づくフライト情報|リクエストの搭乗者連絡先情報に指定がある場合|  ## 2.ASWDB(Tx)&lt;br/&gt; | 更新テーブル  | 更新内容 | データ取得元 | 条件等 | | :------------- | :------------- | :------------- | :------------- | | 予約購入実績 | 実績内容  | &lt;ol&gt;&lt;li&gt;リクエストパラメータ&lt;/li&gt;&lt;li&gt;PNR&lt;/li&gt;&lt;li&gt;ユーザ共通情報&lt;/li&gt;&lt;/ol&gt; | | | バッチ処理タスク | データ削除  | &lt;ol&gt;&lt;li&gt;リクエストパラメータ&lt;/li&gt;&lt;li&gt;PNR&lt;/li&gt;&lt;/ol&gt; | 処理種別：01（SK COUC削除処理）かつ PNRロケータ＝リクエストパラメータのPNRのデータを対象 | | S2パーソナライズ情報 | 更新に成功した予約基本情報と対応する項目  | &lt;ol&gt;&lt;li&gt;リクエストパラメータ&lt;/li&gt;&lt;/ol&gt; | 予約基本情報の更新が成功した場合 |  ## 3.AMC会員情報&lt;br/&gt; | 更新フィールド  | 更新内容 | データ取得元 | 条件等 | | :------------- | :------------- | :------------- | :------------- | | 予約基本情報 | 決済手段区分 | リクエストパラメータ  | いつもの情報の支払方法の更新が指定された場合 |           | 予約基本情報 | 一般用クレジットカード有効期限 | リクエストパラメータ  | いつもの情報のクレジットカード情報の有効期限更新が指定された場合 |           | 予約基本情報 | 一般用クレジットカード番号、一般用クレジットカード名称、一般用クレジットカード有効期限  | リクエストパラメータ  | いつもの情報のクレジットカード情報新規登録が指定された場合 | &lt;!-- list end --&gt;  # 4.特記事項&lt;br/&gt; 1. エラーのハンドリングについて、以下のとおりとする。     1. muleによる入力チェックに係るエラーについてはすべての入力項目をチェックしたうえでエラーを返却する。     1. PNR情報やカタログ情報、ASWDBなどを突き合せた存在チェック、有効性チェックについては事前座席やサービス登録を実施する前にエラーの有無を判定し、エラー&lt;br/&gt;     があればエラーをまとめて返却する。     1. 座席やサービス登録の処理時にワーニングが発生した場合、指定されたリクエスト内容を一通り処理し終えた段階でワーニングの有無を判定し、申込されたすべての&lt;br/&gt;     有料サービスがワーニングとなった場合は、支払処理前にエラーを返却することとし、有料サービスの一部がワーニングとなった場合は、支払処理前にワーニングを返却&lt;br/&gt;     する。無料のサービスのみの場合は、すべての処理が完了した段階でワーニングとして返却する。 1. 有料サービスのSSR登録後に購入処理失敗などで離脱した場合の考慮としては以下のとおりとする。&lt;br/&gt; 有料サービスのSSR登録後に購入処理に失敗して離脱した場合、SSRのみが残ったままとなる。この場合、AILが付与するTL切れを待つか、コールセンターにてSSRの取消を&lt;br/&gt; 行った後、再申込をするものとし、考慮不要とする。 なお、カウチについては、カウチ種別SSRと座席指定SSRの2つを登録するが、TLが付与されるのはカウチ種別SSRのみ&lt;br/&gt; となる。TL切れで削除されない座席指定SSRについてはコールセンターにてBRAINにて対象を抽出してマニュアルでリカバリを行うものとし、考慮不要とする。  &lt;!-- list end --&gt;  # ToDo(未決課題) 1. 削除処理が失敗した場合のオペレーションが必要かどうかはbacklogにて確認中。解決次第、反映が必要     1. https://asy-pd.backlog.com/view/ANAUIUXS2_DEV-2409
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public ordersUpdateServicesPost(
    generated?: UpdateServicesRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<UpdateServicesResponse>;
  public ordersUpdateServicesPost(
    generated?: UpdateServicesRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<UpdateServicesResponse>>;
  public ordersUpdateServicesPost(
    generated?: UpdateServicesRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<UpdateServicesResponse>>;
  public ordersUpdateServicesPost(
    generated?: UpdateServicesRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/orders/update-services`;
    return this.httpClient.request<UpdateServicesResponse>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要 リクエストパラメータの搭乗者情報をもとに、DxAPIへ搭乗者情報の登録または更新を行う。&lt;br/&gt; 当APIでは、リクエストパラメータについて、項目なし(リクエストパラメータの項目と値の組み合わせについて、両方ともないもの)と、空欄(項目はあるが、値が空)の2つを厳密に区別するものとし、&lt;br/&gt; 項目なしは処理不要のために利用し、空欄はそのリクエストパラメータの内容が空(未登録であれば登録をしない旨、登録済みであれば空にして削除をする旨)であることを表すために利用する。&lt;br/&gt; # 2. 処理内容 1. Mulesoftが行う入力チェック(各項目の型定義などに応じたチェック)にてエラーが発生している場合、&lt;br/&gt;   エラーハンドリング(API)(G01-010)を利用してMulesoftが生成したエラー情報を解析し、ステータスコード400(Bad request)でエラー情報を返却する。&lt;br/&gt; 1. 呼び出し元より渡されたアクセストークンについて、認可検証APIにてcookie、アクセストークンの有効性確認およびTTL延長を行う。&lt;br/&gt;   有効でない場合、ステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。  &lt;br/&gt; 1. PNRの状態に依存しないリクエストパラメータのチェックとして、以下のチェックを行う。&lt;br/&gt;   1. 連絡先情報について、以下条件のいずれかに合致する場合、HTTPステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;     1. 代表者メールアドレスについて、共通部品「入力値変換・入力チェック」(G03-501)の結果がフォーマット不正。&lt;br/&gt;     1. 代表者電話番号情報について、以下条件のいずれかに合致する。&lt;br/&gt;         1. 国番号が日本で、電話番号が9～11桁でない。&lt;br/&gt;         1. 国番号が日本以外の国で、国番号+電話番号が9桁以上でない。&lt;br/&gt;         1. 国番号がASWDB(マスタ)にて連絡電話番号国フラグが不可として登録されている。&lt;br/&gt;     1. アップグレード通知メールアドレスについて、共通部品「入力値変換・入力チェック」(G03-501)の結果がフォーマット不正。&lt;br/&gt;     1. 搭乗者毎のメールアドレスについて、共通部品「入力値変換・入力チェック」(G03-501)の結果がフォーマット不正。&lt;br/&gt;     1. 搭乗者毎の電話番号情報について、以下条件のいずれかに合致する。&lt;br/&gt;         1. 国番号が日本で、電話番号が9～11桁でない。&lt;br/&gt;         1. 国番号が日本以外の国で、国番号+電話番号が9桁以上でない。&lt;br/&gt;         1. 国番号がASWDB(マスタ)にて、搭乗者SMS送信可否が不可として登録されている。&lt;br/&gt;     1. 発着通知メールアドレスについて、共通部品「入力値変換・入力チェック」(G03-501)の結果がフォーマット不正。&lt;br/&gt;     1. 発着通知連絡先情報リストの送信言語がASWDB(マスタ)に言語コード(メール)として登録されていない。&lt;br/&gt;   1. 入国関連情報について、以下条件のいずれかに合致する場合、HTTPステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;     1. 以下のいずれかの項目が指定されている場合は、以下すべての項目の指定が必要となるが、一つでも不足している項目が存在する。&lt;br/&gt;         パスポート姓、パスポート名、生年月日、性別、国籍。&lt;br/&gt;     1. パスポート姓、パスポート名、パスポートミドルネームの合計文字数が60文字以上である。&lt;br/&gt;     1. 性別の項目があり、male（男性）またはfemale（女性）以外である。&lt;br/&gt;     1. パスポート番号、パスポート有効期限、パスポート発行国のいずれかが指定されている場合、一つでも不足している項目が存在する。&lt;br/&gt;     1. パスポート有効期限が日付有効範囲外。ただし、パスポート有効期限の指定無しの場合、本チェックは実施しない。&lt;br/&gt;         日付有効範囲は設定ファイルより取得したパスポート有効期限の最小年以上最大年以下とする。&lt;br/&gt;     1. パスポート情報の発行国の値がASWDB（マスタ）に存在しない、またはAPIS登録対象/パスポート国籍・発行国として使用しないと定義されている。&lt;br/&gt;     1. リクエストパラメータ間で、パスポート姓名、生年月日、性別の組み合わせが完全に同じ項目が複数存在する。&lt;br/&gt;     1. 中国公民身分番号が全て数字、もしくは17桁の数字+末尾X(エックス)でない。&lt;br/&gt;     1. VISA情報とグリーンカード情報両方に値が設定されている。&lt;br/&gt;     1. グリーンカード有効期限が日付有効範囲外。ただし、グリーンカード有効期限の指定無しの場合、本チェックは実施しない。&lt;br/&gt;         日付有効範囲は設定ファイルより取得したグリーンカード有効期限の最小年以上最大年以下とする。&lt;br/&gt;     1. グリーンカード番号が空かつ、グリーンカードの有効期限ありまたはグリーンカードの無期限指定あり。&lt;br/&gt;     1. グリーンカード番号がありかつ、グリーンカードの有効期限なしかつグリーンカードの無期限指定なし。&lt;br/&gt;     1. 滞在先情報の国籍または地区コードが\&quot;US\&quot;(米国)かつ、ビザ番号の桁数が8桁でない。&lt;br/&gt;   1. FFP情報について、マイレージプログラム名がNH（AMC）かつ、以下のいずれかに一致する場合、HTTPステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;     1. FFP会員番号が10桁の数字でない。&lt;br/&gt;     1. FFP会員番号が上9桁の数字を7で割った余りに1を足した値が、下1桁と一致しない。&lt;br/&gt;     1. FFP会員番号をもとにMindsからAMC会員情報が取得できない、または、搭乗者姓名が取得したAMC会員情報の搭乗者姓名と一致しない。&lt;br/&gt;   1. サポート情報について、以下条件のいずれかに合致する場合、HTTPステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;     1. 歩行の程度が指定されており、車いす持ち込み有無が指定されていない。&lt;br/&gt;     1. 車いす持ち込みが持ち込みありの場合、折りたたみ可否と車いす種類が指定されていない。&lt;br/&gt;     1. 車いす種類が電動かつ、バッテリータイプが指定されていない。&lt;br/&gt;     1. 車いす折りたたみ可否が\&quot;UNFOLDABLE\&quot;かつ、以下の車いすサイズのうち、一つでも指定されていないものが存在する。&lt;br/&gt;         1. 車いすサイズ（奥行）&lt;br/&gt;         1. 車いすサイズ（横幅）&lt;br/&gt;         1. 車いすサイズ（高さ）&lt;br/&gt;         1. 車いすサイズ（重さ）&lt;br/&gt;     1. 妊娠中であるかが妊娠中であり、かつ医師の名前、医師の電話番号、出産予定日、現在の状況のいずれかが指定されていない。&lt;br/&gt;     1. 医師の電話番号が以下のいずれかに該当する。&lt;br/&gt;         1. 国番号が日本で、電話番号が9～11桁でない。&lt;br/&gt;         1. 国番号が日本以外の国で、国番号+電話番号が9桁以上でない。&lt;br/&gt;   1. リクエストパラメータの予約基本情報更新区分がtrueの場合、会員情報の取得処理を行う。&lt;br/&gt;     呼び出し元より渡されたアクセストークンを復号し、トークン内に含まれるuuidを基に、ASWDB(Tx)からログイン中の会員情報を取得する。&lt;br/&gt;     AMC会員番号を取得できなかった場合はステータスコード401(Unauthorized)でエラー情報を返して、本処理を中止とする。 1. リクエストパラメータをもとに、PNR情報取得APIからPNR情報を取得する。&lt;br/&gt;   PNR情報が取得できなかった場合、ステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt; 1. PNRの状態に依存するリクエストパラメータのチェックとして、以下のチェックを行う。&lt;br/&gt;   1. PNR情報の搭乗者情報入力案内要否が否の場合、HTTPステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;   1. 連絡先情報について、以下条件のいずれかに合致する場合、HTTPステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;     1. グループPNRで、リクエストパラメータの代表者連絡先情報が項目ありである。&lt;br/&gt;     1. グループPNR、チャネル区分がGDS PNR、チャネル詳細区分マーチャントがANAでないNDC PNRのいずれかに合致し、リクエストパラメータの代表者連絡先情報の電話番号情報、現地連絡先情報リストのいずれかが項目ありである。&lt;br/&gt;     1. PNR情報の代表者メールアドレスが2件以上であり、リクエストパラメータの代表者メールアドレスが項目ありである。&lt;br/&gt;     1. PNR情報の代表者電話番号情報が2件以上であり、リクエストパラメータの代表者電話番号情報が項目ありである。&lt;br/&gt;     1. PNR情報の現地連絡先情報が3件以上であり、リクエストパラメータの現地連絡先情報が項目ありである。&lt;br/&gt;     1. グループPNRまたは、未出発のNHグループ運航便無しの場合、リクエストパラメータの搭乗者毎の電話番号情報が項目ありである。&lt;br/&gt;     1. PNR情報の発着通知メール利用可否が否の場合、リクエストパラメータの搭乗者毎の発着通知連絡先情報が項目ありである。&lt;br/&gt;     1. PNR情報の搭乗者毎の発着通知連絡先情報が3件以上であり、リクエストパラメータの搭乗者毎の発着通知連絡先情報が項目ありである。&lt;br/&gt;     1. 操作オフィスが日本、かつPNR情報の旅程区分が日本国内単独旅程で、リクエストパラメータの代表者連絡先情報の現地連絡先情報リストが項目あり、または搭乗者毎の発着通知連絡先情報の中に送信言語ありのものが存在する。&lt;br/&gt;     1. PNR情報のPNRチャネル区分が国内代理店作成PNRであり、かつリクエストパラメータの代表者連絡先情報のメールアドレス情報、電話番号情報、現地連絡先情報のいずれかが項目ありである。&lt;br/&gt;   1. 入国関連情報について、以下条件のいずれかに合致する場合、HTTPステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;     1. PNR情報から取得した入国関連情報入力案内要否が否の場合、リクエストパラメータの入国関連情報が項目ありである。&lt;br/&gt;     1. PNR情報の搭乗者毎のパスポート情報が2件以上であり、リクエストパラメータのパスポート情報が項目ありである。&lt;br/&gt;     1. 生年月日について、日付有効範囲外の値が存在する。&lt;br/&gt;         日付有効範囲は以下とし、年齢の基準日を旅程内の第一便出発日として計算を行う。&lt;br/&gt;         1. PNRチャネル区分が直営PNRかつ、大人：12歳から99歳&lt;br/&gt;         1. PNRチャネル区分が直営PNRかつ、ヤングアダルト：12歳から15歳&lt;br/&gt;         1. PNRチャネル区分が直営PNR以外かつ、大人、ヤングアダルトの場合、生後8日から99歳&lt;br/&gt;         1. 小児：PNR情報の旅程区分に応じて以下の通り決定&lt;br/&gt;           1. 日本国内単独旅程かつ年齢の基準日が次期PSS移行後日付(設定ファイルにて管理)より前の場合、3歳から11歳&lt;br/&gt;           1. 上記以外の場合、2歳から11歳&lt;br/&gt;         1. 幼児：PNR情報の旅程区分に応じて以下の通り決定&lt;br/&gt;           1. 日本国内単独旅程かつ年齢の基準日が次期PSS移行後日付(設定ファイルにて管理)より前の場合、生後8日から2歳&lt;br/&gt;           1. 上記以外の場合、生後8日から1歳&lt;br/&gt;     1. PNR情報から取得した居住国登録要否が否の場合、リクエストパラメータの居住国が項目ありである。&lt;br/&gt;     1. PNR情報の居住国が2件以上かつ、リクエストパラメータの居住国が項目ありである。&lt;br/&gt;     1. PNR情報から取得した中国公民身分番号登録要否が否の場合、リクエストパラメータの中国公民身分番号が項目ありである。&lt;br/&gt;     1. PNR情報の中国公民身分番号が2件以上かつ、リクエストパラメータの中国公民身分番号が項目ありである。&lt;br/&gt;     1. PNR情報の滞在先ドキュメント情報登録要否が要かつ、「適用国ごとのVISA情報、グリーンカード情報、滞在先リスト」について、項目ありのリクエストパラメータが「グリーンカード情報」または「VISA情報と滞在先情報」または「滞在先情報」のいずれでもない。&lt;br/&gt;     1. PNR情報のVISA情報が同一国で2件以上かつ、リクエストパラメータのVISA情報が項目ありである。&lt;br/&gt;     1. PNR情報のグリーンカード情報が2件以上かつ、リクエストパラメータのグリーンカード情報が項目ありである。&lt;br/&gt;     1. PNR情報の滞在先情報が2件以上かつ、リクエストパラメータの滞在先情報が項目ありである。&lt;br/&gt;     1. PNR情報から取得したRedress Number登録要否が否の場合、リクエストパラメータのredressNumberが項目ありである。&lt;br/&gt;     1. PNR情報のredressNumberが登録済みであり、リクエストパラメータのredressNumberが項目ありである。&lt;br/&gt;     1. PNR情報から取得したknown Traveller Number登録要否が否の場合、リクエストパラメータのknownTravellerNumberが項目ありである。&lt;br/&gt;     1. PNR情報のknownTravellerNumberが登録済みであり、リクエストパラメータのknownTravellerNumberが項目ありである。&lt;br/&gt;   1. FFP情報について、以下条件のいずれかに合致する場合、HTTPステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;     1. PNR情報から取得したFFP情報入力案内要否が否の場合、リクエストパラメータのFFP情報が項目ありである。&lt;br/&gt;     1. リクエストパラメータのマイレージプログラム名とPNR情報のFFPキャリアコードが一致しないかつ、リクエストパラメータのマイレージプログラム名がASWDB（マスタ）に存在しない。&lt;br/&gt;     1. リクエストパラメータのマイレージプログラム名とFFP会員番号がPNR情報（FQTV）と合致せず、リクエストパラメータのマイレージプログラム名が設定ファイルに存在する登録不可FFP情報のキャリアコードと一致する。&lt;br/&gt;     1. リクエストパラメータのマイレージプログラム名とFFP会員番号が同一の組み合わせとして複数存在する。&lt;br/&gt;     1. ANAがマイレージ提携していないFFPが登録されている場合に、リクエストパラメータのFFP情報が項目ありである。&lt;br/&gt;         ※マイレージ提携していないFFPはキャリアコードを基にASWDB(マスタ)で判定する。&lt;br/&gt;     1. SSR FQTVが2つ以上登録されている場合に、リクエストパラメータのFFP情報が項目ありである。&lt;br/&gt;     1. PNR情報から取得した年齢制限のある割引運賃有無、ビジネスきっぷ運賃有無、アップグレード済である日本国内線のセグメント有無のいずれかがtrueであり、かつリクエストパラメータのマイレージプログラム名、FFP会員番号について、PNR情報の取得結果と一致しないものが存在する&lt;br/&gt;     1. PNR情報から取得したANA BizPNR区分がtrueであり、かつANA Bizログインでない。&lt;br/&gt;   1. サポート情報について、以下条件のいずれかに合致する場合、HTTPステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;     1. PNR情報から取得した搭乗者情報系サポート情報案内要否が否の場合、リクエストパラメータのサポート情報が項目ありである。&lt;br/&gt;     1. PNR情報のサポート情報について、歩行程度または車いす情報が2件以上で、リクエストパラメータの同項目が項目ありである。&lt;br/&gt;     1. 非常口座席を選択している搭乗者について、設定ファイルに定義したサポート情報のSSRまたはSKがある、またはSSR CKINでフリーテキストにEXMOが含まれるものがある。&lt;br/&gt;     1. 妊婦情報について、妊娠中であるかがtrueであり、かつ医師の名前、医師の電話番号、出産予定日、現在の状況のいずれかが存在しないまたは値が空である。&lt;br/&gt;     1. PNR情報から取得したPNRオーナーオフィスIDが、設定ファイルに定義されるadam作成のNH3PNRのオフィスコードと合致する&lt;br/&gt;   1. 障がい者割引関連情報について、以下条件のいずれかに合致する場合、HTTPステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;     1. 障がい者割引搭乗者種別が\&quot;handicapped\&quot;または\&quot;menallyHandicapped\&quot;であり、かつ介助対象者の搭乗者IDが指定されている&lt;br/&gt;     1. 障がい者割引搭乗者種別が\&quot;caregiver\&quot;であり、かつ介助対象者の搭乗者IDが以下のいずれかに該当する&lt;br/&gt;         1. 指定されていない、または指定された搭乗者IDに該当する搭乗者がPNR情報に存在しない&lt;br/&gt;         1. 同じ搭乗者を介助対象としている搭乗者が他に存在する&lt;br/&gt;         1. 介助対象としている搭乗者の障がい者割引搭乗者種別が、\&quot;handicapped\&quot;または\&quot;menallyHandicapped\&quot;でない&lt;br/&gt;     1. PNR情報から取得した障がい者割引運賃有無がfalseであり、かつ障がい者割引関連情報が項目ありである。&lt;br/&gt;   1. 離島カード番号について、PNR情報から取得したアイきっぷ運賃有無がfalseであり、かつ離島カード番号が項目ありである場合、HTTPステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;   1. 生年月日(パスポート情報でない、搭乗者毎の情報直下のもの)について、以下のいずれかに該当する場合、HTTPステータスコード400(Bad Request)でエラー情報を返して、本処理を中止とする。&lt;br/&gt;     1. 日付有効範囲外の値のものが存在する(定義は入国関連情報内の生年月日と同様とする)。&lt;br/&gt;     1. 12歳以上となる搭乗者が存在せず、かつ4歳以下となる搭乗者が存在する。&lt;br/&gt;     1. PNR情報にてSSR UMNRとジュニアパイロットケア不要の旨が登録されている搭乗者の年齢が7歳以下となる。 ※4歳以下となる場合と5~7歳となる場合とで異なるエラーとする&lt;br/&gt; 1. リクエストパラメータをもとに、搭乗者情報の登録および更新を行う。&lt;br/&gt;   以下の各処理について、リクエストパラメータの項目がない場合は削除、登録、更新処理のいずれも実施しない。&lt;br/&gt;   削除、登録、更新に予期せぬエラーが発生した場合、HTTPステータスコード500を返却する。&lt;br/&gt;   1. リクエストパラメータの代表者電話番号、現地連絡先情報、搭乗者毎のメールアドレス、電話番号がPNR情報の取得結果と一致しないものについて、DxAPI（contacts）を呼び出し、以下の内容で更新処理を行う。&lt;br/&gt;     1. 代表者電話番号、現地連絡先情報、搭乗者毎の電話番号について、リクエストパラメータが空欄のものを、登録済みの情報から削除する。&lt;br/&gt;     1. 代表者電話番号、現地連絡先情報、搭乗者毎のメールアドレス、電話番号について、PNR情報の取得結果に存在せずリクエストパラメータが空欄でないものを、登録する。ただし、搭乗者毎のメールアドレスについては、PNRの登録状況を問わず、常に追加を行う。&lt;br/&gt;     1. 現地連絡先情報、搭乗者毎の電話番号について、PNR情報の取得結果に存在し、リクエストパラメータが空欄でないものを、リクエストパラメータの内容で更新する。&lt;br/&gt;   1. リクエストパラメータの代表者メールアドレス、アップグレードメールアドレス、搭乗者毎のメールアドレスがPNR情報の取得結果と一致しないものについて、DxAPI（special-keywords）を呼び出し、以下の内容で更新処理を行う。&lt;br/&gt;     1. 対象の項目について、登録済みの情報を削除する。&lt;br/&gt;     1. 対象の項目について、リクエストパラメータの内容で登録する。&lt;br/&gt;   1. リクエストパラメータの発着通知連絡先情報がPNR情報の取得結果と一致しないものについて、DxAPI（remarks）を呼び出し、以下の内容で発着通知連絡先情報を更新する。&lt;br/&gt;     1. リクエストパラメータが空欄のものを、登録済みの情報から削除する。&lt;br/&gt;     1. PNR情報に存在せずリクエストパラメータが空欄でないものを、リクエストパラメータの内容で登録する。&lt;br/&gt;     1. PNR情報に存在し、リクエストパラメータが空欄でないものを、リクエストパラメータの内容で更新する。&lt;br/&gt;   1. リクエストパラメータの入国関連情報がPNR情報の取得結果と一致しないものについて、DxAPI(regulatory-details)を呼び出し、以下の内容で更新処理を行う。&lt;br/&gt;     ただし、パスポート発行国、居住国または地区、適用国について、リクエストパラメータから受け取った値が\&quot;UNO\&quot;かつPNR情報の取得結果が\&quot;UNA\&quot;の場合、本項目については一致しており変更がないものとして扱う。&lt;br/&gt;     1. 対象の項目について、登録済みの情報を削除する。&lt;br/&gt;     1. 対象の項目について、リクエストパラメータの内容で登録する。&lt;br/&gt;   1. リクエストパラメータのFFP情報がPNR情報の取得結果と一致しないものについて、DxAPI（frequentFlyerCards）を呼び出し、以下の内容で更新処理を行う。&lt;br/&gt;     1. 対象の項目について、登録済みの情報を削除する。&lt;br/&gt;     1. 対象の項目について、リクエストパラメータの内容で登録する。&lt;br/&gt;   1. リクエストパラメータのサポート情報がPNR情報の取得結果と一致しないものについて、DxAPI（services）を呼び出し、以下の内容で更新処理を行う。&lt;br/&gt;     1. 対象の項目について、登録済みの情報を削除する。&lt;br/&gt;     1. 対象の項目について、リクエストパラメータの内容で登録する。&lt;br/&gt;   1. 以下の全ての条件に該当する搭乗者について、DxAPI(specialKeywords)を呼び出し、SK NNBPの削除処理を行う(障がい者割引運賃関連)。&lt;br/&gt;     1. リクエストパラメータ内の障がい者割引搭乗者種別が\&quot;handicapped\&quot;または\&quot;mentallyHandicapped\&quot;である&lt;br/&gt;     1. FFP会員番号をもとにMindsから取得したAMC会員情報に障がい者手帳の情報が登録済み&lt;br/&gt;   1. 以下の全ての条件に該当する搭乗者について、DxAPI(specialKeywords)を呼び出し、SK NNBPの登録処理を行う(障がい者割引運賃関連)。&lt;br/&gt;     1. リクエストパラメータ内の障がい者割引搭乗者種別が\&quot;handicapped\&quot;または\&quot;mentallyHandicapped\&quot;である&lt;br/&gt;     1. FFP会員番号をもとにMindsから取得したAMC会員情報に障がい者手帳の情報が登録されていない、またはAMC会員情報が取得できなかった&lt;br/&gt;   1. PNR情報のアイきっぷ運賃有無がtrueである場合、FFP会員番号をもとにMindsから取得したAMC会員情報に離島カード情報が登録されていない、または離島カード情報が以下のいずれかに該当する搭乗者について、DxAPI(specialKeywords)を呼び出し、SK NNBPの削除処理を行う。&lt;br/&gt;     1. 有効期限が現在時刻より前である&lt;br/&gt;     1. 登録されているルート情報(出発地・到着地)が、PNR情報のセグメントの内運賃がアイきっぷであるものの出発地・到着地と一致しない&lt;br/&gt;   1. PNR情報のアイきっぷ運賃有無がtrueである場合、FFP会員番号をもとにMindsから取得したAMC会員情報に離島カード情報が登録済み、かつ離島カード情報が以下の全てに該当する搭乗者について、DxAPI(specialKeywords)を呼び出し、SK NNBPの登録処理を行う。&lt;br/&gt;     1. 有効期限が現在時刻より後である&lt;br/&gt;     1. 登録されているルート情報(出発地・到着地)が、PNR情報のセグメントの内運賃がアイきっぷであるものの出発地・到着地と一致する&lt;br/&gt;   1. リクエストパラメータの生年月日がPNR情報の取得結果と一致しないものについて、DxAPI(regulatory-details)を呼び出し、以下の内容で更新処理を行う。&lt;br/&gt;     1. 対象の項目について、登録済みの情報を削除する。&lt;br/&gt;     1. 対象の項目について、リクエストパラメータの内容で登録する。&lt;br/&gt;   1. 生年月日を変更したことにより、SSR UMNRのフリーテキスト部に\&quot;UMxx\&quot;の形式で登録されている年齢の数値(例:11歳であれば\&quot;UM11\&quot;)が年齢と合致しなくなった搭乗者が存在する場合、&lt;br/&gt;     DxAPI(special-service-requests)を呼び出し、該当するSSR UMNRの削除処理を行い、その後正しい数値で再登録する。&lt;br/&gt; 1. リクエストパラメータの予約基本情報更新区分がtrueかつ、リクエストパラメータのパスポート情報が存在する、かつMinds上のパスポート情報を比較し異なる場合、「予約基本情報」としてMindsへ登録する。&lt;br/&gt; 1. 指定された発着通知メールアドレス宛てに発着通知メールアドレス登録完了メールを送信する。iCASへ発着通知メールアドレス登録完了メールの送信リクエストを行う。&lt;br/&gt;   ただし、メール送信言語のみ変更している、または削除処理の場合は送信を行わない。&lt;br/&gt; 1. PNR情報から取得したANA BizPNR区分がtrueであり、かつリクエストパラメータのFFP情報のマイレージプログラム名が\&quot;NH\&quot;である場合、ANA Bizの実績管理データ更新APIを呼び出し、FFP情報の更新を行う。&lt;br/&gt; 1. PNR情報取得APIから取得したANA BizPNR区分がtrueであり、リクエストパラメータにて指定されたFFP情報とAMC会員情報のFFP情報とが異なり、かつDynamoDBより取得した法人情報にてデータ連携先URLが存在する場合、&lt;br/&gt;   予約情報送信APIを呼び出し、企業への予約情報連携を行う。&lt;br/&gt; 1. 正常終了の場合、HTTPステータスコード201を返却し、本処理を終了する。&lt;br/&gt;  # 3. データ更新内容 | 更新フィールド | 更新内容 | データ取得元 | 条件等 | | ---: | :--- | :--- | :--- | | SK |コード &#x3D; \&quot;MAIL\&quot;&lt;br&gt;フリーテキスト &#x3D; “A” + ASWDB(マスタ)で管理している、操作中の言語に対応するメール用言語コード + “T” + メールアドレス(PAXリレートする) | リクエストパラメータより取得した、代表者メールアドレス | リクエストパラメータが存在し、PNR情報取得APIより取得した情報と異なる場合、登録済みの値を削除し、リクエストパラメータの内容の登録を行う。 | | AP |フリーテキスト &#x3D; “+” + 国番号 + “-” + 電話番号 + “/”(スラッシュ) + “CTC HERE” + “-” + 種別(PAXリレートはしない)&lt;br&gt;※種別は電話番号種別がHOMEの場合は区分”H”、MOBILEの場合は区分”M”、OFFICEの場合は区分”B”とする&lt;br&gt;※国番号が日本、かつ電話番号の先頭が0の場合、電話番号の先頭の0を取り除く&lt;br&gt;※DxAPIのキーは&lt;br&gt;MOBILE：category&#x3D;personal、purpose&#x3D;standard、device&#x3D;mobile&lt;br&gt;HOME：category&#x3D;personal、purpose&#x3D;standard、device&#x3D;landline&lt;br&gt;OFFICE：category&#x3D;business、purpose&#x3D;standardとして登録する。 | リクエストパラメータより取得した、以下の情報&lt;br&gt;1.代表者電話番号種別&lt;br&gt;2.国番号&lt;br&gt;3.電話番号 | リクエストパラメータが存在し、PNR情報取得APIより取得した情報と異なる場合、登録済みの値を削除し、リクエストパラメータの内容の登録を行う。&lt;br&gt;※ DxAPIで更新用(PATCH)のエンドポイントが存在するが、電話番号種別変更は更新処理では行えないため、削除＋登録を行う。 | | AP |フリーテキスト &#x3D; フリーフォーマット + “-”(半角ハイフン) + “L”(PAXリレートはしない)&lt;br&gt;※DxAPIのキーは1A確認中 | リクエストパラメータより取得した現地連絡先情報リスト | リクエストパラメータの現地連絡先情報リストの件数と登録状況に応じて以下の処理を行う。&lt;br&gt;1. リクエストパラメータの件数が1件以上で、登録が0件の場合、すべて登録&lt;br&gt;2. リクエストパラメータの件数が0件で、登録が1件以上の場合、すべて削除&lt;br&gt;3. リクエストパラメータと登録の件数が同じで、ともに1件以上の場合、すべて更新&lt;br&gt;4. リクエストパラメータの件数が2件で、登録が1件の場合、1件目を更新し、2件目を登録&lt;br&gt;5. リクエストパラメータの件数が1件で、登録が2件の場合、1件目を更新し、2件目を削除 | | SK |コード  &#x3D; \&quot;MAIL\&quot;&lt;br&gt;フリーテキスト &#x3D; “U” + ASWDB(マスタ)で管理している、操作中の言語に対応するメール用言語コード + “T” + メールアドレス(PAXリレートする※)&lt;br&gt;※変更前と同じPAXにリレートする。 | リクエストパラメータより取得した、アップグレード通知メールアドレス | リクエストパラメータとPNR情報より取得した同じ順番のアップグレード通知メールアドレスについて、内容が異なる場合、登録済みの値を削除し、リクエストパラメータの内容で登録を行う。 | | SK |コード &#x3D; \&quot;MAIL\&quot;&lt;br&gt;フリーテキスト &#x3D; “P” + ASWDB(マスタ)で管理している、操作中の言語に対応するメール用言語コード + “T” + メールアドレス(PAXリレートする) | リクエストパラメータより取得した搭乗者メールアドレス | リクエストパラメータが存在し、PNR情報取得APIより取得した情報と異なる搭乗者について、リクエストパラメータの値に応じて以下の処理を行う。&lt;br&gt;1.登録済みの値がある場合、それを削除。&lt;br&gt;2.リクエストパラメータが空欄でない場合、リクエストパラメータの内容を登録。 | | SK |キーワード &#x3D; \&quot;NNBP\&quot;&lt;br/&gt;フリーテキスト &#x3D; \&quot;CHECK DOCS FOR FARE\&quot; | リクエストパラメータより取得した以下の情報&lt;br/&gt;1.障がい者割引運賃関連情報&lt;br/&gt;2.AMC会員番号をもとにMindsより取得したAMC会員情報&lt;br/&gt;3.離島カード番号 | データ取得元の情報に応じて以下の処理を行う。&lt;br/&gt;1.以下のいずれかに該当する場合、更新内容の値を登録。&lt;br/&gt;  1-1.障がい者割引搭乗者種別が\&quot;handicapped\&quot;または\&quot;mentallyHandicapped\&quot;であり、かつAMC会員情報に障がい者手帳の情報が登録済みでない&lt;br/&gt;  1-2.離島カード番号が存在し、かつアイきっぷ運賃であるセグメントの出発地・到着地と適合する期限内の離島カードの情報がAMC会員情報に登録済みでない&lt;br/&gt;2.以下のいずれかに該当する場合、更新内容の値のSKエレメントを削除。&lt;br/&gt;  2-1.障がい者割引搭乗者種別が\&quot;handicapped\&quot;または\&quot;mentallyHandicapped\&quot;であり、かつAMC会員情報に障がい者手帳の情報が登録済みである&lt;br/&gt;  2-2.離島カード番号が存在し、かつアイきっぷ運賃であるセグメントの出発地・到着地と適合する期限内の離島カードの情報がAMC会員情報に登録済みである | | SSR |コード &#x3D; \&quot;CTCE\&quot;&lt;br&gt;キャリアコード＝販売キャリアコード&lt;br&gt;フリーテキスト＝搭乗者メールアドレスとASWDB(マスタ)で管理している、操作中の言語に対応するIATA用言語コードが含まれた文字列&lt;br&gt;（SEGリレートなし、PAXリレートあり）&lt;br&gt;※DxAPIのキーはcategory&#x3D;personal,contactType&#x3D;Email,purpose&#x3D;notificationとして登録する。&lt;br&gt;※PNRに存在するセグメントの販売キャリアの種類の数だけ登録| リクエストパラメータより取得した、搭乗者メールアドレス | リクエストパラメータが存在し、PNR情報取得APIより取得した情報と異なる搭乗者について、リクエストパラメータの内容の登録を行う。&lt;br&gt;※ SSR CTCEではなく、SK MAILの搭乗者メールアドレスにて比較を行い、異なる場合にSSR CTCEへの追加登録を行う。&lt;br&gt;※グループPNRの場合、登録を行わない。 | | SSR |コード &#x3D; \&quot;CTCM\&quot;、&lt;br&gt;キャリアコード＝NH&lt;br&gt;フリーテキスト＝搭乗者SMSの国番号と電話番号、ASWDBで管理している、操作中の言語に対応するIATA用言語コードが含まれた文字列（SEGリレートなし、PAXリレートあり）&lt;br&gt;※国番号が日本、かつ電話番号の先頭が0の場合、電話番号の先頭の0を取り除く。&lt;br&gt;※ASWDBに該当するIATA用言語コードが存在しない場合は、言語コードは登録しない。&lt;br&gt;※DxAPIのキーはcategory&#x3D;personal, contactType&#x3D;Phone,purpose&#x3D;notificationとして登録する。&lt;br&gt;※キャリアコード＝NHのSSRのみ登録| リクエストパラメータより取得した、以下の情報&lt;br&gt;搭乗者連絡先情報&lt;br&gt;1.搭乗者SMS国番号&lt;br&gt;2.搭乗者SMS番号 | リクエストパラメータが存在し、PNR情報取得APIより取得した情報と異なる搭乗者について、リクエストパラメータの値に応じて以下の処理を行う。&lt;br&gt;1.登録済みの値がある場合、それを削除。&lt;br&gt;2.リクエストパラメータが空欄でない場合、リクエストパラメータの内容を登録。 | | RM |コード &#x3D; \&quot;MAIL\&quot;&lt;br&gt;フリーテキスト &#x3D; “D” + ASWDB(マスタ)で管理している、操作中の言語に対応するメール用言語コード + “T” + メールアドレス + “:”(コロン) + メール受取人名(PAXリレートする)| リクエストパラメータより取得した発着通知連絡先情報リスト | リクエストパラメータが存在し、PNR情報取得APIより取得した情報と異なる搭乗者について、リクエストパラメータの発着通知連絡先情報リストの件数と登録状況に応じて以下の処理を行う。&lt;br&gt;1 リクエストパラメータの件数が1件以上で、登録が0件の場合、すべて登録&lt;br&gt;2 リクエストパラメータの件数が0件で、登録が1件以上の場合、すべて削除&lt;br&gt;3 リクエストパラメータと登録の件数が同じで、ともに1件以上の場合、すべて更新&lt;br&gt;4 リクエストパラメータの件数が2件で、登録が1件の場合、1件目を更新し、2件目を登録&lt;br&gt;5 リクエストパラメータの件数が1件で、登録が2件の場合、1件目を更新し、2件目を削除 | | SSR |コード &#x3D; \&quot;DOCS\&quot;&lt;br&gt;フリーテキスト &#x3D; \&quot;P\&quot; + 国籍コード + パスポート番号 + 国籍または地区 + 生年月日 + 性別 + パスポート有効期限 + 姓 + 名 + ミドルネーム&lt;br&gt;※各項目の間には\&quot;/\&quot;(スラッシュ)を含む。| リクエストパラメータより取得した、以下の情報&lt;br&gt;1.パスポート名&lt;br&gt;2.パスポートミドルネーム&lt;br&gt;3.パスポート姓&lt;br&gt;4.生年月日(※)&lt;br&gt;5.パスポート性別&lt;br&gt;6.パスポート国籍&lt;br&gt;7.パスポート番号&lt;br&gt;8.パスポート有効期限&lt;br&gt;9.パスポート発行国&lt;br/&gt;※国際線旅程である場合はパスポート生年月日、日本国内単独旅程である場合は生年月日を使用する。また、後者の場合はパスポート情報が存在しないため、生年月日以外は空で登録する。 | リクエストパラメータが存在し、PNR情報取得APIより取得した情報と異なる搭乗者について、リクエストパラメータの値に応じて以下の処理を行う。&lt;br&gt;1.登録済みの値がある場合、それを削除。&lt;br&gt;2.リクエストパラメータが空欄でない場合、リクエストパラメータの内容を登録。 | | SSR |コード &#x3D; \&quot;DOCA\&quot;&lt;br&gt;フリーテキスト &#x3D; \&quot;R\&quot; + “/”(スラッシュ) + 居住国または地区| リクエストパラメータより取得した、パスポート情報の居住国または地区 | リクエストパラメータが存在し、PNR情報取得APIより取得した情報と異なる搭乗者について、リクエストパラメータの値に応じて以下の処理を行う。&lt;br&gt;1.登録済みの値がある場合、それを削除。&lt;br&gt;2.リクエストパラメータが空欄でない場合、リクエストパラメータの内容を登録。&lt;br&gt;※同伴幼児については同伴する大人の情報を登録する。 | | SSR |コード &#x3D; \&quot;DOCO\&quot;&lt;br&gt;フリーテキスト &#x3D; \&quot;V\&quot; + VISA番号 + 適用国の国コード&lt;br&gt;※フリーテキストの先頭、各項目の間には\&quot;/\&quot;(スラッシュ)を含む。VISA番号と適用国の国コードの間は3つ\&quot;/\&quot;とする。| リクエストパラメータより取得した、以下の情報&lt;br&gt;入国関連情報&lt;br&gt;1.VISA番号&lt;br&gt;2.適用国の国コード | リクエストパラメータが存在し、PNR情報取得APIより取得した情報と異なる搭乗者について、リクエストパラメータの値に応じて以下の処理を行う。&lt;br&gt;1.登録済みの値がある場合、それを削除。&lt;br&gt;2.リクエストパラメータが空欄でない場合、リクエストパラメータの内容を登録。 | | SSR |コード &#x3D; \&quot;DOCS\&quot;&lt;br&gt;フリーテキスト &#x3D; \&quot;C\&quot; + 適用国の国コード + グリーンカード番号 + 生年月日 + 性別 + グリーンカード有効期限 + 姓 + 名 + ミドルネーム &lt;br&gt;※有効期限がない場合は、グリーンカード有効期限を1999年12月31日とする。&lt;br&gt;※各項目の間には\&quot;/\&quot;(スラッシュ)を含む。グリーンカード番号と生年月日の間にはもう1つ\&quot;/\&quot;(スラッシュ)を含む。| リクエストパラメータより取得した、以下の情報&lt;br&gt;入国関連情報及びパスポート情報&lt;br&gt;1.適用国の国コード&lt;br&gt;2.グリーンカード番号&lt;br&gt;3.パスポート生年月日&lt;br&gt;4.パスポート性別&lt;br&gt;5.グリーンカード有効期限&lt;br&gt;6.パスポート姓&lt;br&gt;7.パスポート名&lt;br&gt;8.パスポートミドルネーム&lt;br&gt;9.無期限のグリーンカードかどうか | リクエストパラメータが存在し、PNR情報取得APIより取得した情報と異なる搭乗者について、リクエストパラメータの値に応じて以下の処理を行う。&lt;br&gt;1.登録済みの値がある場合、それを削除。&lt;br&gt;2.リクエストパラメータが空欄でない場合、リクエストパラメータの内容を登録。&lt;br&gt;※パスポート情報が複数存在する場合、登録済みの1件目のパスポート情報をもとに、パスポート関連の情報を登録する。&lt;br&gt;※グリーンカード登録後にパスポート情報の生年月日を更新したら、グリーンカードの情報も一緒に更新される。 | | SSR |コード &#x3D; \&quot;DOCA\&quot;&lt;br&gt;フリーテキスト &#x3D; \&quot;D\&quot; + 国 + 滞在先住所名 + 都市名 + 州名 + ZIPコード&lt;br&gt;トランジットの場合、以下の値で登録。&lt;br&gt;フリーテキスト &#x3D; \&quot;D\&quot; + 国(“USA”) + 滞在先住所名(\&quot;TRANSIT\&quot;) + 都市名(\&quot;TRANSIT\&quot;) + 州名(“NY”) + ZIPコード(“99999”)&lt;br&gt;※各項目の間には\&quot;/\&quot;(スラッシュ)を含む。| リクエストパラメータより取得した、以下の情報&lt;br&gt;入国関連情報&lt;br&gt;1.滞在先住所（ホテル名）&lt;br&gt;2.都市名&lt;br&gt;3.州名&lt;br&gt;4.郵便番号（ZIPコード）&lt;br&gt;5.国＝“US”(アメリカ) | リクエストパラメータが存在し、PNR情報取得APIより取得した情報と異なる搭乗者について、リクエストパラメータの値に応じて以下の処理を行う。&lt;br&gt;1.登録済みの値がある場合、それを削除。&lt;br&gt;2.リクエストパラメータが空欄でない場合、リクエストパラメータの内容を登録。 | | SSR |コード &#x3D; \&quot;DOCO\&quot;&lt;br&gt;フリーテキスト &#x3D; “/”(スラッシュ) + \&quot;K\&quot; + Known Traveller Number + “/”(スラッシュ) + 発行国（\&quot;US\&quot;固定）&lt;br&gt;(PAXリレートあり、SEGリレートなし。)| リクエストパラメータより取得した、以下の情報&lt;br&gt;入国関連情報&lt;br&gt;1.Known Traveller Number&lt;br&gt;2.発行国(“US”(アメリカ)固定) | リクエストパラメータが空欄でない場合、リクエストパラメータの内容で登録を行う。 | | SSR |コード &#x3D; \&quot;DOCO\&quot;&lt;br&gt;フリーテキスト &#x3D; “/”(スラッシュ) + \&quot;R\&quot; + Redress number + “/”(スラッシュ) + 発行国（\&quot;US\&quot;）&lt;br&gt;(PAXリレートあり、SEGリレートなし。)| リクエストパラメータより取得した、以下の情報&lt;br&gt;入国関連情報&lt;br&gt;1.Redress number&lt;br&gt;2.発行国(“US”(アメリカ)固定)| リクエストパラメータが空欄でない場合、リクエストパラメータの内容で登録を行う。 | | SSR |コード &#x3D; \&quot;FOID\&quot;&lt;br&gt;フリーテキスト &#x3D; 中国公民身分番号| リクエストパラメータより取得した、入国関連情報の中国公民身分番号| リクエストパラメータが存在し、PNR情報取得APIより取得した情報と異なる搭乗者について、リクエストパラメータの値に応じて以下の処理を行う。&lt;br&gt;1.登録済みの値がある場合、それを削除。&lt;br&gt;2.リクエストパラメータが空欄でない場合、リクエストパラメータの内容を登録。 | | SSR |コード &#x3D; \&quot;FQTV\&quot;&lt;br&gt;フリーテキスト &#x3D; マイレージプログラム名 + FFP番号&lt;br&gt;※PAXリレートする。| リクエストパラメータより取得した、以下の情報&lt;br&gt;FFP情報&lt;br&gt;1.マイレージプログラム名&lt;br&gt;2.FFP番号| リクエストパラメータが存在し、PNR情報取得APIより取得した情報と異なる搭乗者について、リクエストパラメータの値に応じて以下の処理を行う。&lt;br&gt;1.登録済みの値がある場合、それを削除。&lt;br&gt;2.リクエストパラメータが空欄でない場合、リクエストパラメータの内容を登録。 | | SSR |コード &#x3D; \&quot;FQTS\&quot;&lt;br&gt;フリーテキスト &#x3D; マイレージプログラム名(\&quot;NH\&quot;) + FFP番号&lt;br&gt;※PAXリレートする。| 1.リクエストパラメータより取得した、FFP情報のFFP会員番号&lt;br&gt;2.リクエストパラメータより取得した、FFP情報のログインユーザのFFP会員番号| 1.リクエストパラメータが存在し、マイレージプログラム名＝\&quot;NH\&quot;かつ、PNR情報取得APIより取得した情報が存在しない搭乗者について、登録を行う。&lt;br&gt;2.リクエストパラメータが存在し、搭乗者がログインユーザと一致し、PNR情報取得APIより取得した情報が存在しない搭乗者について登録を行う。 | | | SSR |コード &#x3D; 歩行程度のSSRコード| リクエストパラメータより取得した、サポート情報の歩行程度のSSRコード| リクエストパラメータが存在し、PNR情報取得APIより取得した情報と異なる搭乗者について、登録済みの値を削除し、リクエストパラメータの内容の登録を行う。 | | SSR |コード &#x3D; 車いす種類と、バッテリータイプに応じて以下。&lt;br&gt;1.車いす種類が「手動」の場合、\&quot;WCMP\&quot;&lt;br&gt;2.バッテリータイプが「ニッカド」「ニッケル水素」「リチウムイオン」の場合、\&quot;WCBD\&quot;&lt;br&gt;3.バッテリータイプが「シールド」「ノンシールド」の場合。\&quot;WCBW\&quot;&lt;br&gt;フリーテキスト＝車いす折り畳み可否に応じて以下。&lt;br&gt;1.「はい」の場合&lt;br&gt;　\&quot;999\&quot; + \&quot;×\&quot; + \&quot;999\&quot; + \&quot;×\&quot; + \&quot;999\&quot; + \&quot;CM\&quot; + \&quot;×\&quot; + \&quot;999\&quot; + \&quot;KG\&quot; + \&quot;FOLDABLE\&quot;&lt;br&gt;2.「いいえ」の場合&lt;br&gt;高さ + \&quot;×\&quot; + 横幅 + \&quot;×\&quot; + 奥行 + \&quot;CM\&quot; + \&quot;×\&quot; + 重さ + \&quot;KG\&quot; + \&quot;UNFOLDABLE\&quot;| リクエストパラメータより取得した、以下の情報&lt;br&gt;サポート情報&lt;br&gt;1.車いす種類&lt;br&gt;2.バッテリータイプ&lt;br&gt;3.車いす折りたたみ&lt;br&gt;4.車いすサイズ(奥行)&lt;br&gt;5.車いすサイズ(横幅)&lt;br&gt;6.車いすサイズ(高さ)&lt;br&gt;7.車いすサイズ(重さ)| リクエストパラメータが存在し、PNR情報取得APIより取得した情報と異なる搭乗者について、リクエストパラメータの値に応じて以下の処理を行う。&lt;br&gt;1.登録済みの値がある場合、それを削除。&lt;br&gt;2.リクエストパラメータが空欄でない場合、リクエストパラメータの内容を登録。 | | SSR |コード &#x3D; \&quot;BLND\&quot;| リクエストパラメータより取得した、サポート情報の視覚障がい| リクエストパラメータが存在し、PNR情報取得APIより取得した情報と異なる搭乗者について、リクエストパラメータの値に応じて以下の処理を行う。&lt;br/&gt;1.登録済みの値がある場合、それを削除。&lt;br/&gt;2.リクエストパラメータが空欄でない場合、リクエストパラメータの内容を登録。 | | SSR |コード &#x3D; \&quot;DEAF\&quot;| リクエストパラメータより取得した、サポート情報の聴覚障がい| リクエストパラメータが存在し、PNR情報取得APIより取得した情報と異なる搭乗者について、リクエストパラメータの値に応じて以下の処理を行う。&lt;br/&gt;1.登録済みの値がある場合、それを削除。&lt;br/&gt;2.リクエストパラメータが空欄でない場合、リクエストパラメータの内容を登録。 | | SK |キーワード &#x3D; \&quot;EXMO\&quot;&lt;br&gt;フリーテキスト &#x3D; 出産予定日(DDMMMYY形式)| リクエストパラメータより取得した、妊婦情報の出産予定日| リクエストパラメータが存在し、PNR情報取得APIより取得した情報と異なる搭乗者について、リクエストパラメータの値に応じて以下の処理を行う。&lt;br/&gt;1.登録済みの値がある場合、それを削除。&lt;br/&gt;2.リクエストパラメータが空欄でない場合、リクエストパラメータの内容を登録。 | | SSR |コード &#x3D; \&quot;OTHS\&quot;&lt;br/&gt;フリーテキスト &#x3D; 以下の3種類&lt;br/&gt;1.\&quot;//EXMO//01 \&quot; + 医師の名前 + \&quot;/\&quot; + 電話番号&lt;br/&gt;2.\&quot;//EXMO//02 \&quot; + \&quot;TIME OF CONFINEMENT \&quot; + 出産予定日(DDMMMYY形式)&lt;br/&gt;3.\&quot;//EXMO//03 \&quot; + 現在の状況&lt;br/&gt;※フリーテキストの種類数分、SSR OTHSを登録する。| リクエストパラメータより取得した、以下の情報&lt;br/&gt;妊婦情報&lt;br/&gt;1.医師の名前&lt;br/&gt;2.電話番号&lt;br/&gt;3.出産予定日&lt;br/&gt;4.現在の状況| リクエストパラメータが存在し、PNR情報取得APIより取得した情報と異なる搭乗者について、リクエストパラメータの値に応じて以下の処理を行う。&lt;br/&gt;1.登録済みの値がある場合、それを削除。&lt;br/&gt;2.リクエストパラメータが空欄でない場合、リクエストパラメータの内容を登録。 | | SSR |コード &#x3D; \&quot;UMNR\&quot;&lt;br/&gt;フリーテキスト &#x3D; \&quot;UMxx\&quot;(xxは年齢の数値)| リクエストパラメータより取得した生年月日| リクエストパラメータが存在し、PNR情報取得APIより取得した情報と異なる搭乗者について、リクエストパラメータの値に応じて以下の処理を行う。&lt;br/&gt;1.登録済みの値がある場合、それを削除。&lt;br/&gt;2.リクエストパラメータが空欄でない場合、リクエストパラメータの内容を登録。 |  # 4. 特記事項 1. メールアドレス変更時、SK MAILは古いものを削除した上で新しい内容を登録するが、SSR CTCEは他社で登録したCTCEである可能性があるため、古いものを削除せず新規で追加する。&lt;br/&gt; 1. SSR CTCEの登録における記号の変換(@(アットマーク)→//（スラッシュ2つ）、_(アンダースコア)→..(ピリオド2つ)、-(ハイフン)→./(ピリオド+スラッシュ)については、DxAPI側で行われるため、考慮不要とする。&lt;br/&gt; 1. SSR DOCSに、旅客の生年月日のみが登録されているものが存在する。パスポート情報の登録を行う際にこのSSR DOCSが存在する場合は削除した上で新たにパスポート情報を登録する。&lt;br/&gt;
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public ordersUpdateTravelersPost(
    generated?: UpdateTravelersRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<UpdateTravelersResponse>;
  public ordersUpdateTravelersPost(
    generated?: UpdateTravelersRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<UpdateTravelersResponse>>;
  public ordersUpdateTravelersPost(
    generated?: UpdateTravelersRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<UpdateTravelersResponse>>;
  public ordersUpdateTravelersPost(
    generated?: UpdateTravelersRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/orders/update-travelers`;
    return this.httpClient.request<UpdateTravelersResponse>('post', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: generated,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * # 1. 概要 フライト毎のWi-Fi利用可否を、ASWDB(tx)に対して登録・更新する。  # 2. 処理内容 1. リクエストパラメータの運航日、キャリアコード、便番号毎のWi-Fi利用可否を更新する。 2. ASWDB(マスタ)に運航日、キャリアコード、便番号が未登録の場合、運航日、キャリアコード、便番号をキーにWi-Fi利用可否を新規登録する。 3. ステータスコード200(正常)を返却し処理を終了する。  # 3. データ更新内容 - 呼び出し元より渡された運航日、キャリアコード、便番号に紐づくWi-Fi利用可否情報  # 4. 特記事項 - なし &lt;br/&gt;
   * @param generated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateWifiRecordsPost(
    generated?: UpdateWifiRecordsRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<Array<CreateMycarValetResponseWarningsInner>>;
  public updateWifiRecordsPost(
    generated?: UpdateWifiRecordsRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpResponse<Array<CreateMycarValetResponseWarningsInner>>>;
  public updateWifiRecordsPost(
    generated?: UpdateWifiRecordsRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<HttpEvent<Array<CreateMycarValetResponseWarningsInner>>>;
  public updateWifiRecordsPost(
    generated?: UpdateWifiRecordsRequest,
    observe: any = 'body',
    reportProgress = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    const localVarPath = `/update-wifi-records`;
    return this.httpClient.request<Array<CreateMycarValetResponseWarningsInner>>(
      'post',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: generated,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }
}
